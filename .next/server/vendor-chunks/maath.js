"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/maath";
exports.ids = ["vendor-chunks/maath"];
exports.modules = {

/***/ "(ssr)/./node_modules/maath/dist/buffer-6b4e8456.cjs.dev.js":
/*!************************************************************!*\
  !*** ./node_modules/maath/dist/buffer-6b4e8456.cjs.dev.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar objectSpread2 = __webpack_require__(/*! ./objectSpread2-32cd2c34.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/objectSpread2-32cd2c34.cjs.dev.js\");\nvar triangle_dist_maathTriangle = __webpack_require__(/*! ./triangle-33ffdfef.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/triangle-33ffdfef.cjs.dev.js\");\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\nvar misc_dist_maathMisc = __webpack_require__(/*! ./misc-fce4d494.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/misc-fce4d494.cjs.dev.js\");\nvar vector2_dist_maathVector2 = __webpack_require__(/*! ./vector2-f44fd63e.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/vector2-f44fd63e.cjs.dev.js\");\nvar vector3_dist_maathVector3 = __webpack_require__(/*! ./vector3-5e723d1a.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/vector3-5e723d1a.cjs.dev.js\");\n\nfunction swizzle(buffer) {\n  var stride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  var swizzle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"xyz\";\n  var o = {\n    x: 0,\n    y: 0,\n    z: 0\n  };\n\n  for (var _i = 0; _i < buffer.length; _i += stride) {\n    o.x = buffer[_i];\n    o.y = buffer[_i + 1];\n    o.z = buffer[_i + 2];\n\n    var _swizzle$split = swizzle.split(\"\"),\n        _swizzle$split2 = triangle_dist_maathTriangle._slicedToArray(_swizzle$split, 3),\n        x = _swizzle$split2[0],\n        y = _swizzle$split2[1],\n        z = _swizzle$split2[2]; // TODO Fix this ugly type\n\n\n    buffer[_i] = o[x];\n    buffer[_i + 1] = o[y];\n\n    if (stride === 3) {\n      buffer[_i + 2] = o[z];\n    }\n  }\n\n  return buffer;\n}\n/**\n * @param buffer A stride 2 points buffer\n * @param valueGenerator A function that returns the value of the z axis at index i\n * @returns\n */\n\nfunction addAxis(buffer, size) {\n  var valueGenerator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n    return Math.random();\n  };\n  var newSize = size + 1;\n  var newBuffer = new Float32Array(buffer.length / size * newSize);\n\n  for (var _i2 = 0; _i2 < buffer.length; _i2 += size) {\n    var _j = _i2 / size * newSize;\n\n    newBuffer[_j] = buffer[_i2];\n    newBuffer[_j + 1] = buffer[_i2 + 1];\n\n    if (size === 2) {\n      newBuffer[_j + 2] = valueGenerator(_j);\n    }\n\n    if (size === 3) {\n      newBuffer[_j + 2] = buffer[_i2 + 2];\n      newBuffer[_j + 3] = valueGenerator(_j);\n    }\n  }\n\n  return newBuffer;\n}\n/**\n * Lerps bufferA and bufferB into final\n *\n * @param bufferA\n * @param bufferB\n * @param final\n * @param t\n */\n\nfunction lerp(bufferA, bufferB, _final, t) {\n  for (var _i3 = 0; _i3 < bufferA.length; _i3++) {\n    _final[_i3] = misc_dist_maathMisc.lerp(bufferA[_i3], bufferB[_i3], t);\n  }\n} // TODO add stride\n// TODO Fix types & vectors\n\n/**\n *\n * Translate all points in the passed buffer by the passed translactionVector.\n *\n * @param buffer\n * @param translationVector\n * @returns\n */\n\nfunction translate(buffer, translationVector) {\n  var stride = translationVector.length;\n\n  for (var _i4 = 0; _i4 < buffer.length; _i4 += stride) {\n    buffer[_i4] += translationVector[0];\n    buffer[_i4 + 1] += translationVector[1];\n    buffer[_i4 + 2] += translationVector[2];\n  }\n\n  return buffer;\n} // TODO add stride\n// TODO remove quaternion & vector3 dependencies\n\nfunction rotate(buffer, rotation) {\n  var defaultRotation = {\n    center: [0, 0, 0],\n    q: new THREE.Quaternion().identity()\n  };\n  var v = new THREE.Vector3();\n\n  var _defaultRotation$rota = objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, defaultRotation), rotation),\n      q = _defaultRotation$rota.q,\n      center = _defaultRotation$rota.center;\n\n  for (var _i5 = 0; _i5 < buffer.length; _i5 += 3) {\n    v.set(buffer[_i5] - center[0], buffer[_i5 + 1] - center[1], buffer[_i5 + 2] - center[2]);\n    v.applyQuaternion(q);\n    buffer[_i5] = v.x + center[0];\n    buffer[_i5 + 1] = v.y + center[1];\n    buffer[_i5 + 2] = v.z + center[1];\n  }\n\n  return buffer;\n}\nfunction map(buffer, stride, callback) {\n  for (var _i6 = 0, _j2 = 0; _i6 < buffer.length; _i6 += stride, _j2++) {\n    if (stride === 3) {\n      var res = callback([buffer[_i6], buffer[_i6 + 1], buffer[_i6 + 2]], _j2);\n      buffer.set(res, _i6);\n    } else {\n      buffer.set(callback([buffer[_i6], buffer[_i6 + 1]], _j2), _i6);\n    }\n  }\n\n  return buffer;\n}\n/**\n * Reduces passed buffer\n */\n\nfunction reduce(b, stride, callback, acc) {\n  for (var _i7 = 0, _j3 = 0; _i7 < b.length; _i7 += stride, _j3++) {\n    if (stride === 2) {\n      acc = callback(acc, [b[_i7], b[_i7 + 1]], _j3);\n    } else {\n      acc = callback(acc, [b[_i7], b[_i7 + 1], b[_i7 + 2]], _j3);\n    }\n  }\n\n  return acc;\n}\nfunction expand(b, stride, opts) {\n  var defaultExpandOptions = {\n    center: [0, 0, 0]\n  };\n\n  var _defaultExpandOptions = objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, defaultExpandOptions), opts),\n      center = _defaultExpandOptions.center,\n      distance = _defaultExpandOptions.distance;\n\n  for (var _i8 = 0; _i8 < b.length; _i8 += stride) {\n    /**\n     * 1. translate to origin (subtract the scaling center)\n     * 2. scale by the correct amount (multiply by a constant)\n     * 2. translate from origin (add the scaling center)\n     */\n    b[_i8] = (b[_i8] - center[0]) * (1 + distance) + center[0];\n    b[_i8 + 1] = (b[_i8 + 1] - center[1]) * (1 + distance) + center[1];\n\n    if (stride === 3) {\n      b[_i8 + 2] = (b[_i8 + 2] - center[1]) * (1 + distance) + center[2];\n    }\n  }\n\n  return b;\n}\nfunction center(myBuffer, stride) {\n  return reduce(myBuffer, stride, function (acc, point) {\n    if (stride === 3) {\n      // some type hacking is necessary to avoid type errors going from [n, n] => [n, n, n]\n      // but it's not an actual problem, as this path would always get a v3\n      acc = vector3_dist_maathVector3.add(acc, point);\n    } else {\n      acc = vector2_dist_maathVector2.add(acc, point);\n    }\n\n    return acc;\n  }, vector2_dist_maathVector2.zero());\n}\nfunction sort(myBuffer, stride, callback) {\n  // 1. make an array of the correct size\n  var indices = Int16Array.from({\n    length: myBuffer.length / stride\n  }, function (_, i) {\n    return i;\n  }); // 2. sort the indices array\n\n  indices.sort(function (a, b) {\n    var pa = myBuffer.slice(a * stride, a * stride + stride);\n    var pb = myBuffer.slice(b * stride, b * stride + stride);\n    return callback(pa, pb);\n  }); // 3. make a copy of the original array to fetch indices from\n\n  var prevBuffer = myBuffer.slice(0); // 4. mutate the passed array\n\n  for (var _i9 = 0; _i9 < indices.length; _i9++) {\n    var _j4 = indices[_i9];\n    myBuffer.set(prevBuffer.slice(_j4 * stride, _j4 * stride + stride), _i9 * 3);\n  }\n\n  return myBuffer;\n}\n\nvar buffer = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  swizzle: swizzle,\n  addAxis: addAxis,\n  lerp: lerp,\n  translate: translate,\n  rotate: rotate,\n  map: map,\n  reduce: reduce,\n  expand: expand,\n  center: center,\n  sort: sort\n});\n\nexports.addAxis = addAxis;\nexports.buffer = buffer;\nexports.center = center;\nexports.expand = expand;\nexports.lerp = lerp;\nexports.map = map;\nexports.reduce = reduce;\nexports.rotate = rotate;\nexports.sort = sort;\nexports.swizzle = swizzle;\nexports.translate = translate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9idWZmZXItNmI0ZTg0NTYuY2pzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyw4R0FBcUM7QUFDakUsa0NBQWtDLG1CQUFPLENBQUMsb0dBQWdDO0FBQzFFLFlBQVksbUJBQU8sQ0FBQyx5REFBTztBQUMzQiwwQkFBMEIsbUJBQU8sQ0FBQyw0RkFBNEI7QUFDOUQsZ0NBQWdDLG1CQUFPLENBQUMsa0dBQStCO0FBQ3ZFLGdDQUFnQyxtQkFBTyxDQUFDLGtHQUErQjs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7O0FBR2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEZBQTBGO0FBQzFGO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRkFBMEY7QUFDMUY7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOLHNDQUFzQzs7QUFFdEMsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGVBQWU7QUFDZixjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxZQUFZO0FBQ1osV0FBVztBQUNYLGNBQWM7QUFDZCxjQUFjO0FBQ2QsWUFBWTtBQUNaLGVBQWU7QUFDZixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9tYWF0aC9kaXN0L2J1ZmZlci02YjRlODQ1Ni5janMuZGV2LmpzPzJmOTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0U3ByZWFkMiA9IHJlcXVpcmUoJy4vb2JqZWN0U3ByZWFkMi0zMmNkMmMzNC5janMuZGV2LmpzJyk7XG52YXIgdHJpYW5nbGVfZGlzdF9tYWF0aFRyaWFuZ2xlID0gcmVxdWlyZSgnLi90cmlhbmdsZS0zM2ZmZGZlZi5janMuZGV2LmpzJyk7XG52YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpO1xudmFyIG1pc2NfZGlzdF9tYWF0aE1pc2MgPSByZXF1aXJlKCcuL21pc2MtZmNlNGQ0OTQuY2pzLmRldi5qcycpO1xudmFyIHZlY3RvcjJfZGlzdF9tYWF0aFZlY3RvcjIgPSByZXF1aXJlKCcuL3ZlY3RvcjItZjQ0ZmQ2M2UuY2pzLmRldi5qcycpO1xudmFyIHZlY3RvcjNfZGlzdF9tYWF0aFZlY3RvcjMgPSByZXF1aXJlKCcuL3ZlY3RvcjMtNWU3MjNkMWEuY2pzLmRldi5qcycpO1xuXG5mdW5jdGlvbiBzd2l6emxlKGJ1ZmZlcikge1xuICB2YXIgc3RyaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAzO1xuICB2YXIgc3dpenpsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJ4eXpcIjtcbiAgdmFyIG8gPSB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHo6IDBcbiAgfTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYnVmZmVyLmxlbmd0aDsgX2kgKz0gc3RyaWRlKSB7XG4gICAgby54ID0gYnVmZmVyW19pXTtcbiAgICBvLnkgPSBidWZmZXJbX2kgKyAxXTtcbiAgICBvLnogPSBidWZmZXJbX2kgKyAyXTtcblxuICAgIHZhciBfc3dpenpsZSRzcGxpdCA9IHN3aXp6bGUuc3BsaXQoXCJcIiksXG4gICAgICAgIF9zd2l6emxlJHNwbGl0MiA9IHRyaWFuZ2xlX2Rpc3RfbWFhdGhUcmlhbmdsZS5fc2xpY2VkVG9BcnJheShfc3dpenpsZSRzcGxpdCwgMyksXG4gICAgICAgIHggPSBfc3dpenpsZSRzcGxpdDJbMF0sXG4gICAgICAgIHkgPSBfc3dpenpsZSRzcGxpdDJbMV0sXG4gICAgICAgIHogPSBfc3dpenpsZSRzcGxpdDJbMl07IC8vIFRPRE8gRml4IHRoaXMgdWdseSB0eXBlXG5cblxuICAgIGJ1ZmZlcltfaV0gPSBvW3hdO1xuICAgIGJ1ZmZlcltfaSArIDFdID0gb1t5XTtcblxuICAgIGlmIChzdHJpZGUgPT09IDMpIHtcbiAgICAgIGJ1ZmZlcltfaSArIDJdID0gb1t6XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufVxuLyoqXG4gKiBAcGFyYW0gYnVmZmVyIEEgc3RyaWRlIDIgcG9pbnRzIGJ1ZmZlclxuICogQHBhcmFtIHZhbHVlR2VuZXJhdG9yIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgeiBheGlzIGF0IGluZGV4IGlcbiAqIEByZXR1cm5zXG4gKi9cblxuZnVuY3Rpb24gYWRkQXhpcyhidWZmZXIsIHNpemUpIHtcbiAgdmFyIHZhbHVlR2VuZXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG4gIH07XG4gIHZhciBuZXdTaXplID0gc2l6ZSArIDE7XG4gIHZhciBuZXdCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlci5sZW5ndGggLyBzaXplICogbmV3U2l6ZSk7XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYnVmZmVyLmxlbmd0aDsgX2kyICs9IHNpemUpIHtcbiAgICB2YXIgX2ogPSBfaTIgLyBzaXplICogbmV3U2l6ZTtcblxuICAgIG5ld0J1ZmZlcltfal0gPSBidWZmZXJbX2kyXTtcbiAgICBuZXdCdWZmZXJbX2ogKyAxXSA9IGJ1ZmZlcltfaTIgKyAxXTtcblxuICAgIGlmIChzaXplID09PSAyKSB7XG4gICAgICBuZXdCdWZmZXJbX2ogKyAyXSA9IHZhbHVlR2VuZXJhdG9yKF9qKTtcbiAgICB9XG5cbiAgICBpZiAoc2l6ZSA9PT0gMykge1xuICAgICAgbmV3QnVmZmVyW19qICsgMl0gPSBidWZmZXJbX2kyICsgMl07XG4gICAgICBuZXdCdWZmZXJbX2ogKyAzXSA9IHZhbHVlR2VuZXJhdG9yKF9qKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmZmVyO1xufVxuLyoqXG4gKiBMZXJwcyBidWZmZXJBIGFuZCBidWZmZXJCIGludG8gZmluYWxcbiAqXG4gKiBAcGFyYW0gYnVmZmVyQVxuICogQHBhcmFtIGJ1ZmZlckJcbiAqIEBwYXJhbSBmaW5hbFxuICogQHBhcmFtIHRcbiAqL1xuXG5mdW5jdGlvbiBsZXJwKGJ1ZmZlckEsIGJ1ZmZlckIsIF9maW5hbCwgdCkge1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBidWZmZXJBLmxlbmd0aDsgX2kzKyspIHtcbiAgICBfZmluYWxbX2kzXSA9IG1pc2NfZGlzdF9tYWF0aE1pc2MubGVycChidWZmZXJBW19pM10sIGJ1ZmZlckJbX2kzXSwgdCk7XG4gIH1cbn0gLy8gVE9ETyBhZGQgc3RyaWRlXG4vLyBUT0RPIEZpeCB0eXBlcyAmIHZlY3RvcnNcblxuLyoqXG4gKlxuICogVHJhbnNsYXRlIGFsbCBwb2ludHMgaW4gdGhlIHBhc3NlZCBidWZmZXIgYnkgdGhlIHBhc3NlZCB0cmFuc2xhY3Rpb25WZWN0b3IuXG4gKlxuICogQHBhcmFtIGJ1ZmZlclxuICogQHBhcmFtIHRyYW5zbGF0aW9uVmVjdG9yXG4gKiBAcmV0dXJuc1xuICovXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShidWZmZXIsIHRyYW5zbGF0aW9uVmVjdG9yKSB7XG4gIHZhciBzdHJpZGUgPSB0cmFuc2xhdGlvblZlY3Rvci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgYnVmZmVyLmxlbmd0aDsgX2k0ICs9IHN0cmlkZSkge1xuICAgIGJ1ZmZlcltfaTRdICs9IHRyYW5zbGF0aW9uVmVjdG9yWzBdO1xuICAgIGJ1ZmZlcltfaTQgKyAxXSArPSB0cmFuc2xhdGlvblZlY3RvclsxXTtcbiAgICBidWZmZXJbX2k0ICsgMl0gKz0gdHJhbnNsYXRpb25WZWN0b3JbMl07XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufSAvLyBUT0RPIGFkZCBzdHJpZGVcbi8vIFRPRE8gcmVtb3ZlIHF1YXRlcm5pb24gJiB2ZWN0b3IzIGRlcGVuZGVuY2llc1xuXG5mdW5jdGlvbiByb3RhdGUoYnVmZmVyLCByb3RhdGlvbikge1xuICB2YXIgZGVmYXVsdFJvdGF0aW9uID0ge1xuICAgIGNlbnRlcjogWzAsIDAsIDBdLFxuICAgIHE6IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuaWRlbnRpdHkoKVxuICB9O1xuICB2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgdmFyIF9kZWZhdWx0Um90YXRpb24kcm90YSA9IG9iamVjdFNwcmVhZDIuX29iamVjdFNwcmVhZDIob2JqZWN0U3ByZWFkMi5fb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdFJvdGF0aW9uKSwgcm90YXRpb24pLFxuICAgICAgcSA9IF9kZWZhdWx0Um90YXRpb24kcm90YS5xLFxuICAgICAgY2VudGVyID0gX2RlZmF1bHRSb3RhdGlvbiRyb3RhLmNlbnRlcjtcblxuICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBidWZmZXIubGVuZ3RoOyBfaTUgKz0gMykge1xuICAgIHYuc2V0KGJ1ZmZlcltfaTVdIC0gY2VudGVyWzBdLCBidWZmZXJbX2k1ICsgMV0gLSBjZW50ZXJbMV0sIGJ1ZmZlcltfaTUgKyAyXSAtIGNlbnRlclsyXSk7XG4gICAgdi5hcHBseVF1YXRlcm5pb24ocSk7XG4gICAgYnVmZmVyW19pNV0gPSB2LnggKyBjZW50ZXJbMF07XG4gICAgYnVmZmVyW19pNSArIDFdID0gdi55ICsgY2VudGVyWzFdO1xuICAgIGJ1ZmZlcltfaTUgKyAyXSA9IHYueiArIGNlbnRlclsxXTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBtYXAoYnVmZmVyLCBzdHJpZGUsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIF9pNiA9IDAsIF9qMiA9IDA7IF9pNiA8IGJ1ZmZlci5sZW5ndGg7IF9pNiArPSBzdHJpZGUsIF9qMisrKSB7XG4gICAgaWYgKHN0cmlkZSA9PT0gMykge1xuICAgICAgdmFyIHJlcyA9IGNhbGxiYWNrKFtidWZmZXJbX2k2XSwgYnVmZmVyW19pNiArIDFdLCBidWZmZXJbX2k2ICsgMl1dLCBfajIpO1xuICAgICAgYnVmZmVyLnNldChyZXMsIF9pNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5zZXQoY2FsbGJhY2soW2J1ZmZlcltfaTZdLCBidWZmZXJbX2k2ICsgMV1dLCBfajIpLCBfaTYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59XG4vKipcbiAqIFJlZHVjZXMgcGFzc2VkIGJ1ZmZlclxuICovXG5cbmZ1bmN0aW9uIHJlZHVjZShiLCBzdHJpZGUsIGNhbGxiYWNrLCBhY2MpIHtcbiAgZm9yICh2YXIgX2k3ID0gMCwgX2ozID0gMDsgX2k3IDwgYi5sZW5ndGg7IF9pNyArPSBzdHJpZGUsIF9qMysrKSB7XG4gICAgaWYgKHN0cmlkZSA9PT0gMikge1xuICAgICAgYWNjID0gY2FsbGJhY2soYWNjLCBbYltfaTddLCBiW19pNyArIDFdXSwgX2ozKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjID0gY2FsbGJhY2soYWNjLCBbYltfaTddLCBiW19pNyArIDFdLCBiW19pNyArIDJdXSwgX2ozKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYWNjO1xufVxuZnVuY3Rpb24gZXhwYW5kKGIsIHN0cmlkZSwgb3B0cykge1xuICB2YXIgZGVmYXVsdEV4cGFuZE9wdGlvbnMgPSB7XG4gICAgY2VudGVyOiBbMCwgMCwgMF1cbiAgfTtcblxuICB2YXIgX2RlZmF1bHRFeHBhbmRPcHRpb25zID0gb2JqZWN0U3ByZWFkMi5fb2JqZWN0U3ByZWFkMihvYmplY3RTcHJlYWQyLl9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0RXhwYW5kT3B0aW9ucyksIG9wdHMpLFxuICAgICAgY2VudGVyID0gX2RlZmF1bHRFeHBhbmRPcHRpb25zLmNlbnRlcixcbiAgICAgIGRpc3RhbmNlID0gX2RlZmF1bHRFeHBhbmRPcHRpb25zLmRpc3RhbmNlO1xuXG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IGIubGVuZ3RoOyBfaTggKz0gc3RyaWRlKSB7XG4gICAgLyoqXG4gICAgICogMS4gdHJhbnNsYXRlIHRvIG9yaWdpbiAoc3VidHJhY3QgdGhlIHNjYWxpbmcgY2VudGVyKVxuICAgICAqIDIuIHNjYWxlIGJ5IHRoZSBjb3JyZWN0IGFtb3VudCAobXVsdGlwbHkgYnkgYSBjb25zdGFudClcbiAgICAgKiAyLiB0cmFuc2xhdGUgZnJvbSBvcmlnaW4gKGFkZCB0aGUgc2NhbGluZyBjZW50ZXIpXG4gICAgICovXG4gICAgYltfaThdID0gKGJbX2k4XSAtIGNlbnRlclswXSkgKiAoMSArIGRpc3RhbmNlKSArIGNlbnRlclswXTtcbiAgICBiW19pOCArIDFdID0gKGJbX2k4ICsgMV0gLSBjZW50ZXJbMV0pICogKDEgKyBkaXN0YW5jZSkgKyBjZW50ZXJbMV07XG5cbiAgICBpZiAoc3RyaWRlID09PSAzKSB7XG4gICAgICBiW19pOCArIDJdID0gKGJbX2k4ICsgMl0gLSBjZW50ZXJbMV0pICogKDEgKyBkaXN0YW5jZSkgKyBjZW50ZXJbMl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiBjZW50ZXIobXlCdWZmZXIsIHN0cmlkZSkge1xuICByZXR1cm4gcmVkdWNlKG15QnVmZmVyLCBzdHJpZGUsIGZ1bmN0aW9uIChhY2MsIHBvaW50KSB7XG4gICAgaWYgKHN0cmlkZSA9PT0gMykge1xuICAgICAgLy8gc29tZSB0eXBlIGhhY2tpbmcgaXMgbmVjZXNzYXJ5IHRvIGF2b2lkIHR5cGUgZXJyb3JzIGdvaW5nIGZyb20gW24sIG5dID0+IFtuLCBuLCBuXVxuICAgICAgLy8gYnV0IGl0J3Mgbm90IGFuIGFjdHVhbCBwcm9ibGVtLCBhcyB0aGlzIHBhdGggd291bGQgYWx3YXlzIGdldCBhIHYzXG4gICAgICBhY2MgPSB2ZWN0b3IzX2Rpc3RfbWFhdGhWZWN0b3IzLmFkZChhY2MsIHBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjID0gdmVjdG9yMl9kaXN0X21hYXRoVmVjdG9yMi5hZGQoYWNjLCBwb2ludCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwgdmVjdG9yMl9kaXN0X21hYXRoVmVjdG9yMi56ZXJvKCkpO1xufVxuZnVuY3Rpb24gc29ydChteUJ1ZmZlciwgc3RyaWRlLCBjYWxsYmFjaykge1xuICAvLyAxLiBtYWtlIGFuIGFycmF5IG9mIHRoZSBjb3JyZWN0IHNpemVcbiAgdmFyIGluZGljZXMgPSBJbnQxNkFycmF5LmZyb20oe1xuICAgIGxlbmd0aDogbXlCdWZmZXIubGVuZ3RoIC8gc3RyaWRlXG4gIH0sIGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgcmV0dXJuIGk7XG4gIH0pOyAvLyAyLiBzb3J0IHRoZSBpbmRpY2VzIGFycmF5XG5cbiAgaW5kaWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHBhID0gbXlCdWZmZXIuc2xpY2UoYSAqIHN0cmlkZSwgYSAqIHN0cmlkZSArIHN0cmlkZSk7XG4gICAgdmFyIHBiID0gbXlCdWZmZXIuc2xpY2UoYiAqIHN0cmlkZSwgYiAqIHN0cmlkZSArIHN0cmlkZSk7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHBhLCBwYik7XG4gIH0pOyAvLyAzLiBtYWtlIGEgY29weSBvZiB0aGUgb3JpZ2luYWwgYXJyYXkgdG8gZmV0Y2ggaW5kaWNlcyBmcm9tXG5cbiAgdmFyIHByZXZCdWZmZXIgPSBteUJ1ZmZlci5zbGljZSgwKTsgLy8gNC4gbXV0YXRlIHRoZSBwYXNzZWQgYXJyYXlcblxuICBmb3IgKHZhciBfaTkgPSAwOyBfaTkgPCBpbmRpY2VzLmxlbmd0aDsgX2k5KyspIHtcbiAgICB2YXIgX2o0ID0gaW5kaWNlc1tfaTldO1xuICAgIG15QnVmZmVyLnNldChwcmV2QnVmZmVyLnNsaWNlKF9qNCAqIHN0cmlkZSwgX2o0ICogc3RyaWRlICsgc3RyaWRlKSwgX2k5ICogMyk7XG4gIH1cblxuICByZXR1cm4gbXlCdWZmZXI7XG59XG5cbnZhciBidWZmZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc3dpenpsZTogc3dpenpsZSxcbiAgYWRkQXhpczogYWRkQXhpcyxcbiAgbGVycDogbGVycCxcbiAgdHJhbnNsYXRlOiB0cmFuc2xhdGUsXG4gIHJvdGF0ZTogcm90YXRlLFxuICBtYXA6IG1hcCxcbiAgcmVkdWNlOiByZWR1Y2UsXG4gIGV4cGFuZDogZXhwYW5kLFxuICBjZW50ZXI6IGNlbnRlcixcbiAgc29ydDogc29ydFxufSk7XG5cbmV4cG9ydHMuYWRkQXhpcyA9IGFkZEF4aXM7XG5leHBvcnRzLmJ1ZmZlciA9IGJ1ZmZlcjtcbmV4cG9ydHMuY2VudGVyID0gY2VudGVyO1xuZXhwb3J0cy5leHBhbmQgPSBleHBhbmQ7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5tYXAgPSBtYXA7XG5leHBvcnRzLnJlZHVjZSA9IHJlZHVjZTtcbmV4cG9ydHMucm90YXRlID0gcm90YXRlO1xuZXhwb3J0cy5zb3J0ID0gc29ydDtcbmV4cG9ydHMuc3dpenpsZSA9IHN3aXp6bGU7XG5leHBvcnRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/buffer-6b4e8456.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/classCallCheck-9098b006.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/maath/dist/classCallCheck-9098b006.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _classCallCheck)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9jbGFzc0NhbGxDaGVjay05MDk4YjAwNi5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9jbGFzc0NhbGxDaGVjay05MDk4YjAwNi5lc20uanM/MWVkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5leHBvcnQgeyBfY2xhc3NDYWxsQ2hlY2sgYXMgXyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/classCallCheck-9098b006.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/classCallCheck-eaf0efc7.cjs.dev.js":
/*!********************************************************************!*\
  !*** ./node_modules/maath/dist/classCallCheck-eaf0efc7.cjs.dev.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nexports._classCallCheck = _classCallCheck;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9jbGFzc0NhbGxDaGVjay1lYWYwZWZjNy5janMuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9jbGFzc0NhbGxDaGVjay1lYWYwZWZjNy5janMuZGV2LmpzPzQxMjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5leHBvcnRzLl9jbGFzc0NhbGxDaGVjayA9IF9jbGFzc0NhbGxDaGVjaztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/classCallCheck-eaf0efc7.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/easing-104c3902.cjs.dev.js":
/*!************************************************************!*\
  !*** ./node_modules/maath/dist/easing-104c3902.cjs.dev.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar triangle_dist_maathTriangle = __webpack_require__(/*! ./triangle-33ffdfef.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/triangle-33ffdfef.cjs.dev.js\");\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\nvar misc_dist_maathMisc = __webpack_require__(/*! ./misc-fce4d494.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/misc-fce4d494.cjs.dev.js\");\n\nvar rsqw = function rsqw(t) {\n  var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.01;\n  var a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var f = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1 / (2 * Math.PI);\n  return a / Math.atan(1 / delta) * Math.atan(Math.sin(2 * Math.PI * t * f) / delta);\n};\nvar exp = function exp(t) {\n  return 1 / (1 + t + 0.48 * t * t + 0.235 * t * t * t);\n};\nvar linear = function linear(t) {\n  return t;\n};\nvar sine = {\n  \"in\": function _in(x) {\n    return 1 - Math.cos(x * Math.PI / 2);\n  },\n  out: function out(x) {\n    return Math.sin(x * Math.PI / 2);\n  },\n  inOut: function inOut(x) {\n    return -(Math.cos(Math.PI * x) - 1) / 2;\n  }\n};\nvar cubic = {\n  \"in\": function _in(x) {\n    return x * x * x;\n  },\n  out: function out(x) {\n    return 1 - Math.pow(1 - x, 3);\n  },\n  inOut: function inOut(x) {\n    return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;\n  }\n};\nvar quint = {\n  \"in\": function _in(x) {\n    return x * x * x * x * x;\n  },\n  out: function out(x) {\n    return 1 - Math.pow(1 - x, 5);\n  },\n  inOut: function inOut(x) {\n    return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;\n  }\n};\nvar circ = {\n  \"in\": function _in(x) {\n    return 1 - Math.sqrt(1 - Math.pow(x, 2));\n  },\n  out: function out(x) {\n    return Math.sqrt(1 - Math.pow(x - 1, 2));\n  },\n  inOut: function inOut(x) {\n    return x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;\n  }\n};\nvar quart = {\n  \"in\": function _in(t) {\n    return t * t * t * t;\n  },\n  out: function out(t) {\n    return 1 - --t * t * t * t;\n  },\n  inOut: function inOut(t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n  }\n};\nvar expo = {\n  \"in\": function _in(x) {\n    return x === 0 ? 0 : Math.pow(2, 10 * x - 10);\n  },\n  out: function out(x) {\n    return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);\n  },\n  inOut: function inOut(x) {\n    return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2;\n  }\n};\n/**\n * Damp, based on Game Programming Gems 4 Chapter 1.10\n *   Return value indicates whether the animation is still running.\n */\n\nfunction damp(\n/** The object */\ncurrent,\n/** The key to animate */\nprop,\n/** To goal value */\ntarget) {\n  var smoothTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.25;\n  var delta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.01;\n  var maxSpeed = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n  var easing = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : exp;\n  var eps = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0.001;\n  var vel = \"velocity_\" + prop;\n  if (current.__damp === undefined) current.__damp = {};\n  if (current.__damp[vel] === undefined) current.__damp[vel] = 0;\n\n  if (Math.abs(current[prop] - target) <= eps) {\n    current[prop] = target;\n    return false;\n  }\n\n  smoothTime = Math.max(0.0001, smoothTime);\n  var omega = 2 / smoothTime;\n  var t = easing(omega * delta);\n  var change = current[prop] - target;\n  var originalTo = target; // Clamp maximum maxSpeed\n\n  var maxChange = maxSpeed * smoothTime;\n  change = Math.min(Math.max(change, -maxChange), maxChange);\n  target = current[prop] - change;\n  var temp = (current.__damp[vel] + omega * change) * delta;\n  current.__damp[vel] = (current.__damp[vel] - omega * temp) * t;\n  var output = target + (change + temp) * t; // Prevent overshooting\n\n  if (originalTo - current[prop] > 0.0 === output > originalTo) {\n    output = originalTo;\n    current.__damp[vel] = (output - originalTo) / delta;\n  }\n\n  current[prop] = output;\n  return true;\n}\n/**\n * DampLookAt\n */\n\nvar isCamera = function isCamera(v) {\n  return v && v.isCamera;\n};\n\nvar isLight = function isLight(v) {\n  return v && v.isLight;\n};\n\nvar vl3d = /*@__PURE__*/new THREE.Vector3();\n\nvar _q1 = /*@__PURE__*/new THREE.Quaternion();\n\nvar _q2 = /*@__PURE__*/new THREE.Quaternion();\n\nvar _m1 = /*@__PURE__*/new THREE.Matrix4();\n\nvar _position = /*@__PURE__*/new THREE.Vector3();\n\nfunction dampLookAt(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  // This method does not support objects having non-uniformly-scaled parent(s)\n  if (typeof target === \"number\") vl3d.setScalar(target);else if (Array.isArray(target)) vl3d.set(target[0], target[1], target[2]);else vl3d.copy(target);\n  var parent = current.parent;\n  current.updateWorldMatrix(true, false);\n\n  _position.setFromMatrixPosition(current.matrixWorld);\n\n  if (isCamera(current) || isLight(current)) _m1.lookAt(_position, vl3d, current.up);else _m1.lookAt(vl3d, _position, current.up);\n  dampQ(current.quaternion, _q2.setFromRotationMatrix(_m1), smoothTime, delta, maxSpeed, easing, eps);\n\n  if (parent) {\n    _m1.extractRotation(parent.matrixWorld);\n\n    _q1.setFromRotationMatrix(_m1);\n\n    dampQ(current.quaternion, _q2.copy(current.quaternion).premultiply(_q1.invert()), smoothTime, delta, maxSpeed, easing, eps);\n  }\n}\n/**\n * DampAngle, with a shortest-path\n */\n\nfunction dampAngle(current, prop, target, smoothTime, delta, maxSpeed, easing, eps) {\n  return damp(current, prop, current[prop] + misc_dist_maathMisc.deltaAngle(current[prop], target), smoothTime, delta, maxSpeed, easing, eps);\n}\n/**\n * Vector2D Damp\n */\n\nvar v2d = /*@__PURE__*/new THREE.Vector2();\nvar a2, b2;\nfunction damp2(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (typeof target === \"number\") v2d.setScalar(target);else if (Array.isArray(target)) v2d.set(target[0], target[1]);else v2d.copy(target);\n  a2 = damp(current, \"x\", v2d.x, smoothTime, delta, maxSpeed, easing, eps);\n  b2 = damp(current, \"y\", v2d.y, smoothTime, delta, maxSpeed, easing, eps);\n  return a2 || b2;\n}\n/**\n * Vector3D Damp\n */\n\nvar v3d = /*@__PURE__*/new THREE.Vector3();\nvar a3, b3, c3;\nfunction damp3(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (typeof target === \"number\") v3d.setScalar(target);else if (Array.isArray(target)) v3d.set(target[0], target[1], target[2]);else v3d.copy(target);\n  a3 = damp(current, \"x\", v3d.x, smoothTime, delta, maxSpeed, easing, eps);\n  b3 = damp(current, \"y\", v3d.y, smoothTime, delta, maxSpeed, easing, eps);\n  c3 = damp(current, \"z\", v3d.z, smoothTime, delta, maxSpeed, easing, eps);\n  return a3 || b3 || c3;\n}\n/**\n * Vector4D Damp\n */\n\nvar v4d = /*@__PURE__*/new THREE.Vector4();\nvar a4, b4, c4, d4;\nfunction damp4(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (typeof target === \"number\") v4d.setScalar(target);else if (Array.isArray(target)) v4d.set(target[0], target[1], target[2], target[3]);else v4d.copy(target);\n  a4 = damp(current, \"x\", v4d.x, smoothTime, delta, maxSpeed, easing, eps);\n  b4 = damp(current, \"y\", v4d.y, smoothTime, delta, maxSpeed, easing, eps);\n  c4 = damp(current, \"z\", v4d.z, smoothTime, delta, maxSpeed, easing, eps);\n  d4 = damp(current, \"w\", v4d.w, smoothTime, delta, maxSpeed, easing, eps);\n  return a4 || b4 || c4 || d4;\n}\n\n/**\n * Euler Damp\n */\nvar rot = /*@__PURE__*/new THREE.Euler();\nvar aE, bE, cE;\nfunction dampE(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (Array.isArray(target)) rot.set(target[0], target[1], target[2], target[3]);else rot.copy(target);\n  aE = dampAngle(current, \"x\", rot.x, smoothTime, delta, maxSpeed, easing, eps);\n  bE = dampAngle(current, \"y\", rot.y, smoothTime, delta, maxSpeed, easing, eps);\n  cE = dampAngle(current, \"z\", rot.z, smoothTime, delta, maxSpeed, easing, eps);\n  return aE || bE || cE;\n}\n/**\n * Color Damp\n */\n\nvar col = /*@__PURE__*/new THREE.Color();\nvar aC, bC, cC;\nfunction dampC(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (target instanceof THREE.Color) col.copy(target);else if (Array.isArray(target)) col.setRGB(target[0], target[1], target[2]);else col.set(target);\n  aC = damp(current, \"r\", col.r, smoothTime, delta, maxSpeed, easing, eps);\n  bC = damp(current, \"g\", col.g, smoothTime, delta, maxSpeed, easing, eps);\n  cC = damp(current, \"b\", col.b, smoothTime, delta, maxSpeed, easing, eps);\n  return aC || bC || cC;\n}\n/**\n * Quaternion Damp\n * https://gist.github.com/maxattack/4c7b4de00f5c1b95a33b\n * Copyright 2016 Max Kaufmann (max.kaufmann@gmail.com)\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nvar qt = /*@__PURE__*/new THREE.Quaternion();\nvar v4result = /*@__PURE__*/new THREE.Vector4();\nvar v4velocity = /*@__PURE__*/new THREE.Vector4();\nvar v4error = /*@__PURE__*/new THREE.Vector4();\nvar aQ, bQ, cQ, dQ;\nfunction dampQ(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  var cur = current;\n  if (Array.isArray(target)) qt.set(target[0], target[1], target[2], target[3]);else qt.copy(target);\n  var multi = current.dot(qt) > 0 ? 1 : -1;\n  qt.x *= multi;\n  qt.y *= multi;\n  qt.z *= multi;\n  qt.w *= multi;\n  aQ = damp(current, \"x\", qt.x, smoothTime, delta, maxSpeed, easing, eps);\n  bQ = damp(current, \"y\", qt.y, smoothTime, delta, maxSpeed, easing, eps);\n  cQ = damp(current, \"z\", qt.z, smoothTime, delta, maxSpeed, easing, eps);\n  dQ = damp(current, \"w\", qt.w, smoothTime, delta, maxSpeed, easing, eps); // smooth damp (nlerp approx)\n\n  v4result.set(current.x, current.y, current.z, current.w).normalize();\n  v4velocity.set(cur.__damp.velocity_x, cur.__damp.velocity_y, cur.__damp.velocity_z, cur.__damp.velocity_w); // ensure deriv is tangent\n\n  v4error.copy(v4result).multiplyScalar(v4velocity.dot(v4result) / v4result.dot(v4result));\n  cur.__damp.velocity_x -= v4error.x;\n  cur.__damp.velocity_y -= v4error.y;\n  cur.__damp.velocity_z -= v4error.z;\n  cur.__damp.velocity_w -= v4error.w;\n  current.set(v4result.x, v4result.y, v4result.z, v4result.w);\n  return aQ || bQ || cQ || dQ;\n}\n/**\n * Spherical Damp\n */\n\nvar spherical = /*@__PURE__*/new THREE.Spherical();\nvar aS, bS, cS;\nfunction dampS(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (Array.isArray(target)) spherical.set(target[0], target[1], target[2]);else spherical.copy(target);\n  aS = damp(current, \"radius\", spherical.radius, smoothTime, delta, maxSpeed, easing, eps);\n  bS = dampAngle(current, \"phi\", spherical.phi, smoothTime, delta, maxSpeed, easing, eps);\n  cS = dampAngle(current, \"theta\", spherical.theta, smoothTime, delta, maxSpeed, easing, eps);\n  return aS || bS || cS;\n}\n/**\n * Matrix4 Damp\n */\n\nvar mat = /*@__PURE__*/new THREE.Matrix4();\nvar mPos = /*@__PURE__*/new THREE.Vector3();\nvar mRot = /*@__PURE__*/new THREE.Quaternion();\nvar mSca = /*@__PURE__*/new THREE.Vector3();\nvar aM, bM, cM;\nfunction dampM(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  var cur = current;\n\n  if (cur.__damp === undefined) {\n    cur.__damp = {\n      position: new THREE.Vector3(),\n      rotation: new THREE.Quaternion(),\n      scale: new THREE.Vector3()\n    };\n    current.decompose(cur.__damp.position, cur.__damp.rotation, cur.__damp.scale);\n  }\n\n  if (Array.isArray(target)) mat.set.apply(mat, triangle_dist_maathTriangle._toConsumableArray(target));else mat.copy(target);\n  mat.decompose(mPos, mRot, mSca);\n  aM = damp3(cur.__damp.position, mPos, smoothTime, delta, maxSpeed, easing, eps);\n  bM = dampQ(cur.__damp.rotation, mRot, smoothTime, delta, maxSpeed, easing, eps);\n  cM = damp3(cur.__damp.scale, mSca, smoothTime, delta, maxSpeed, easing, eps);\n  current.compose(cur.__damp.position, cur.__damp.rotation, cur.__damp.scale);\n  return aM || bM || cM;\n}\n\nvar easing = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  rsqw: rsqw,\n  exp: exp,\n  linear: linear,\n  sine: sine,\n  cubic: cubic,\n  quint: quint,\n  circ: circ,\n  quart: quart,\n  expo: expo,\n  damp: damp,\n  dampLookAt: dampLookAt,\n  dampAngle: dampAngle,\n  damp2: damp2,\n  damp3: damp3,\n  damp4: damp4,\n  dampE: dampE,\n  dampC: dampC,\n  dampQ: dampQ,\n  dampS: dampS,\n  dampM: dampM\n});\n\nexports.circ = circ;\nexports.cubic = cubic;\nexports.damp = damp;\nexports.damp2 = damp2;\nexports.damp3 = damp3;\nexports.damp4 = damp4;\nexports.dampAngle = dampAngle;\nexports.dampC = dampC;\nexports.dampE = dampE;\nexports.dampLookAt = dampLookAt;\nexports.dampM = dampM;\nexports.dampQ = dampQ;\nexports.dampS = dampS;\nexports.easing = easing;\nexports.exp = exp;\nexports.expo = expo;\nexports.linear = linear;\nexports.quart = quart;\nexports.quint = quint;\nexports.rsqw = rsqw;\nexports.sine = sine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9lYXNpbmctMTA0YzM5MDIuY2pzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQ0FBa0MsbUJBQU8sQ0FBQyxvR0FBZ0M7QUFDMUUsWUFBWSxtQkFBTyxDQUFDLHlEQUFPO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLDRGQUE0Qjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlELDBFQUEwRTtBQUNuSTtBQUNBOztBQUVBOztBQUVBLHFGQUFxRjtBQUNyRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDhEQUE4RDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseUVBQXlFO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG9GQUFvRjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDRFQUE0RTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFOztBQUUzRTtBQUNBLDhHQUE4Rzs7QUFFOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsWUFBWTtBQUNaLGFBQWE7QUFDYixZQUFZO0FBQ1osYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGNBQWM7QUFDZCxXQUFXO0FBQ1gsWUFBWTtBQUNaLGNBQWM7QUFDZCxhQUFhO0FBQ2IsYUFBYTtBQUNiLFlBQVk7QUFDWixZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9lYXNpbmctMTA0YzM5MDIuY2pzLmRldi5qcz8zYTAyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHRyaWFuZ2xlX2Rpc3RfbWFhdGhUcmlhbmdsZSA9IHJlcXVpcmUoJy4vdHJpYW5nbGUtMzNmZmRmZWYuY2pzLmRldi5qcycpO1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcbnZhciBtaXNjX2Rpc3RfbWFhdGhNaXNjID0gcmVxdWlyZSgnLi9taXNjLWZjZTRkNDk0LmNqcy5kZXYuanMnKTtcblxudmFyIHJzcXcgPSBmdW5jdGlvbiByc3F3KHQpIHtcbiAgdmFyIGRlbHRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwLjAxO1xuICB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgdmFyIGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDEgLyAoMiAqIE1hdGguUEkpO1xuICByZXR1cm4gYSAvIE1hdGguYXRhbigxIC8gZGVsdGEpICogTWF0aC5hdGFuKE1hdGguc2luKDIgKiBNYXRoLlBJICogdCAqIGYpIC8gZGVsdGEpO1xufTtcbnZhciBleHAgPSBmdW5jdGlvbiBleHAodCkge1xuICByZXR1cm4gMSAvICgxICsgdCArIDAuNDggKiB0ICogdCArIDAuMjM1ICogdCAqIHQgKiB0KTtcbn07XG52YXIgbGluZWFyID0gZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgcmV0dXJuIHQ7XG59O1xudmFyIHNpbmUgPSB7XG4gIFwiaW5cIjogZnVuY3Rpb24gX2luKHgpIHtcbiAgICByZXR1cm4gMSAtIE1hdGguY29zKHggKiBNYXRoLlBJIC8gMik7XG4gIH0sXG4gIG91dDogZnVuY3Rpb24gb3V0KHgpIHtcbiAgICByZXR1cm4gTWF0aC5zaW4oeCAqIE1hdGguUEkgLyAyKTtcbiAgfSxcbiAgaW5PdXQ6IGZ1bmN0aW9uIGluT3V0KHgpIHtcbiAgICByZXR1cm4gLShNYXRoLmNvcyhNYXRoLlBJICogeCkgLSAxKSAvIDI7XG4gIH1cbn07XG52YXIgY3ViaWMgPSB7XG4gIFwiaW5cIjogZnVuY3Rpb24gX2luKHgpIHtcbiAgICByZXR1cm4geCAqIHggKiB4O1xuICB9LFxuICBvdXQ6IGZ1bmN0aW9uIG91dCh4KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0geCwgMyk7XG4gIH0sXG4gIGluT3V0OiBmdW5jdGlvbiBpbk91dCh4KSB7XG4gICAgcmV0dXJuIHggPCAwLjUgPyA0ICogeCAqIHggKiB4IDogMSAtIE1hdGgucG93KC0yICogeCArIDIsIDMpIC8gMjtcbiAgfVxufTtcbnZhciBxdWludCA9IHtcbiAgXCJpblwiOiBmdW5jdGlvbiBfaW4oeCkge1xuICAgIHJldHVybiB4ICogeCAqIHggKiB4ICogeDtcbiAgfSxcbiAgb3V0OiBmdW5jdGlvbiBvdXQoeCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHgsIDUpO1xuICB9LFxuICBpbk91dDogZnVuY3Rpb24gaW5PdXQoeCkge1xuICAgIHJldHVybiB4IDwgMC41ID8gMTYgKiB4ICogeCAqIHggKiB4ICogeCA6IDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCA1KSAvIDI7XG4gIH1cbn07XG52YXIgY2lyYyA9IHtcbiAgXCJpblwiOiBmdW5jdGlvbiBfaW4oeCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdyh4LCAyKSk7XG4gIH0sXG4gIG91dDogZnVuY3Rpb24gb3V0KHgpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdyh4IC0gMSwgMikpO1xuICB9LFxuICBpbk91dDogZnVuY3Rpb24gaW5PdXQoeCkge1xuICAgIHJldHVybiB4IDwgMC41ID8gKDEgLSBNYXRoLnNxcnQoMSAtIE1hdGgucG93KDIgKiB4LCAyKSkpIC8gMiA6IChNYXRoLnNxcnQoMSAtIE1hdGgucG93KC0yICogeCArIDIsIDIpKSArIDEpIC8gMjtcbiAgfVxufTtcbnZhciBxdWFydCA9IHtcbiAgXCJpblwiOiBmdW5jdGlvbiBfaW4odCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0O1xuICB9LFxuICBvdXQ6IGZ1bmN0aW9uIG91dCh0KSB7XG4gICAgcmV0dXJuIDEgLSAtLXQgKiB0ICogdCAqIHQ7XG4gIH0sXG4gIGluT3V0OiBmdW5jdGlvbiBpbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyA4ICogdCAqIHQgKiB0ICogdCA6IDEgLSA4ICogLS10ICogdCAqIHQgKiB0O1xuICB9XG59O1xudmFyIGV4cG8gPSB7XG4gIFwiaW5cIjogZnVuY3Rpb24gX2luKHgpIHtcbiAgICByZXR1cm4geCA9PT0gMCA/IDAgOiBNYXRoLnBvdygyLCAxMCAqIHggLSAxMCk7XG4gIH0sXG4gIG91dDogZnVuY3Rpb24gb3V0KHgpIHtcbiAgICByZXR1cm4geCA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogeCk7XG4gIH0sXG4gIGluT3V0OiBmdW5jdGlvbiBpbk91dCh4KSB7XG4gICAgcmV0dXJuIHggPT09IDAgPyAwIDogeCA9PT0gMSA/IDEgOiB4IDwgMC41ID8gTWF0aC5wb3coMiwgMjAgKiB4IC0gMTApIC8gMiA6ICgyIC0gTWF0aC5wb3coMiwgLTIwICogeCArIDEwKSkgLyAyO1xuICB9XG59O1xuLyoqXG4gKiBEYW1wLCBiYXNlZCBvbiBHYW1lIFByb2dyYW1taW5nIEdlbXMgNCBDaGFwdGVyIDEuMTBcbiAqICAgUmV0dXJuIHZhbHVlIGluZGljYXRlcyB3aGV0aGVyIHRoZSBhbmltYXRpb24gaXMgc3RpbGwgcnVubmluZy5cbiAqL1xuXG5mdW5jdGlvbiBkYW1wKFxuLyoqIFRoZSBvYmplY3QgKi9cbmN1cnJlbnQsXG4vKiogVGhlIGtleSB0byBhbmltYXRlICovXG5wcm9wLFxuLyoqIFRvIGdvYWwgdmFsdWUgKi9cbnRhcmdldCkge1xuICB2YXIgc21vb3RoVGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMC4yNTtcbiAgdmFyIGRlbHRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAwLjAxO1xuICB2YXIgbWF4U3BlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IEluZmluaXR5O1xuICB2YXIgZWFzaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBleHA7XG4gIHZhciBlcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNyAmJiBhcmd1bWVudHNbN10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s3XSA6IDAuMDAxO1xuICB2YXIgdmVsID0gXCJ2ZWxvY2l0eV9cIiArIHByb3A7XG4gIGlmIChjdXJyZW50Ll9fZGFtcCA9PT0gdW5kZWZpbmVkKSBjdXJyZW50Ll9fZGFtcCA9IHt9O1xuICBpZiAoY3VycmVudC5fX2RhbXBbdmVsXSA9PT0gdW5kZWZpbmVkKSBjdXJyZW50Ll9fZGFtcFt2ZWxdID0gMDtcblxuICBpZiAoTWF0aC5hYnMoY3VycmVudFtwcm9wXSAtIHRhcmdldCkgPD0gZXBzKSB7XG4gICAgY3VycmVudFtwcm9wXSA9IHRhcmdldDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzbW9vdGhUaW1lID0gTWF0aC5tYXgoMC4wMDAxLCBzbW9vdGhUaW1lKTtcbiAgdmFyIG9tZWdhID0gMiAvIHNtb290aFRpbWU7XG4gIHZhciB0ID0gZWFzaW5nKG9tZWdhICogZGVsdGEpO1xuICB2YXIgY2hhbmdlID0gY3VycmVudFtwcm9wXSAtIHRhcmdldDtcbiAgdmFyIG9yaWdpbmFsVG8gPSB0YXJnZXQ7IC8vIENsYW1wIG1heGltdW0gbWF4U3BlZWRcblxuICB2YXIgbWF4Q2hhbmdlID0gbWF4U3BlZWQgKiBzbW9vdGhUaW1lO1xuICBjaGFuZ2UgPSBNYXRoLm1pbihNYXRoLm1heChjaGFuZ2UsIC1tYXhDaGFuZ2UpLCBtYXhDaGFuZ2UpO1xuICB0YXJnZXQgPSBjdXJyZW50W3Byb3BdIC0gY2hhbmdlO1xuICB2YXIgdGVtcCA9IChjdXJyZW50Ll9fZGFtcFt2ZWxdICsgb21lZ2EgKiBjaGFuZ2UpICogZGVsdGE7XG4gIGN1cnJlbnQuX19kYW1wW3ZlbF0gPSAoY3VycmVudC5fX2RhbXBbdmVsXSAtIG9tZWdhICogdGVtcCkgKiB0O1xuICB2YXIgb3V0cHV0ID0gdGFyZ2V0ICsgKGNoYW5nZSArIHRlbXApICogdDsgLy8gUHJldmVudCBvdmVyc2hvb3RpbmdcblxuICBpZiAob3JpZ2luYWxUbyAtIGN1cnJlbnRbcHJvcF0gPiAwLjAgPT09IG91dHB1dCA+IG9yaWdpbmFsVG8pIHtcbiAgICBvdXRwdXQgPSBvcmlnaW5hbFRvO1xuICAgIGN1cnJlbnQuX19kYW1wW3ZlbF0gPSAob3V0cHV0IC0gb3JpZ2luYWxUbykgLyBkZWx0YTtcbiAgfVxuXG4gIGN1cnJlbnRbcHJvcF0gPSBvdXRwdXQ7XG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBEYW1wTG9va0F0XG4gKi9cblxudmFyIGlzQ2FtZXJhID0gZnVuY3Rpb24gaXNDYW1lcmEodikge1xuICByZXR1cm4gdiAmJiB2LmlzQ2FtZXJhO1xufTtcblxudmFyIGlzTGlnaHQgPSBmdW5jdGlvbiBpc0xpZ2h0KHYpIHtcbiAgcmV0dXJuIHYgJiYgdi5pc0xpZ2h0O1xufTtcblxudmFyIHZsM2QgPSAvKkBfX1BVUkVfXyovbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxudmFyIF9xMSA9IC8qQF9fUFVSRV9fKi9uZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG52YXIgX3EyID0gLypAX19QVVJFX18qL25ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbnZhciBfbTEgPSAvKkBfX1BVUkVfXyovbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxudmFyIF9wb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi9uZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5mdW5jdGlvbiBkYW1wTG9va0F0KGN1cnJlbnQsIHRhcmdldCwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcykge1xuICAvLyBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgaGF2aW5nIG5vbi11bmlmb3JtbHktc2NhbGVkIHBhcmVudChzKVxuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJudW1iZXJcIikgdmwzZC5zZXRTY2FsYXIodGFyZ2V0KTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHZsM2Quc2V0KHRhcmdldFswXSwgdGFyZ2V0WzFdLCB0YXJnZXRbMl0pO2Vsc2UgdmwzZC5jb3B5KHRhcmdldCk7XG4gIHZhciBwYXJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgY3VycmVudC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cbiAgX3Bvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihjdXJyZW50Lm1hdHJpeFdvcmxkKTtcblxuICBpZiAoaXNDYW1lcmEoY3VycmVudCkgfHwgaXNMaWdodChjdXJyZW50KSkgX20xLmxvb2tBdChfcG9zaXRpb24sIHZsM2QsIGN1cnJlbnQudXApO2Vsc2UgX20xLmxvb2tBdCh2bDNkLCBfcG9zaXRpb24sIGN1cnJlbnQudXApO1xuICBkYW1wUShjdXJyZW50LnF1YXRlcm5pb24sIF9xMi5zZXRGcm9tUm90YXRpb25NYXRyaXgoX20xKSwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIF9tMS5leHRyYWN0Um90YXRpb24ocGFyZW50Lm1hdHJpeFdvcmxkKTtcblxuICAgIF9xMS5zZXRGcm9tUm90YXRpb25NYXRyaXgoX20xKTtcblxuICAgIGRhbXBRKGN1cnJlbnQucXVhdGVybmlvbiwgX3EyLmNvcHkoY3VycmVudC5xdWF0ZXJuaW9uKS5wcmVtdWx0aXBseShfcTEuaW52ZXJ0KCkpLCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgfVxufVxuLyoqXG4gKiBEYW1wQW5nbGUsIHdpdGggYSBzaG9ydGVzdC1wYXRoXG4gKi9cblxuZnVuY3Rpb24gZGFtcEFuZ2xlKGN1cnJlbnQsIHByb3AsIHRhcmdldCwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcykge1xuICByZXR1cm4gZGFtcChjdXJyZW50LCBwcm9wLCBjdXJyZW50W3Byb3BdICsgbWlzY19kaXN0X21hYXRoTWlzYy5kZWx0YUFuZ2xlKGN1cnJlbnRbcHJvcF0sIHRhcmdldCksIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xufVxuLyoqXG4gKiBWZWN0b3IyRCBEYW1wXG4gKi9cblxudmFyIHYyZCA9IC8qQF9fUFVSRV9fKi9uZXcgVEhSRUUuVmVjdG9yMigpO1xudmFyIGEyLCBiMjtcbmZ1bmN0aW9uIGRhbXAyKGN1cnJlbnQsIHRhcmdldCwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcykge1xuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJudW1iZXJcIikgdjJkLnNldFNjYWxhcih0YXJnZXQpO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkgdjJkLnNldCh0YXJnZXRbMF0sIHRhcmdldFsxXSk7ZWxzZSB2MmQuY29weSh0YXJnZXQpO1xuICBhMiA9IGRhbXAoY3VycmVudCwgXCJ4XCIsIHYyZC54LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgYjIgPSBkYW1wKGN1cnJlbnQsIFwieVwiLCB2MmQueSwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIHJldHVybiBhMiB8fCBiMjtcbn1cbi8qKlxuICogVmVjdG9yM0QgRGFtcFxuICovXG5cbnZhciB2M2QgPSAvKkBfX1BVUkVfXyovbmV3IFRIUkVFLlZlY3RvcjMoKTtcbnZhciBhMywgYjMsIGMzO1xuZnVuY3Rpb24gZGFtcDMoY3VycmVudCwgdGFyZ2V0LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKSB7XG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcIm51bWJlclwiKSB2M2Quc2V0U2NhbGFyKHRhcmdldCk7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB2M2Quc2V0KHRhcmdldFswXSwgdGFyZ2V0WzFdLCB0YXJnZXRbMl0pO2Vsc2UgdjNkLmNvcHkodGFyZ2V0KTtcbiAgYTMgPSBkYW1wKGN1cnJlbnQsIFwieFwiLCB2M2QueCwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGIzID0gZGFtcChjdXJyZW50LCBcInlcIiwgdjNkLnksIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICBjMyA9IGRhbXAoY3VycmVudCwgXCJ6XCIsIHYzZC56LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgcmV0dXJuIGEzIHx8IGIzIHx8IGMzO1xufVxuLyoqXG4gKiBWZWN0b3I0RCBEYW1wXG4gKi9cblxudmFyIHY0ZCA9IC8qQF9fUFVSRV9fKi9uZXcgVEhSRUUuVmVjdG9yNCgpO1xudmFyIGE0LCBiNCwgYzQsIGQ0O1xuZnVuY3Rpb24gZGFtcDQoY3VycmVudCwgdGFyZ2V0LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKSB7XG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcIm51bWJlclwiKSB2NGQuc2V0U2NhbGFyKHRhcmdldCk7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB2NGQuc2V0KHRhcmdldFswXSwgdGFyZ2V0WzFdLCB0YXJnZXRbMl0sIHRhcmdldFszXSk7ZWxzZSB2NGQuY29weSh0YXJnZXQpO1xuICBhNCA9IGRhbXAoY3VycmVudCwgXCJ4XCIsIHY0ZC54LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgYjQgPSBkYW1wKGN1cnJlbnQsIFwieVwiLCB2NGQueSwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGM0ID0gZGFtcChjdXJyZW50LCBcInpcIiwgdjRkLnosIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICBkNCA9IGRhbXAoY3VycmVudCwgXCJ3XCIsIHY0ZC53LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgcmV0dXJuIGE0IHx8IGI0IHx8IGM0IHx8IGQ0O1xufVxuXG4vKipcbiAqIEV1bGVyIERhbXBcbiAqL1xudmFyIHJvdCA9IC8qQF9fUFVSRV9fKi9uZXcgVEhSRUUuRXVsZXIoKTtcbnZhciBhRSwgYkUsIGNFO1xuZnVuY3Rpb24gZGFtcEUoY3VycmVudCwgdGFyZ2V0LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHJvdC5zZXQodGFyZ2V0WzBdLCB0YXJnZXRbMV0sIHRhcmdldFsyXSwgdGFyZ2V0WzNdKTtlbHNlIHJvdC5jb3B5KHRhcmdldCk7XG4gIGFFID0gZGFtcEFuZ2xlKGN1cnJlbnQsIFwieFwiLCByb3QueCwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGJFID0gZGFtcEFuZ2xlKGN1cnJlbnQsIFwieVwiLCByb3QueSwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGNFID0gZGFtcEFuZ2xlKGN1cnJlbnQsIFwielwiLCByb3Queiwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIHJldHVybiBhRSB8fCBiRSB8fCBjRTtcbn1cbi8qKlxuICogQ29sb3IgRGFtcFxuICovXG5cbnZhciBjb2wgPSAvKkBfX1BVUkVfXyovbmV3IFRIUkVFLkNvbG9yKCk7XG52YXIgYUMsIGJDLCBjQztcbmZ1bmN0aW9uIGRhbXBDKGN1cnJlbnQsIHRhcmdldCwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcykge1xuICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuQ29sb3IpIGNvbC5jb3B5KHRhcmdldCk7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSBjb2wuc2V0UkdCKHRhcmdldFswXSwgdGFyZ2V0WzFdLCB0YXJnZXRbMl0pO2Vsc2UgY29sLnNldCh0YXJnZXQpO1xuICBhQyA9IGRhbXAoY3VycmVudCwgXCJyXCIsIGNvbC5yLCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgYkMgPSBkYW1wKGN1cnJlbnQsIFwiZ1wiLCBjb2wuZywgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGNDID0gZGFtcChjdXJyZW50LCBcImJcIiwgY29sLmIsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICByZXR1cm4gYUMgfHwgYkMgfHwgY0M7XG59XG4vKipcbiAqIFF1YXRlcm5pb24gRGFtcFxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWF4YXR0YWNrLzRjN2I0ZGUwMGY1YzFiOTVhMzNiXG4gKiBDb3B5cmlnaHQgMjAxNiBNYXggS2F1Zm1hbm4gKG1heC5rYXVmbWFubkBnbWFpbC5jb20pXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG52YXIgcXQgPSAvKkBfX1BVUkVfXyovbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbnZhciB2NHJlc3VsdCA9IC8qQF9fUFVSRV9fKi9uZXcgVEhSRUUuVmVjdG9yNCgpO1xudmFyIHY0dmVsb2NpdHkgPSAvKkBfX1BVUkVfXyovbmV3IFRIUkVFLlZlY3RvcjQoKTtcbnZhciB2NGVycm9yID0gLypAX19QVVJFX18qL25ldyBUSFJFRS5WZWN0b3I0KCk7XG52YXIgYVEsIGJRLCBjUSwgZFE7XG5mdW5jdGlvbiBkYW1wUShjdXJyZW50LCB0YXJnZXQsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpIHtcbiAgdmFyIGN1ciA9IGN1cnJlbnQ7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHF0LnNldCh0YXJnZXRbMF0sIHRhcmdldFsxXSwgdGFyZ2V0WzJdLCB0YXJnZXRbM10pO2Vsc2UgcXQuY29weSh0YXJnZXQpO1xuICB2YXIgbXVsdGkgPSBjdXJyZW50LmRvdChxdCkgPiAwID8gMSA6IC0xO1xuICBxdC54ICo9IG11bHRpO1xuICBxdC55ICo9IG11bHRpO1xuICBxdC56ICo9IG11bHRpO1xuICBxdC53ICo9IG11bHRpO1xuICBhUSA9IGRhbXAoY3VycmVudCwgXCJ4XCIsIHF0LngsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICBiUSA9IGRhbXAoY3VycmVudCwgXCJ5XCIsIHF0LnksIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICBjUSA9IGRhbXAoY3VycmVudCwgXCJ6XCIsIHF0LnosIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICBkUSA9IGRhbXAoY3VycmVudCwgXCJ3XCIsIHF0LncsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpOyAvLyBzbW9vdGggZGFtcCAobmxlcnAgYXBwcm94KVxuXG4gIHY0cmVzdWx0LnNldChjdXJyZW50LngsIGN1cnJlbnQueSwgY3VycmVudC56LCBjdXJyZW50LncpLm5vcm1hbGl6ZSgpO1xuICB2NHZlbG9jaXR5LnNldChjdXIuX19kYW1wLnZlbG9jaXR5X3gsIGN1ci5fX2RhbXAudmVsb2NpdHlfeSwgY3VyLl9fZGFtcC52ZWxvY2l0eV96LCBjdXIuX19kYW1wLnZlbG9jaXR5X3cpOyAvLyBlbnN1cmUgZGVyaXYgaXMgdGFuZ2VudFxuXG4gIHY0ZXJyb3IuY29weSh2NHJlc3VsdCkubXVsdGlwbHlTY2FsYXIodjR2ZWxvY2l0eS5kb3QodjRyZXN1bHQpIC8gdjRyZXN1bHQuZG90KHY0cmVzdWx0KSk7XG4gIGN1ci5fX2RhbXAudmVsb2NpdHlfeCAtPSB2NGVycm9yLng7XG4gIGN1ci5fX2RhbXAudmVsb2NpdHlfeSAtPSB2NGVycm9yLnk7XG4gIGN1ci5fX2RhbXAudmVsb2NpdHlfeiAtPSB2NGVycm9yLno7XG4gIGN1ci5fX2RhbXAudmVsb2NpdHlfdyAtPSB2NGVycm9yLnc7XG4gIGN1cnJlbnQuc2V0KHY0cmVzdWx0LngsIHY0cmVzdWx0LnksIHY0cmVzdWx0LnosIHY0cmVzdWx0LncpO1xuICByZXR1cm4gYVEgfHwgYlEgfHwgY1EgfHwgZFE7XG59XG4vKipcbiAqIFNwaGVyaWNhbCBEYW1wXG4gKi9cblxudmFyIHNwaGVyaWNhbCA9IC8qQF9fUFVSRV9fKi9uZXcgVEhSRUUuU3BoZXJpY2FsKCk7XG52YXIgYVMsIGJTLCBjUztcbmZ1bmN0aW9uIGRhbXBTKGN1cnJlbnQsIHRhcmdldCwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSBzcGhlcmljYWwuc2V0KHRhcmdldFswXSwgdGFyZ2V0WzFdLCB0YXJnZXRbMl0pO2Vsc2Ugc3BoZXJpY2FsLmNvcHkodGFyZ2V0KTtcbiAgYVMgPSBkYW1wKGN1cnJlbnQsIFwicmFkaXVzXCIsIHNwaGVyaWNhbC5yYWRpdXMsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICBiUyA9IGRhbXBBbmdsZShjdXJyZW50LCBcInBoaVwiLCBzcGhlcmljYWwucGhpLCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgY1MgPSBkYW1wQW5nbGUoY3VycmVudCwgXCJ0aGV0YVwiLCBzcGhlcmljYWwudGhldGEsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICByZXR1cm4gYVMgfHwgYlMgfHwgY1M7XG59XG4vKipcbiAqIE1hdHJpeDQgRGFtcFxuICovXG5cbnZhciBtYXQgPSAvKkBfX1BVUkVfXyovbmV3IFRIUkVFLk1hdHJpeDQoKTtcbnZhciBtUG9zID0gLypAX19QVVJFX18qL25ldyBUSFJFRS5WZWN0b3IzKCk7XG52YXIgbVJvdCA9IC8qQF9fUFVSRV9fKi9uZXcgVEhSRUUuUXVhdGVybmlvbigpO1xudmFyIG1TY2EgPSAvKkBfX1BVUkVfXyovbmV3IFRIUkVFLlZlY3RvcjMoKTtcbnZhciBhTSwgYk0sIGNNO1xuZnVuY3Rpb24gZGFtcE0oY3VycmVudCwgdGFyZ2V0LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKSB7XG4gIHZhciBjdXIgPSBjdXJyZW50O1xuXG4gIGlmIChjdXIuX19kYW1wID09PSB1bmRlZmluZWQpIHtcbiAgICBjdXIuX19kYW1wID0ge1xuICAgICAgcG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICByb3RhdGlvbjogbmV3IFRIUkVFLlF1YXRlcm5pb24oKSxcbiAgICAgIHNjYWxlOiBuZXcgVEhSRUUuVmVjdG9yMygpXG4gICAgfTtcbiAgICBjdXJyZW50LmRlY29tcG9zZShjdXIuX19kYW1wLnBvc2l0aW9uLCBjdXIuX19kYW1wLnJvdGF0aW9uLCBjdXIuX19kYW1wLnNjYWxlKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIG1hdC5zZXQuYXBwbHkobWF0LCB0cmlhbmdsZV9kaXN0X21hYXRoVHJpYW5nbGUuX3RvQ29uc3VtYWJsZUFycmF5KHRhcmdldCkpO2Vsc2UgbWF0LmNvcHkodGFyZ2V0KTtcbiAgbWF0LmRlY29tcG9zZShtUG9zLCBtUm90LCBtU2NhKTtcbiAgYU0gPSBkYW1wMyhjdXIuX19kYW1wLnBvc2l0aW9uLCBtUG9zLCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgYk0gPSBkYW1wUShjdXIuX19kYW1wLnJvdGF0aW9uLCBtUm90LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgY00gPSBkYW1wMyhjdXIuX19kYW1wLnNjYWxlLCBtU2NhLCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgY3VycmVudC5jb21wb3NlKGN1ci5fX2RhbXAucG9zaXRpb24sIGN1ci5fX2RhbXAucm90YXRpb24sIGN1ci5fX2RhbXAuc2NhbGUpO1xuICByZXR1cm4gYU0gfHwgYk0gfHwgY007XG59XG5cbnZhciBlYXNpbmcgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgcnNxdzogcnNxdyxcbiAgZXhwOiBleHAsXG4gIGxpbmVhcjogbGluZWFyLFxuICBzaW5lOiBzaW5lLFxuICBjdWJpYzogY3ViaWMsXG4gIHF1aW50OiBxdWludCxcbiAgY2lyYzogY2lyYyxcbiAgcXVhcnQ6IHF1YXJ0LFxuICBleHBvOiBleHBvLFxuICBkYW1wOiBkYW1wLFxuICBkYW1wTG9va0F0OiBkYW1wTG9va0F0LFxuICBkYW1wQW5nbGU6IGRhbXBBbmdsZSxcbiAgZGFtcDI6IGRhbXAyLFxuICBkYW1wMzogZGFtcDMsXG4gIGRhbXA0OiBkYW1wNCxcbiAgZGFtcEU6IGRhbXBFLFxuICBkYW1wQzogZGFtcEMsXG4gIGRhbXBROiBkYW1wUSxcbiAgZGFtcFM6IGRhbXBTLFxuICBkYW1wTTogZGFtcE1cbn0pO1xuXG5leHBvcnRzLmNpcmMgPSBjaXJjO1xuZXhwb3J0cy5jdWJpYyA9IGN1YmljO1xuZXhwb3J0cy5kYW1wID0gZGFtcDtcbmV4cG9ydHMuZGFtcDIgPSBkYW1wMjtcbmV4cG9ydHMuZGFtcDMgPSBkYW1wMztcbmV4cG9ydHMuZGFtcDQgPSBkYW1wNDtcbmV4cG9ydHMuZGFtcEFuZ2xlID0gZGFtcEFuZ2xlO1xuZXhwb3J0cy5kYW1wQyA9IGRhbXBDO1xuZXhwb3J0cy5kYW1wRSA9IGRhbXBFO1xuZXhwb3J0cy5kYW1wTG9va0F0ID0gZGFtcExvb2tBdDtcbmV4cG9ydHMuZGFtcE0gPSBkYW1wTTtcbmV4cG9ydHMuZGFtcFEgPSBkYW1wUTtcbmV4cG9ydHMuZGFtcFMgPSBkYW1wUztcbmV4cG9ydHMuZWFzaW5nID0gZWFzaW5nO1xuZXhwb3J0cy5leHAgPSBleHA7XG5leHBvcnRzLmV4cG8gPSBleHBvO1xuZXhwb3J0cy5saW5lYXIgPSBsaW5lYXI7XG5leHBvcnRzLnF1YXJ0ID0gcXVhcnQ7XG5leHBvcnRzLnF1aW50ID0gcXVpbnQ7XG5leHBvcnRzLnJzcXcgPSByc3F3O1xuZXhwb3J0cy5zaW5lID0gc2luZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/easing-104c3902.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/geometry-358de1c4.cjs.dev.js":
/*!**************************************************************!*\
  !*** ./node_modules/maath/dist/geometry-358de1c4.cjs.dev.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar classCallCheck = __webpack_require__(/*! ./classCallCheck-eaf0efc7.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/classCallCheck-eaf0efc7.cjs.dev.js\");\nvar isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct-ddc4ebc1.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/isNativeReflectConstruct-ddc4ebc1.cjs.dev.js\");\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) isNativeReflectConstruct._setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct._isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar RoundedPlaneGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  _inherits(RoundedPlaneGeometry, _THREE$BufferGeometry);\n\n  var _super = _createSuper(RoundedPlaneGeometry);\n\n  function RoundedPlaneGeometry() {\n    var _this;\n\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.2;\n    var segments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 16;\n\n    classCallCheck._classCallCheck(this, RoundedPlaneGeometry);\n\n    _this = _super.call(this);\n    _this.parameters = {\n      width: width,\n      height: height,\n      radius: radius,\n      segments: segments\n    }; // helper const's\n\n    var wi = width / 2 - radius; // inner width\n\n    var hi = height / 2 - radius; // inner height\n\n    var ul = radius / width; // u left\n\n    var ur = (width - radius) / width; // u right\n\n    var vl = radius / height; // v low\n\n    var vh = (height - radius) / height; // v high\n\n    var positions = [wi, hi, 0, -wi, hi, 0, -wi, -hi, 0, wi, -hi, 0];\n    var uvs = [ur, vh, ul, vh, ul, vl, ur, vl];\n    var n = [3 * (segments + 1) + 3, 3 * (segments + 1) + 4, segments + 4, segments + 5, 2 * (segments + 1) + 4, 2, 1, 2 * (segments + 1) + 3, 3, 4 * (segments + 1) + 3, 4, 0];\n    var indices = [n[0], n[1], n[2], n[0], n[2], n[3], n[4], n[5], n[6], n[4], n[6], n[7], n[8], n[9], n[10], n[8], n[10], n[11]];\n    var phi, cos, sin, xc, yc, uc, vc, idx;\n\n    for (var i = 0; i < 4; i++) {\n      xc = i < 1 || i > 2 ? wi : -wi;\n      yc = i < 2 ? hi : -hi;\n      uc = i < 1 || i > 2 ? ur : ul;\n      vc = i < 2 ? vh : vl;\n\n      for (var j = 0; j <= segments; j++) {\n        phi = Math.PI / 2 * (i + j / segments);\n        cos = Math.cos(phi);\n        sin = Math.sin(phi);\n        positions.push(xc + radius * cos, yc + radius * sin, 0);\n        uvs.push(uc + ul * cos, vc + vl * sin);\n\n        if (j < segments) {\n          idx = (segments + 1) * i + j + 4;\n          indices.push(i, idx, idx + 1);\n        }\n      }\n    }\n\n    _this.setIndex(new THREE__namespace.BufferAttribute(new Uint32Array(indices), 1));\n\n    _this.setAttribute(\"position\", new THREE__namespace.BufferAttribute(new Float32Array(positions), 3));\n\n    _this.setAttribute(\"uv\", new THREE__namespace.BufferAttribute(new Float32Array(uvs), 2));\n\n    return _this;\n  }\n\n  return RoundedPlaneGeometry;\n}(THREE__namespace.BufferGeometry); // Author: https://stackoverflow.com/users/128511/gman\n// https://stackoverflow.com/questions/34958072/programmatically-generate-simple-uv-mapping-for-models\n\nfunction applyCylindricalUV(bufferGeometry) {\n  var uvs = [];\n\n  for (var i = 0; i < bufferGeometry.attributes.position.array.length / 3; i++) {\n    var x = bufferGeometry.attributes.position.array[i * 3 + 0];\n    var y = bufferGeometry.attributes.position.array[i * 3 + 1];\n    var z = bufferGeometry.attributes.position.array[i * 3 + 2];\n    uvs.push(Math.atan2(x, z) / Math.PI * 0.5 + 0.5, y / Math.PI * 0.5 + 0.5);\n  }\n\n  if (bufferGeometry.attributes.uv) delete bufferGeometry.attributes.uv;\n  bufferGeometry.setAttribute(\"uv\", new THREE__namespace.Float32BufferAttribute(uvs, 2));\n  bufferGeometry.attributes.uv.needsUpdate = true;\n  return bufferGeometry;\n} // Author: https://stackoverflow.com/users/268905/knee-cola\n// https://stackoverflow.com/questions/20774648/three-js-generate-uv-coordinate\n\nfunction applySphereUV(bufferGeometry) {\n  var uvs = [];\n  var vertices = [];\n\n  for (var i = 0; i < bufferGeometry.attributes.position.array.length / 3; i++) {\n    var x = bufferGeometry.attributes.position.array[i * 3 + 0];\n    var y = bufferGeometry.attributes.position.array[i * 3 + 1];\n    var z = bufferGeometry.attributes.position.array[i * 3 + 2];\n    vertices.push(new THREE__namespace.Vector3(x, y, z));\n  }\n\n  var polarVertices = vertices.map(cartesian2polar);\n\n  for (var _i = 0; _i < polarVertices.length / 3; _i++) {\n    var tri = new THREE__namespace.Triangle(vertices[_i * 3 + 0], vertices[_i * 3 + 1], vertices[_i * 3 + 2]);\n    var normal = tri.getNormal(new THREE__namespace.Vector3());\n\n    for (var f = 0; f < 3; f++) {\n      var vertex = polarVertices[_i * 3 + f];\n\n      if (vertex.theta === 0 && (vertex.phi === 0 || vertex.phi === Math.PI)) {\n        var alignedVertice = vertex.phi === 0 ? _i * 3 + 1 : _i * 3 + 0;\n        vertex = {\n          r: vertex.r,\n          phi: vertex.phi,\n          theta: polarVertices[alignedVertice].theta\n        };\n      }\n\n      if (vertex.theta === Math.PI && cartesian2polar(normal).theta < Math.PI / 2) {\n        vertex.theta = -Math.PI;\n      }\n\n      var canvasPoint = polar2canvas(vertex);\n      uvs.push(1 - canvasPoint.x, 1 - canvasPoint.y);\n    }\n  }\n\n  if (bufferGeometry.attributes.uv) delete bufferGeometry.attributes.uv;\n  bufferGeometry.setAttribute(\"uv\", new THREE__namespace.Float32BufferAttribute(uvs, 2));\n  bufferGeometry.attributes.uv.needsUpdate = true;\n  return bufferGeometry;\n}\n\nfunction cartesian2polar(position) {\n  var r = Math.sqrt(position.x * position.x + position.z * position.z + position.y * position.y);\n  return {\n    r: r,\n    phi: Math.acos(position.y / r),\n    theta: Math.atan2(position.z, position.x)\n  };\n}\n\nfunction polar2canvas(polarPoint) {\n  return {\n    y: polarPoint.phi / Math.PI,\n    x: (polarPoint.theta + Math.PI) / (2 * Math.PI)\n  };\n} // Author: Alex Khoroshylov (https://stackoverflow.com/users/8742287/alex-khoroshylov)\n// https://stackoverflow.com/questions/20774648/three-js-generate-uv-coordinate\n\n\nfunction applyBoxUV(bufferGeometry) {\n  bufferGeometry.computeBoundingBox();\n  var bboxSize = bufferGeometry.boundingBox.getSize(new THREE__namespace.Vector3());\n  var boxSize = Math.min(bboxSize.x, bboxSize.y, bboxSize.z);\n  var boxGeometry = new THREE__namespace.BoxGeometry(boxSize, boxSize, boxSize);\n  var cube = new THREE__namespace.Mesh(boxGeometry);\n  cube.rotation.set(0, 0, 0);\n  cube.updateWorldMatrix(true, false);\n  var transformMatrix = cube.matrix.clone().invert();\n  var uvBbox = new THREE__namespace.Box3(new THREE__namespace.Vector3(-boxSize / 2, -boxSize / 2, -boxSize / 2), new THREE__namespace.Vector3(boxSize / 2, boxSize / 2, boxSize / 2));\n\n  _applyBoxUV(bufferGeometry, transformMatrix, uvBbox, boxSize);\n\n  bufferGeometry.attributes.uv.needsUpdate = true;\n  return bufferGeometry;\n}\n\nfunction _applyBoxUV(geom, transformMatrix, bbox, bbox_max_size) {\n  var coords = [];\n  coords.length = 2 * geom.attributes.position.array.length / 3; //maps 3 verts of 1 face on the better side of the cube\n  //side of the cube can be XY, XZ or YZ\n\n  var makeUVs = function makeUVs(v0, v1, v2) {\n    //pre-rotate the model so that cube sides match world axis\n    v0.applyMatrix4(transformMatrix);\n    v1.applyMatrix4(transformMatrix);\n    v2.applyMatrix4(transformMatrix); //get normal of the face, to know into which cube side it maps better\n\n    var n = new THREE__namespace.Vector3();\n    n.crossVectors(v1.clone().sub(v0), v1.clone().sub(v2)).normalize();\n    n.x = Math.abs(n.x);\n    n.y = Math.abs(n.y);\n    n.z = Math.abs(n.z);\n    var uv0 = new THREE__namespace.Vector2();\n    var uv1 = new THREE__namespace.Vector2();\n    var uv2 = new THREE__namespace.Vector2(); // xz mapping\n\n    if (n.y > n.x && n.y > n.z) {\n      uv0.x = (v0.x - bbox.min.x) / bbox_max_size;\n      uv0.y = (bbox.max.z - v0.z) / bbox_max_size;\n      uv1.x = (v1.x - bbox.min.x) / bbox_max_size;\n      uv1.y = (bbox.max.z - v1.z) / bbox_max_size;\n      uv2.x = (v2.x - bbox.min.x) / bbox_max_size;\n      uv2.y = (bbox.max.z - v2.z) / bbox_max_size;\n    } else if (n.x > n.y && n.x > n.z) {\n      uv0.x = (v0.z - bbox.min.z) / bbox_max_size;\n      uv0.y = (v0.y - bbox.min.y) / bbox_max_size;\n      uv1.x = (v1.z - bbox.min.z) / bbox_max_size;\n      uv1.y = (v1.y - bbox.min.y) / bbox_max_size;\n      uv2.x = (v2.z - bbox.min.z) / bbox_max_size;\n      uv2.y = (v2.y - bbox.min.y) / bbox_max_size;\n    } else if (n.z > n.y && n.z > n.x) {\n      uv0.x = (v0.x - bbox.min.x) / bbox_max_size;\n      uv0.y = (v0.y - bbox.min.y) / bbox_max_size;\n      uv1.x = (v1.x - bbox.min.x) / bbox_max_size;\n      uv1.y = (v1.y - bbox.min.y) / bbox_max_size;\n      uv2.x = (v2.x - bbox.min.x) / bbox_max_size;\n      uv2.y = (v2.y - bbox.min.y) / bbox_max_size;\n    }\n\n    return {\n      uv0: uv0,\n      uv1: uv1,\n      uv2: uv2\n    };\n  };\n\n  if (geom.index) {\n    // is it indexed buffer geometry?\n    for (var vi = 0; vi < geom.index.array.length; vi += 3) {\n      var idx0 = geom.index.array[vi];\n      var idx1 = geom.index.array[vi + 1];\n      var idx2 = geom.index.array[vi + 2];\n      var vx0 = geom.attributes.position.array[3 * idx0];\n      var vy0 = geom.attributes.position.array[3 * idx0 + 1];\n      var vz0 = geom.attributes.position.array[3 * idx0 + 2];\n      var vx1 = geom.attributes.position.array[3 * idx1];\n      var vy1 = geom.attributes.position.array[3 * idx1 + 1];\n      var vz1 = geom.attributes.position.array[3 * idx1 + 2];\n      var vx2 = geom.attributes.position.array[3 * idx2];\n      var vy2 = geom.attributes.position.array[3 * idx2 + 1];\n      var vz2 = geom.attributes.position.array[3 * idx2 + 2];\n      var v0 = new THREE__namespace.Vector3(vx0, vy0, vz0);\n      var v1 = new THREE__namespace.Vector3(vx1, vy1, vz1);\n      var v2 = new THREE__namespace.Vector3(vx2, vy2, vz2);\n      var uvs = makeUVs(v0, v1, v2);\n      coords[2 * idx0] = uvs.uv0.x;\n      coords[2 * idx0 + 1] = uvs.uv0.y;\n      coords[2 * idx1] = uvs.uv1.x;\n      coords[2 * idx1 + 1] = uvs.uv1.y;\n      coords[2 * idx2] = uvs.uv2.x;\n      coords[2 * idx2 + 1] = uvs.uv2.y;\n    }\n  } else {\n    for (var _vi = 0; _vi < geom.attributes.position.array.length; _vi += 9) {\n      var _vx = geom.attributes.position.array[_vi];\n      var _vy = geom.attributes.position.array[_vi + 1];\n      var _vz = geom.attributes.position.array[_vi + 2];\n      var _vx2 = geom.attributes.position.array[_vi + 3];\n      var _vy2 = geom.attributes.position.array[_vi + 4];\n      var _vz2 = geom.attributes.position.array[_vi + 5];\n      var _vx3 = geom.attributes.position.array[_vi + 6];\n      var _vy3 = geom.attributes.position.array[_vi + 7];\n      var _vz3 = geom.attributes.position.array[_vi + 8];\n\n      var _v = new THREE__namespace.Vector3(_vx, _vy, _vz);\n\n      var _v2 = new THREE__namespace.Vector3(_vx2, _vy2, _vz2);\n\n      var _v3 = new THREE__namespace.Vector3(_vx3, _vy3, _vz3);\n\n      var _uvs = makeUVs(_v, _v2, _v3);\n\n      var _idx = _vi / 3;\n\n      var _idx2 = _idx + 1;\n\n      var _idx3 = _idx + 2;\n\n      coords[2 * _idx] = _uvs.uv0.x;\n      coords[2 * _idx + 1] = _uvs.uv0.y;\n      coords[2 * _idx2] = _uvs.uv1.x;\n      coords[2 * _idx2 + 1] = _uvs.uv1.y;\n      coords[2 * _idx3] = _uvs.uv2.x;\n      coords[2 * _idx3 + 1] = _uvs.uv2.y;\n    }\n  }\n\n  if (geom.attributes.uv) delete geom.attributes.uv;\n  geom.setAttribute(\"uv\", new THREE__namespace.Float32BufferAttribute(coords, 2));\n}\n\nvar geometry = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  RoundedPlaneGeometry: RoundedPlaneGeometry,\n  applyCylindricalUV: applyCylindricalUV,\n  applySphereUV: applySphereUV,\n  applyBoxUV: applyBoxUV\n});\n\nexports.RoundedPlaneGeometry = RoundedPlaneGeometry;\nexports.applyBoxUV = applyBoxUV;\nexports.applyCylindricalUV = applyCylindricalUV;\nexports.applySphereUV = applySphereUV;\nexports.geometry = geometry;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9nZW9tZXRyeS0zNThkZTFjNC5janMuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLGdIQUFzQztBQUNuRSwrQkFBK0IsbUJBQU8sQ0FBQyxvSUFBZ0Q7QUFDdkYsWUFBWSxtQkFBTyxDQUFDLHlEQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsaUNBQWlDOztBQUVqQyxrQ0FBa0M7O0FBRWxDLDZCQUE2Qjs7QUFFN0IsdUNBQXVDOztBQUV2Qyw4QkFBOEI7O0FBRTlCLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxtQ0FBbUM7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IseURBQXlEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix5REFBeUQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDhCQUE4QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHNCQUFzQiw2Q0FBNkM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsNEJBQTRCO0FBQzVCLGtCQUFrQjtBQUNsQiwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYWNlcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvZ2VvbWV0cnktMzU4ZGUxYzQuY2pzLmRldi5qcz9mOTNiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGNsYXNzQ2FsbENoZWNrID0gcmVxdWlyZSgnLi9jbGFzc0NhbGxDaGVjay1lYWYwZWZjNy5janMuZGV2LmpzJyk7XG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZSgnLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QtZGRjNGViYzEuY2pzLmRldi5qcycpO1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChlKSB7XG4gICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbltcImRlZmF1bHRcIl0gPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIFRIUkVFX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoVEhSRUUpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5faXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxudmFyIFJvdW5kZWRQbGFuZUdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVEhSRUUkQnVmZmVyR2VvbWV0cnkpIHtcbiAgX2luaGVyaXRzKFJvdW5kZWRQbGFuZUdlb21ldHJ5LCBfVEhSRUUkQnVmZmVyR2VvbWV0cnkpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUm91bmRlZFBsYW5lR2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIFJvdW5kZWRQbGFuZUdlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMjtcbiAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDAuMjtcbiAgICB2YXIgc2VnbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE2O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2suX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdW5kZWRQbGFuZUdlb21ldHJ5KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICBzZWdtZW50czogc2VnbWVudHNcbiAgICB9OyAvLyBoZWxwZXIgY29uc3Qnc1xuXG4gICAgdmFyIHdpID0gd2lkdGggLyAyIC0gcmFkaXVzOyAvLyBpbm5lciB3aWR0aFxuXG4gICAgdmFyIGhpID0gaGVpZ2h0IC8gMiAtIHJhZGl1czsgLy8gaW5uZXIgaGVpZ2h0XG5cbiAgICB2YXIgdWwgPSByYWRpdXMgLyB3aWR0aDsgLy8gdSBsZWZ0XG5cbiAgICB2YXIgdXIgPSAod2lkdGggLSByYWRpdXMpIC8gd2lkdGg7IC8vIHUgcmlnaHRcblxuICAgIHZhciB2bCA9IHJhZGl1cyAvIGhlaWdodDsgLy8gdiBsb3dcblxuICAgIHZhciB2aCA9IChoZWlnaHQgLSByYWRpdXMpIC8gaGVpZ2h0OyAvLyB2IGhpZ2hcblxuICAgIHZhciBwb3NpdGlvbnMgPSBbd2ksIGhpLCAwLCAtd2ksIGhpLCAwLCAtd2ksIC1oaSwgMCwgd2ksIC1oaSwgMF07XG4gICAgdmFyIHV2cyA9IFt1ciwgdmgsIHVsLCB2aCwgdWwsIHZsLCB1ciwgdmxdO1xuICAgIHZhciBuID0gWzMgKiAoc2VnbWVudHMgKyAxKSArIDMsIDMgKiAoc2VnbWVudHMgKyAxKSArIDQsIHNlZ21lbnRzICsgNCwgc2VnbWVudHMgKyA1LCAyICogKHNlZ21lbnRzICsgMSkgKyA0LCAyLCAxLCAyICogKHNlZ21lbnRzICsgMSkgKyAzLCAzLCA0ICogKHNlZ21lbnRzICsgMSkgKyAzLCA0LCAwXTtcbiAgICB2YXIgaW5kaWNlcyA9IFtuWzBdLCBuWzFdLCBuWzJdLCBuWzBdLCBuWzJdLCBuWzNdLCBuWzRdLCBuWzVdLCBuWzZdLCBuWzRdLCBuWzZdLCBuWzddLCBuWzhdLCBuWzldLCBuWzEwXSwgbls4XSwgblsxMF0sIG5bMTFdXTtcbiAgICB2YXIgcGhpLCBjb3MsIHNpbiwgeGMsIHljLCB1YywgdmMsIGlkeDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICB4YyA9IGkgPCAxIHx8IGkgPiAyID8gd2kgOiAtd2k7XG4gICAgICB5YyA9IGkgPCAyID8gaGkgOiAtaGk7XG4gICAgICB1YyA9IGkgPCAxIHx8IGkgPiAyID8gdXIgOiB1bDtcbiAgICAgIHZjID0gaSA8IDIgPyB2aCA6IHZsO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBzZWdtZW50czsgaisrKSB7XG4gICAgICAgIHBoaSA9IE1hdGguUEkgLyAyICogKGkgKyBqIC8gc2VnbWVudHMpO1xuICAgICAgICBjb3MgPSBNYXRoLmNvcyhwaGkpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbihwaGkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaCh4YyArIHJhZGl1cyAqIGNvcywgeWMgKyByYWRpdXMgKiBzaW4sIDApO1xuICAgICAgICB1dnMucHVzaCh1YyArIHVsICogY29zLCB2YyArIHZsICogc2luKTtcblxuICAgICAgICBpZiAoaiA8IHNlZ21lbnRzKSB7XG4gICAgICAgICAgaWR4ID0gKHNlZ21lbnRzICsgMSkgKiBpICsgaiArIDQ7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGksIGlkeCwgaWR4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpcy5zZXRJbmRleChuZXcgVEhSRUVfX25hbWVzcGFjZS5CdWZmZXJBdHRyaWJ1dGUobmV3IFVpbnQzMkFycmF5KGluZGljZXMpLCAxKSk7XG5cbiAgICBfdGhpcy5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgVEhSRUVfX25hbWVzcGFjZS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpLCAzKSk7XG5cbiAgICBfdGhpcy5zZXRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgVEhSRUVfX25hbWVzcGFjZS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSh1dnMpLCAyKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gUm91bmRlZFBsYW5lR2VvbWV0cnk7XG59KFRIUkVFX19uYW1lc3BhY2UuQnVmZmVyR2VvbWV0cnkpOyAvLyBBdXRob3I6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vdXNlcnMvMTI4NTExL2dtYW5cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM0OTU4MDcyL3Byb2dyYW1tYXRpY2FsbHktZ2VuZXJhdGUtc2ltcGxlLXV2LW1hcHBpbmctZm9yLW1vZGVsc1xuXG5mdW5jdGlvbiBhcHBseUN5bGluZHJpY2FsVVYoYnVmZmVyR2VvbWV0cnkpIHtcbiAgdmFyIHV2cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheS5sZW5ndGggLyAzOyBpKyspIHtcbiAgICB2YXIgeCA9IGJ1ZmZlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSAqIDMgKyAwXTtcbiAgICB2YXIgeSA9IGJ1ZmZlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSAqIDMgKyAxXTtcbiAgICB2YXIgeiA9IGJ1ZmZlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSAqIDMgKyAyXTtcbiAgICB1dnMucHVzaChNYXRoLmF0YW4yKHgsIHopIC8gTWF0aC5QSSAqIDAuNSArIDAuNSwgeSAvIE1hdGguUEkgKiAwLjUgKyAwLjUpO1xuICB9XG5cbiAgaWYgKGJ1ZmZlckdlb21ldHJ5LmF0dHJpYnV0ZXMudXYpIGRlbGV0ZSBidWZmZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnV2O1xuICBidWZmZXJHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgVEhSRUVfX25hbWVzcGFjZS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuICBidWZmZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnV2Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgcmV0dXJuIGJ1ZmZlckdlb21ldHJ5O1xufSAvLyBBdXRob3I6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vdXNlcnMvMjY4OTA1L2tuZWUtY29sYVxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjA3NzQ2NDgvdGhyZWUtanMtZ2VuZXJhdGUtdXYtY29vcmRpbmF0ZVxuXG5mdW5jdGlvbiBhcHBseVNwaGVyZVVWKGJ1ZmZlckdlb21ldHJ5KSB7XG4gIHZhciB1dnMgPSBbXTtcbiAgdmFyIHZlcnRpY2VzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDM7IGkrKykge1xuICAgIHZhciB4ID0gYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpICogMyArIDBdO1xuICAgIHZhciB5ID0gYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpICogMyArIDFdO1xuICAgIHZhciB6ID0gYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpICogMyArIDJdO1xuICAgIHZlcnRpY2VzLnB1c2gobmV3IFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMyh4LCB5LCB6KSk7XG4gIH1cblxuICB2YXIgcG9sYXJWZXJ0aWNlcyA9IHZlcnRpY2VzLm1hcChjYXJ0ZXNpYW4ycG9sYXIpO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBwb2xhclZlcnRpY2VzLmxlbmd0aCAvIDM7IF9pKyspIHtcbiAgICB2YXIgdHJpID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuVHJpYW5nbGUodmVydGljZXNbX2kgKiAzICsgMF0sIHZlcnRpY2VzW19pICogMyArIDFdLCB2ZXJ0aWNlc1tfaSAqIDMgKyAyXSk7XG4gICAgdmFyIG5vcm1hbCA9IHRyaS5nZXROb3JtYWwobmV3IFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMygpKTtcblxuICAgIGZvciAodmFyIGYgPSAwOyBmIDwgMzsgZisrKSB7XG4gICAgICB2YXIgdmVydGV4ID0gcG9sYXJWZXJ0aWNlc1tfaSAqIDMgKyBmXTtcblxuICAgICAgaWYgKHZlcnRleC50aGV0YSA9PT0gMCAmJiAodmVydGV4LnBoaSA9PT0gMCB8fCB2ZXJ0ZXgucGhpID09PSBNYXRoLlBJKSkge1xuICAgICAgICB2YXIgYWxpZ25lZFZlcnRpY2UgPSB2ZXJ0ZXgucGhpID09PSAwID8gX2kgKiAzICsgMSA6IF9pICogMyArIDA7XG4gICAgICAgIHZlcnRleCA9IHtcbiAgICAgICAgICByOiB2ZXJ0ZXgucixcbiAgICAgICAgICBwaGk6IHZlcnRleC5waGksXG4gICAgICAgICAgdGhldGE6IHBvbGFyVmVydGljZXNbYWxpZ25lZFZlcnRpY2VdLnRoZXRhXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJ0ZXgudGhldGEgPT09IE1hdGguUEkgJiYgY2FydGVzaWFuMnBvbGFyKG5vcm1hbCkudGhldGEgPCBNYXRoLlBJIC8gMikge1xuICAgICAgICB2ZXJ0ZXgudGhldGEgPSAtTWF0aC5QSTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbnZhc1BvaW50ID0gcG9sYXIyY2FudmFzKHZlcnRleCk7XG4gICAgICB1dnMucHVzaCgxIC0gY2FudmFzUG9pbnQueCwgMSAtIGNhbnZhc1BvaW50LnkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChidWZmZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnV2KSBkZWxldGUgYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcy51djtcbiAgYnVmZmVyR2VvbWV0cnkuc2V0QXR0cmlidXRlKFwidXZcIiwgbmV3IFRIUkVFX19uYW1lc3BhY2UuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcbiAgYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcy51di5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIHJldHVybiBidWZmZXJHZW9tZXRyeTtcbn1cblxuZnVuY3Rpb24gY2FydGVzaWFuMnBvbGFyKHBvc2l0aW9uKSB7XG4gIHZhciByID0gTWF0aC5zcXJ0KHBvc2l0aW9uLnggKiBwb3NpdGlvbi54ICsgcG9zaXRpb24ueiAqIHBvc2l0aW9uLnogKyBwb3NpdGlvbi55ICogcG9zaXRpb24ueSk7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBwaGk6IE1hdGguYWNvcyhwb3NpdGlvbi55IC8gciksXG4gICAgdGhldGE6IE1hdGguYXRhbjIocG9zaXRpb24ueiwgcG9zaXRpb24ueClcbiAgfTtcbn1cblxuZnVuY3Rpb24gcG9sYXIyY2FudmFzKHBvbGFyUG9pbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB5OiBwb2xhclBvaW50LnBoaSAvIE1hdGguUEksXG4gICAgeDogKHBvbGFyUG9pbnQudGhldGEgKyBNYXRoLlBJKSAvICgyICogTWF0aC5QSSlcbiAgfTtcbn0gLy8gQXV0aG9yOiBBbGV4IEtob3Jvc2h5bG92IChodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3VzZXJzLzg3NDIyODcvYWxleC1raG9yb3NoeWxvdilcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwNzc0NjQ4L3RocmVlLWpzLWdlbmVyYXRlLXV2LWNvb3JkaW5hdGVcblxuXG5mdW5jdGlvbiBhcHBseUJveFVWKGJ1ZmZlckdlb21ldHJ5KSB7XG4gIGJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICB2YXIgYmJveFNpemUgPSBidWZmZXJHZW9tZXRyeS5ib3VuZGluZ0JveC5nZXRTaXplKG5ldyBUSFJFRV9fbmFtZXNwYWNlLlZlY3RvcjMoKSk7XG4gIHZhciBib3hTaXplID0gTWF0aC5taW4oYmJveFNpemUueCwgYmJveFNpemUueSwgYmJveFNpemUueik7XG4gIHZhciBib3hHZW9tZXRyeSA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLkJveEdlb21ldHJ5KGJveFNpemUsIGJveFNpemUsIGJveFNpemUpO1xuICB2YXIgY3ViZSA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLk1lc2goYm94R2VvbWV0cnkpO1xuICBjdWJlLnJvdGF0aW9uLnNldCgwLCAwLCAwKTtcbiAgY3ViZS51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG4gIHZhciB0cmFuc2Zvcm1NYXRyaXggPSBjdWJlLm1hdHJpeC5jbG9uZSgpLmludmVydCgpO1xuICB2YXIgdXZCYm94ID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuQm94MyhuZXcgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IzKC1ib3hTaXplIC8gMiwgLWJveFNpemUgLyAyLCAtYm94U2l6ZSAvIDIpLCBuZXcgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IzKGJveFNpemUgLyAyLCBib3hTaXplIC8gMiwgYm94U2l6ZSAvIDIpKTtcblxuICBfYXBwbHlCb3hVVihidWZmZXJHZW9tZXRyeSwgdHJhbnNmb3JtTWF0cml4LCB1dkJib3gsIGJveFNpemUpO1xuXG4gIGJ1ZmZlckdlb21ldHJ5LmF0dHJpYnV0ZXMudXYubmVlZHNVcGRhdGUgPSB0cnVlO1xuICByZXR1cm4gYnVmZmVyR2VvbWV0cnk7XG59XG5cbmZ1bmN0aW9uIF9hcHBseUJveFVWKGdlb20sIHRyYW5zZm9ybU1hdHJpeCwgYmJveCwgYmJveF9tYXhfc2l6ZSkge1xuICB2YXIgY29vcmRzID0gW107XG4gIGNvb3Jkcy5sZW5ndGggPSAyICogZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDM7IC8vbWFwcyAzIHZlcnRzIG9mIDEgZmFjZSBvbiB0aGUgYmV0dGVyIHNpZGUgb2YgdGhlIGN1YmVcbiAgLy9zaWRlIG9mIHRoZSBjdWJlIGNhbiBiZSBYWSwgWFogb3IgWVpcblxuICB2YXIgbWFrZVVWcyA9IGZ1bmN0aW9uIG1ha2VVVnModjAsIHYxLCB2Mikge1xuICAgIC8vcHJlLXJvdGF0ZSB0aGUgbW9kZWwgc28gdGhhdCBjdWJlIHNpZGVzIG1hdGNoIHdvcmxkIGF4aXNcbiAgICB2MC5hcHBseU1hdHJpeDQodHJhbnNmb3JtTWF0cml4KTtcbiAgICB2MS5hcHBseU1hdHJpeDQodHJhbnNmb3JtTWF0cml4KTtcbiAgICB2Mi5hcHBseU1hdHJpeDQodHJhbnNmb3JtTWF0cml4KTsgLy9nZXQgbm9ybWFsIG9mIHRoZSBmYWNlLCB0byBrbm93IGludG8gd2hpY2ggY3ViZSBzaWRlIGl0IG1hcHMgYmV0dGVyXG5cbiAgICB2YXIgbiA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlZlY3RvcjMoKTtcbiAgICBuLmNyb3NzVmVjdG9ycyh2MS5jbG9uZSgpLnN1Yih2MCksIHYxLmNsb25lKCkuc3ViKHYyKSkubm9ybWFsaXplKCk7XG4gICAgbi54ID0gTWF0aC5hYnMobi54KTtcbiAgICBuLnkgPSBNYXRoLmFicyhuLnkpO1xuICAgIG4ueiA9IE1hdGguYWJzKG4ueik7XG4gICAgdmFyIHV2MCA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlZlY3RvcjIoKTtcbiAgICB2YXIgdXYxID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMigpO1xuICAgIHZhciB1djIgPSBuZXcgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IyKCk7IC8vIHh6IG1hcHBpbmdcblxuICAgIGlmIChuLnkgPiBuLnggJiYgbi55ID4gbi56KSB7XG4gICAgICB1djAueCA9ICh2MC54IC0gYmJveC5taW4ueCkgLyBiYm94X21heF9zaXplO1xuICAgICAgdXYwLnkgPSAoYmJveC5tYXgueiAtIHYwLnopIC8gYmJveF9tYXhfc2l6ZTtcbiAgICAgIHV2MS54ID0gKHYxLnggLSBiYm94Lm1pbi54KSAvIGJib3hfbWF4X3NpemU7XG4gICAgICB1djEueSA9IChiYm94Lm1heC56IC0gdjEueikgLyBiYm94X21heF9zaXplO1xuICAgICAgdXYyLnggPSAodjIueCAtIGJib3gubWluLngpIC8gYmJveF9tYXhfc2l6ZTtcbiAgICAgIHV2Mi55ID0gKGJib3gubWF4LnogLSB2Mi56KSAvIGJib3hfbWF4X3NpemU7XG4gICAgfSBlbHNlIGlmIChuLnggPiBuLnkgJiYgbi54ID4gbi56KSB7XG4gICAgICB1djAueCA9ICh2MC56IC0gYmJveC5taW4ueikgLyBiYm94X21heF9zaXplO1xuICAgICAgdXYwLnkgPSAodjAueSAtIGJib3gubWluLnkpIC8gYmJveF9tYXhfc2l6ZTtcbiAgICAgIHV2MS54ID0gKHYxLnogLSBiYm94Lm1pbi56KSAvIGJib3hfbWF4X3NpemU7XG4gICAgICB1djEueSA9ICh2MS55IC0gYmJveC5taW4ueSkgLyBiYm94X21heF9zaXplO1xuICAgICAgdXYyLnggPSAodjIueiAtIGJib3gubWluLnopIC8gYmJveF9tYXhfc2l6ZTtcbiAgICAgIHV2Mi55ID0gKHYyLnkgLSBiYm94Lm1pbi55KSAvIGJib3hfbWF4X3NpemU7XG4gICAgfSBlbHNlIGlmIChuLnogPiBuLnkgJiYgbi56ID4gbi54KSB7XG4gICAgICB1djAueCA9ICh2MC54IC0gYmJveC5taW4ueCkgLyBiYm94X21heF9zaXplO1xuICAgICAgdXYwLnkgPSAodjAueSAtIGJib3gubWluLnkpIC8gYmJveF9tYXhfc2l6ZTtcbiAgICAgIHV2MS54ID0gKHYxLnggLSBiYm94Lm1pbi54KSAvIGJib3hfbWF4X3NpemU7XG4gICAgICB1djEueSA9ICh2MS55IC0gYmJveC5taW4ueSkgLyBiYm94X21heF9zaXplO1xuICAgICAgdXYyLnggPSAodjIueCAtIGJib3gubWluLngpIC8gYmJveF9tYXhfc2l6ZTtcbiAgICAgIHV2Mi55ID0gKHYyLnkgLSBiYm94Lm1pbi55KSAvIGJib3hfbWF4X3NpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHV2MDogdXYwLFxuICAgICAgdXYxOiB1djEsXG4gICAgICB1djI6IHV2MlxuICAgIH07XG4gIH07XG5cbiAgaWYgKGdlb20uaW5kZXgpIHtcbiAgICAvLyBpcyBpdCBpbmRleGVkIGJ1ZmZlciBnZW9tZXRyeT9cbiAgICBmb3IgKHZhciB2aSA9IDA7IHZpIDwgZ2VvbS5pbmRleC5hcnJheS5sZW5ndGg7IHZpICs9IDMpIHtcbiAgICAgIHZhciBpZHgwID0gZ2VvbS5pbmRleC5hcnJheVt2aV07XG4gICAgICB2YXIgaWR4MSA9IGdlb20uaW5kZXguYXJyYXlbdmkgKyAxXTtcbiAgICAgIHZhciBpZHgyID0gZ2VvbS5pbmRleC5hcnJheVt2aSArIDJdO1xuICAgICAgdmFyIHZ4MCA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVszICogaWR4MF07XG4gICAgICB2YXIgdnkwID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5WzMgKiBpZHgwICsgMV07XG4gICAgICB2YXIgdnowID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5WzMgKiBpZHgwICsgMl07XG4gICAgICB2YXIgdngxID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5WzMgKiBpZHgxXTtcbiAgICAgIHZhciB2eTEgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbMyAqIGlkeDEgKyAxXTtcbiAgICAgIHZhciB2ejEgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbMyAqIGlkeDEgKyAyXTtcbiAgICAgIHZhciB2eDIgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbMyAqIGlkeDJdO1xuICAgICAgdmFyIHZ5MiA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVszICogaWR4MiArIDFdO1xuICAgICAgdmFyIHZ6MiA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVszICogaWR4MiArIDJdO1xuICAgICAgdmFyIHYwID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMyh2eDAsIHZ5MCwgdnowKTtcbiAgICAgIHZhciB2MSA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlZlY3RvcjModngxLCB2eTEsIHZ6MSk7XG4gICAgICB2YXIgdjIgPSBuZXcgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IzKHZ4MiwgdnkyLCB2ejIpO1xuICAgICAgdmFyIHV2cyA9IG1ha2VVVnModjAsIHYxLCB2Mik7XG4gICAgICBjb29yZHNbMiAqIGlkeDBdID0gdXZzLnV2MC54O1xuICAgICAgY29vcmRzWzIgKiBpZHgwICsgMV0gPSB1dnMudXYwLnk7XG4gICAgICBjb29yZHNbMiAqIGlkeDFdID0gdXZzLnV2MS54O1xuICAgICAgY29vcmRzWzIgKiBpZHgxICsgMV0gPSB1dnMudXYxLnk7XG4gICAgICBjb29yZHNbMiAqIGlkeDJdID0gdXZzLnV2Mi54O1xuICAgICAgY29vcmRzWzIgKiBpZHgyICsgMV0gPSB1dnMudXYyLnk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIF92aSA9IDA7IF92aSA8IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheS5sZW5ndGg7IF92aSArPSA5KSB7XG4gICAgICB2YXIgX3Z4ID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W192aV07XG4gICAgICB2YXIgX3Z5ID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W192aSArIDFdO1xuICAgICAgdmFyIF92eiA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtfdmkgKyAyXTtcbiAgICAgIHZhciBfdngyID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W192aSArIDNdO1xuICAgICAgdmFyIF92eTIgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbX3ZpICsgNF07XG4gICAgICB2YXIgX3Z6MiA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtfdmkgKyA1XTtcbiAgICAgIHZhciBfdngzID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W192aSArIDZdO1xuICAgICAgdmFyIF92eTMgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbX3ZpICsgN107XG4gICAgICB2YXIgX3Z6MyA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtfdmkgKyA4XTtcblxuICAgICAgdmFyIF92ID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMyhfdngsIF92eSwgX3Z6KTtcblxuICAgICAgdmFyIF92MiA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlZlY3RvcjMoX3Z4MiwgX3Z5MiwgX3Z6Mik7XG5cbiAgICAgIHZhciBfdjMgPSBuZXcgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IzKF92eDMsIF92eTMsIF92ejMpO1xuXG4gICAgICB2YXIgX3V2cyA9IG1ha2VVVnMoX3YsIF92MiwgX3YzKTtcblxuICAgICAgdmFyIF9pZHggPSBfdmkgLyAzO1xuXG4gICAgICB2YXIgX2lkeDIgPSBfaWR4ICsgMTtcblxuICAgICAgdmFyIF9pZHgzID0gX2lkeCArIDI7XG5cbiAgICAgIGNvb3Jkc1syICogX2lkeF0gPSBfdXZzLnV2MC54O1xuICAgICAgY29vcmRzWzIgKiBfaWR4ICsgMV0gPSBfdXZzLnV2MC55O1xuICAgICAgY29vcmRzWzIgKiBfaWR4Ml0gPSBfdXZzLnV2MS54O1xuICAgICAgY29vcmRzWzIgKiBfaWR4MiArIDFdID0gX3V2cy51djEueTtcbiAgICAgIGNvb3Jkc1syICogX2lkeDNdID0gX3V2cy51djIueDtcbiAgICAgIGNvb3Jkc1syICogX2lkeDMgKyAxXSA9IF91dnMudXYyLnk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGdlb20uYXR0cmlidXRlcy51dikgZGVsZXRlIGdlb20uYXR0cmlidXRlcy51djtcbiAgZ2VvbS5zZXRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgVEhSRUVfX25hbWVzcGFjZS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvb3JkcywgMikpO1xufVxuXG52YXIgZ2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgUm91bmRlZFBsYW5lR2VvbWV0cnk6IFJvdW5kZWRQbGFuZUdlb21ldHJ5LFxuICBhcHBseUN5bGluZHJpY2FsVVY6IGFwcGx5Q3lsaW5kcmljYWxVVixcbiAgYXBwbHlTcGhlcmVVVjogYXBwbHlTcGhlcmVVVixcbiAgYXBwbHlCb3hVVjogYXBwbHlCb3hVVlxufSk7XG5cbmV4cG9ydHMuUm91bmRlZFBsYW5lR2VvbWV0cnkgPSBSb3VuZGVkUGxhbmVHZW9tZXRyeTtcbmV4cG9ydHMuYXBwbHlCb3hVViA9IGFwcGx5Qm94VVY7XG5leHBvcnRzLmFwcGx5Q3lsaW5kcmljYWxVViA9IGFwcGx5Q3lsaW5kcmljYWxVVjtcbmV4cG9ydHMuYXBwbHlTcGhlcmVVViA9IGFwcGx5U3BoZXJlVVY7XG5leHBvcnRzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/geometry-358de1c4.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/index-0332b2ed.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/maath/dist/index-0332b2ed.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   F: () => (/* binding */ FlashGen),\n/* harmony export */   G: () => (/* binding */ Generator),\n/* harmony export */   a: () => (/* binding */ inSphere),\n/* harmony export */   b: () => (/* binding */ inCircle),\n/* harmony export */   c: () => (/* binding */ onCircle),\n/* harmony export */   d: () => (/* binding */ inRect),\n/* harmony export */   e: () => (/* binding */ onRect),\n/* harmony export */   f: () => (/* binding */ inBox),\n/* harmony export */   g: () => (/* binding */ onBox),\n/* harmony export */   i: () => (/* binding */ index),\n/* harmony export */   n: () => (/* binding */ noise),\n/* harmony export */   o: () => (/* binding */ onSphere)\n/* harmony export */ });\n/* harmony import */ var _objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objectSpread2-284232a6.esm.js */ \"(ssr)/./node_modules/maath/dist/objectSpread2-284232a6.esm.js\");\n/* harmony import */ var _classCallCheck_9098b006_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classCallCheck-9098b006.esm.js */ \"(ssr)/./node_modules/maath/dist/classCallCheck-9098b006.esm.js\");\n/* harmony import */ var _misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc-19a3ec46.esm.js */ \"(ssr)/./node_modules/maath/dist/misc-19a3ec46.esm.js\");\n\n\n\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/*\n * A speed-improved perlin and simplex noise algorithms for 2D.\n *\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n * Converted to Javascript by Joseph Gentle.\n *\n * Version 2012-03-09\n *\n * This code was placed in the public domain by its original author,\n * Stefan Gustavson. You may use it as you see fit, but\n * attribution is appreciated.\n *\n */\n\nvar Grad = function Grad(x, y, z) {\n  var _this = this;\n\n  (0,_classCallCheck_9098b006_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(this, Grad);\n\n  (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"dot2\", function (x, y) {\n    return _this.x * x + _this.y * y;\n  });\n\n  (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"dot3\", function (x, y, z) {\n    return _this.x * x + _this.y * y + _this.z * z;\n  });\n\n  this.x = x;\n  this.y = y;\n  this.z = z;\n};\n\nvar grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\nvar p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]; // To remove the need for index wrapping, double the permutation table length\n\nvar perm = new Array(512);\nvar gradP = new Array(512); // This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\n\nvar seed = function seed(_seed) {\n  if (_seed > 0 && _seed < 1) {\n    // Scale the seed out\n    _seed *= 65536;\n  }\n\n  _seed = Math.floor(_seed);\n\n  if (_seed < 256) {\n    _seed |= _seed << 8;\n  }\n\n  for (var i = 0; i < 256; i++) {\n    var v;\n\n    if (i & 1) {\n      v = p[i] ^ _seed & 255;\n    } else {\n      v = p[i] ^ _seed >> 8 & 255;\n    }\n\n    perm[i] = perm[i + 256] = v;\n    gradP[i] = gradP[i + 256] = grad3[v % 12];\n  }\n};\nseed(0);\n/*\n  for(var i=0; i<256; i++) {\n    perm[i] = perm[i + 256] = p[i];\n    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\n  }*/\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\n\nvar F2 = 0.5 * (Math.sqrt(3) - 1);\nvar G2 = (3 - Math.sqrt(3)) / 6;\nvar F3 = 1 / 3;\nvar G3 = 1 / 6; // 2D simplex noise\n\nvar simplex2 = function simplex2(xin, yin) {\n  var n0, n1, n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n\n  var s = (xin + yin) * F2; // Hairy factor for 2D\n\n  var i = Math.floor(xin + s);\n  var j = Math.floor(yin + s);\n  var t = (i + j) * G2;\n  var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\n  var y0 = yin - j + t; // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n\n  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\n  if (x0 > y0) {\n    // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n    i1 = 1;\n    j1 = 0;\n  } else {\n    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n    i1 = 0;\n    j1 = 1;\n  } // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n\n\n  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\n  var y1 = y0 - j1 + G2;\n  var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n\n  var y2 = y0 - 1 + 2 * G2; // Work out the hashed gradient indices of the three simplex corners\n\n  i &= 255;\n  j &= 255;\n  var gi0 = gradP[i + perm[j]];\n  var gi1 = gradP[i + i1 + perm[j + j1]];\n  var gi2 = gradP[i + 1 + perm[j + 1]]; // Calculate the contribution from the three corners\n\n  var t0 = 0.5 - x0 * x0 - y0 * y0;\n\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient\n  }\n\n  var t1 = 0.5 - x1 * x1 - y1 * y1;\n\n  if (t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot2(x1, y1);\n  }\n\n  var t2 = 0.5 - x2 * x2 - y2 * y2;\n\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot2(x2, y2);\n  } // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n\n\n  return 70 * (n0 + n1 + n2);\n}; // 3D simplex noise\n\nvar simplex3 = function simplex3(xin, yin, zin) {\n  var n0, n1, n2, n3; // Noise contributions from the four corners\n  // Skew the input space to determine which simplex cell we're in\n\n  var s = (xin + yin + zin) * F3; // Hairy factor for 2D\n\n  var i = Math.floor(xin + s);\n  var j = Math.floor(yin + s);\n  var k = Math.floor(zin + s);\n  var t = (i + j + k) * G3;\n  var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\n  var y0 = yin - j + t;\n  var z0 = zin - k + t; // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n  // Determine which simplex we are in.\n\n  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\n  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\n  if (x0 >= y0) {\n    if (y0 >= z0) {\n      i1 = 1;\n      j1 = 0;\n      k1 = 0;\n      i2 = 1;\n      j2 = 1;\n      k2 = 0;\n    } else if (x0 >= z0) {\n      i1 = 1;\n      j1 = 0;\n      k1 = 0;\n      i2 = 1;\n      j2 = 0;\n      k2 = 1;\n    } else {\n      i1 = 0;\n      j1 = 0;\n      k1 = 1;\n      i2 = 1;\n      j2 = 0;\n      k2 = 1;\n    }\n  } else {\n    if (y0 < z0) {\n      i1 = 0;\n      j1 = 0;\n      k1 = 1;\n      i2 = 0;\n      j2 = 1;\n      k2 = 1;\n    } else if (x0 < z0) {\n      i1 = 0;\n      j1 = 1;\n      k1 = 0;\n      i2 = 0;\n      j2 = 1;\n      k2 = 1;\n    } else {\n      i1 = 0;\n      j1 = 1;\n      k1 = 0;\n      i2 = 1;\n      j2 = 1;\n      k2 = 0;\n    }\n  } // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n  // c = 1/6.\n\n\n  var x1 = x0 - i1 + G3; // Offsets for second corner\n\n  var y1 = y0 - j1 + G3;\n  var z1 = z0 - k1 + G3;\n  var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n\n  var y2 = y0 - j2 + 2 * G3;\n  var z2 = z0 - k2 + 2 * G3;\n  var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n\n  var y3 = y0 - 1 + 3 * G3;\n  var z3 = z0 - 1 + 3 * G3; // Work out the hashed gradient indices of the four simplex corners\n\n  i &= 255;\n  j &= 255;\n  k &= 255;\n  var gi0 = gradP[i + perm[j + perm[k]]];\n  var gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];\n  var gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];\n  var gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]]; // Calculate the contribution from the four corners\n\n  var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot3(x0, y0, z0); // (x,y) of grad3 used for 2D gradient\n  }\n\n  var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n\n  if (t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n  }\n\n  var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n  }\n\n  var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n\n  if (t3 < 0) {\n    n3 = 0;\n  } else {\n    t3 *= t3;\n    n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n  } // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n\n\n  return 32 * (n0 + n1 + n2 + n3);\n}; // ##### Perlin noise stuff\n// 2D Perlin Noise\n\nvar perlin2 = function perlin2(x, y) {\n  // Find unit grid cell containing point\n  var X = Math.floor(x),\n      Y = Math.floor(y); // Get relative xy coordinates of point within that cell\n\n  x = x - X;\n  y = y - Y; // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n\n  X = X & 255;\n  Y = Y & 255; // Calculate noise contributions from each of the four corners\n\n  var n00 = gradP[X + perm[Y]].dot2(x, y);\n  var n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);\n  var n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);\n  var n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1); // Compute the fade curve value for x\n\n  var u = (0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(x); // Interpolate the four results\n\n  return (0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)((0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(n00, n10, u), (0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(n01, n11, u), (0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(y));\n}; // 3D Perlin Noise\n\nvar perlin3 = function perlin3(x, y, z) {\n  // Find unit grid cell containing point\n  var X = Math.floor(x),\n      Y = Math.floor(y),\n      Z = Math.floor(z); // Get relative xyz coordinates of point within that cell\n\n  x = x - X;\n  y = y - Y;\n  z = z - Z; // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n\n  X = X & 255;\n  Y = Y & 255;\n  Z = Z & 255; // Calculate noise contributions from each of the eight corners\n\n  var n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);\n  var n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);\n  var n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);\n  var n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);\n  var n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);\n  var n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);\n  var n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);\n  var n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(x - 1, y - 1, z - 1); // Compute the fade curve value for x, y, z\n\n  var u = (0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(x);\n  var v = (0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(y);\n  var w = (0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(z); // Interpolate\n\n  return (0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)((0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)((0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(n000, n100, u), (0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(n001, n101, u), w), (0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)((0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(n010, n110, u), (0,_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(n011, n111, u), w), v);\n};\n\nvar noise = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  seed: seed,\n  simplex2: simplex2,\n  simplex3: simplex3,\n  perlin2: perlin2,\n  perlin3: perlin3\n});\n\nvar TAU = Math.PI * 2;\nvar FlashGen = /*#__PURE__*/function () {\n  function FlashGen(props) {\n    (0,_classCallCheck_9098b006_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(this, FlashGen);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"nextBurstTime\", 0);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"nextFlashEndTime\", 0);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"flashesDone\", 0);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"isFlashing\", false);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"currentCount\", 0);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"flashIntensity\", 0);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"isDecaying\", false);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"autoBurst\", true);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"decaySpeed\", 40);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"minInterval\", 5000);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"maxInterval\", 10000);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"minDuration\", 50);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"maxDuration\", 300);\n\n    (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"count\", 5);\n\n    Object.assign(this, props);\n  }\n\n  _createClass(FlashGen, [{\n    key: \"scheduleNextBurst\",\n    value: function scheduleNextBurst(currentTime) {\n      var burstInterval = Math.random() * (this.maxInterval - this.minInterval) + this.minInterval;\n      this.nextBurstTime = currentTime + burstInterval / 1000;\n      this.flashesDone = 0;\n      this.isFlashing = false;\n    }\n  }, {\n    key: \"burst\",\n    value: function burst() {\n      this.nextBurstTime = 0;\n      this.flashesDone = 0;\n      this.isFlashing = false;\n    }\n  }, {\n    key: \"update\",\n    value: function update(currentTime, delta) {\n      if (currentTime > this.nextBurstTime && this.currentCount === 0) {\n        this.currentCount = Math.floor(Math.random() * this.count) + 1;\n      }\n\n      if (this.flashesDone < this.currentCount && currentTime > this.nextBurstTime) {\n        if (!this.isFlashing) {\n          this.isFlashing = true;\n          this.flashIntensity = 1;\n          var flashDuration = Math.random() * (this.maxDuration - this.minDuration) + this.minDuration;\n          this.nextFlashEndTime = currentTime + flashDuration / 1000;\n        } else if (this.isFlashing && currentTime > this.nextFlashEndTime) {\n          this.isFlashing = false;\n          this.isDecaying = true;\n          this.flashesDone++;\n\n          if (this.flashesDone >= this.currentCount) {\n            this.currentCount = 0;\n            if (this.autoBurst) this.scheduleNextBurst(currentTime);\n          }\n        }\n      }\n\n      if (this.isDecaying) {\n        this.flashIntensity -= delta * this.decaySpeed;\n        this.flashIntensity = Math.max(0, Math.min(1, this.flashIntensity));\n\n        if (this.flashIntensity <= 0) {\n          this.isDecaying = false;\n          this.flashIntensity = 0;\n        }\n      }\n\n      return this.flashIntensity;\n    }\n  }]);\n\n  return FlashGen;\n}(); // Credits @kchapelier https://github.com/kchapelier/wavefunctioncollapse/blob/master/example/lcg.js#L22-L30\n\nfunction normalizeSeed(seed) {\n  if (typeof seed === \"number\") {\n    seed = Math.abs(seed);\n  } else if (typeof seed === \"string\") {\n    var string = seed;\n    seed = 0;\n\n    for (var i = 0; i < string.length; i++) {\n      seed = (seed + (i + 1) * (string.charCodeAt(i) % 96)) % 2147483647;\n    }\n  }\n\n  if (seed === 0) {\n    seed = 311;\n  }\n\n  return seed;\n}\n\nfunction lcgRandom(seed) {\n  var state = normalizeSeed(seed);\n  return function () {\n    var result = state * 48271 % 2147483647;\n    state = result;\n    return result / 2147483647;\n  };\n}\n\nvar Generator = function Generator(_seed) {\n  var _this = this;\n\n  (0,_classCallCheck_9098b006_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(this, Generator);\n\n  (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"seed\", 0);\n\n  (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"init\", function (seed) {\n    _this.seed = seed;\n    _this.value = lcgRandom(seed);\n  });\n\n  (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"value\", lcgRandom(this.seed));\n\n  this.init(_seed);\n};\nvar defaultGen = new Generator(Math.random());\n/***\n * [3D] Sphere\n */\n\nvar defaultSphere = {\n  radius: 1,\n  center: [0, 0, 0]\n}; // random on surface of sphere\n// - https://twitter.com/fermatslibrary/status/1430932503578226688\n// - https://mathworld.wolfram.com/SpherePointPicking.html\n\nfunction onSphere(buffer, sphere) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultSphere$sphere = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultSphere), sphere),\n      radius = _defaultSphere$sphere.radius,\n      center = _defaultSphere$sphere.center;\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    var u = rng.value();\n    var v = rng.value();\n    var theta = Math.acos(2 * v - 1);\n    var phi = TAU * u;\n    buffer[i] = Math.sin(theta) * Math.cos(phi) * radius + center[0];\n    buffer[i + 1] = Math.sin(theta) * Math.sin(phi) * radius + center[1];\n    buffer[i + 2] = Math.cos(theta) * radius + center[2];\n  }\n\n  return buffer;\n} // from \"Another Method\" https://datagenetics.com/blog/january32020/index.html\n\nfunction inSphere(buffer, sphere) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultSphere$sphere2 = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultSphere), sphere),\n      radius = _defaultSphere$sphere2.radius,\n      center = _defaultSphere$sphere2.center;\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    var u = Math.pow(rng.value(), 1 / 3);\n    var x = rng.value() * 2 - 1;\n    var y = rng.value() * 2 - 1;\n    var z = rng.value() * 2 - 1;\n    var mag = Math.sqrt(x * x + y * y + z * z);\n    x = u * x / mag;\n    y = u * y / mag;\n    z = u * z / mag;\n    buffer[i] = x * radius + center[0];\n    buffer[i + 1] = y * radius + center[1];\n    buffer[i + 2] = z * radius + center[2];\n  }\n\n  return buffer;\n}\n/***\n * [2D] Circle\n */\n\nvar defaultCircle = {\n  radius: 1,\n  center: [0, 0]\n}; // random circle https://stackoverflow.com/a/50746409\n\nfunction inCircle(buffer, circle) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultCircle$circle = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultCircle), circle),\n      radius = _defaultCircle$circle.radius,\n      center = _defaultCircle$circle.center;\n\n  for (var i = 0; i < buffer.length; i += 2) {\n    var r = radius * Math.sqrt(rng.value());\n    var theta = rng.value() * TAU;\n    buffer[i] = Math.sin(theta) * r + center[0];\n    buffer[i + 1] = Math.cos(theta) * r + center[1];\n  }\n\n  return buffer;\n}\nfunction onCircle(buffer, circle) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultCircle$circle2 = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultCircle), circle),\n      radius = _defaultCircle$circle2.radius,\n      center = _defaultCircle$circle2.center;\n\n  for (var i = 0; i < buffer.length; i += 2) {\n    var theta = rng.value() * TAU;\n    buffer[i] = Math.sin(theta) * radius + center[0];\n    buffer[i + 1] = Math.cos(theta) * radius + center[1];\n  }\n\n  return buffer;\n}\n/**\n * [2D] Plane\n */\n\nvar defaultRect = {\n  sides: 1,\n  center: [0, 0]\n};\nfunction inRect(buffer, rect) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultRect$rect = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultRect), rect),\n      sides = _defaultRect$rect.sides,\n      center = _defaultRect$rect.center;\n\n  var sideX = typeof sides === \"number\" ? sides : sides[0];\n  var sideY = typeof sides === \"number\" ? sides : sides[1];\n\n  for (var i = 0; i < buffer.length; i += 2) {\n    buffer[i] = (rng.value() - 0.5) * sideX + center[0];\n    buffer[i + 1] = (rng.value() - 0.5) * sideY + center[1];\n  }\n\n  return buffer;\n}\nfunction onRect(buffer, rect) {\n  return buffer;\n}\n/***\n * [3D] Box\n */\n\nfunction inBox(buffer, box) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultBox$box = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultBox), box),\n      sides = _defaultBox$box.sides,\n      center = _defaultBox$box.center;\n\n  var sideX = typeof sides === \"number\" ? sides : sides[0];\n  var sideY = typeof sides === \"number\" ? sides : sides[1];\n  var sideZ = typeof sides === \"number\" ? sides : sides[2];\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    buffer[i] = (rng.value() - 0.5) * sideX + center[0];\n    buffer[i + 1] = (rng.value() - 0.5) * sideY + center[1];\n    buffer[i + 2] = (rng.value() - 0.5) * sideZ + center[2];\n  }\n\n  return buffer;\n}\nvar defaultBox = {\n  sides: 1,\n  center: [0, 0, 0]\n};\nfunction onBox(buffer, box) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultBox$box2 = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultBox), box),\n      sides = _defaultBox$box2.sides,\n      center = _defaultBox$box2.center;\n\n  var sideX = typeof sides === \"number\" ? sides : sides[0];\n  var sideY = typeof sides === \"number\" ? sides : sides[1];\n  var sideZ = typeof sides === \"number\" ? sides : sides[2];\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    buffer[i] = (rng.value() - 0.5) * sideX + center[0];\n    buffer[i + 1] = (rng.value() - 0.5) * sideY + center[1];\n    buffer[i + 2] = (rng.value() - 0.5) * sideZ + center[2];\n  }\n\n  return buffer;\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  FlashGen: FlashGen,\n  Generator: Generator,\n  onSphere: onSphere,\n  inSphere: inSphere,\n  inCircle: inCircle,\n  onCircle: onCircle,\n  inRect: inRect,\n  onRect: onRect,\n  inBox: inBox,\n  onBox: onBox,\n  noise: noise\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9pbmRleC0wMzMyYjJlZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRGO0FBQ3BCO0FBQ1Y7O0FBRTlEO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUUsa0VBQWU7O0FBRWpCLEVBQUUsaUVBQWU7QUFDakI7QUFDQSxHQUFHOztBQUVILEVBQUUsaUVBQWU7QUFDakI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNHBDQUE0cEM7O0FBRTVwQztBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEIsd0JBQXdCO0FBQ3hCOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBLHlCQUF5Qjs7QUFFekI7QUFDQSw0QkFBNEI7O0FBRTVCLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUEsa0JBQWtCOztBQUVsQixrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQSxhQUFhOztBQUViO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNELFVBQVUsd0RBQUksS0FBSzs7QUFFbkIsU0FBUyx3REFBSSxDQUFDLHdEQUFJLGVBQWUsd0RBQUksZUFBZSx3REFBSTtBQUN4RCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjs7QUFFakYsVUFBVSx3REFBSTtBQUNkLFVBQVUsd0RBQUk7QUFDZCxVQUFVLHdEQUFJLEtBQUs7O0FBRW5CLFNBQVMsd0RBQUksQ0FBQyx3REFBSSxDQUFDLHdEQUFJLGlCQUFpQix3REFBSSxxQkFBcUIsd0RBQUksQ0FBQyx3REFBSSxpQkFBaUIsd0RBQUk7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLElBQUksa0VBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CLElBQUksaUVBQWU7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRSxrRUFBZTs7QUFFakIsRUFBRSxpRUFBZTs7QUFFakIsRUFBRSxpRUFBZTtBQUNqQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFLGlFQUFlOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIsaUVBQWMsQ0FBQyxpRUFBYyxHQUFHO0FBQzlEO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBLCtCQUErQixpRUFBYyxDQUFDLGlFQUFjLEdBQUc7QUFDL0Q7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSw4QkFBOEIsaUVBQWMsQ0FBQyxpRUFBYyxHQUFHO0FBQzlEO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixpRUFBYyxDQUFDLGlFQUFjLEdBQUc7QUFDL0Q7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixpRUFBYyxDQUFDLGlFQUFjLEdBQUc7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsaUVBQWMsQ0FBQyxpRUFBYyxHQUFHO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsaUVBQWMsQ0FBQyxpRUFBYyxHQUFHO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRThLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9pbmRleC0wMzMyYjJlZC5lc20uanM/ODk3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhIGFzIF9kZWZpbmVQcm9wZXJ0eSwgXyBhcyBfb2JqZWN0U3ByZWFkMiB9IGZyb20gJy4vb2JqZWN0U3ByZWFkMi0yODQyMzJhNi5lc20uanMnO1xuaW1wb3J0IHsgXyBhcyBfY2xhc3NDYWxsQ2hlY2sgfSBmcm9tICcuL2NsYXNzQ2FsbENoZWNrLTkwOThiMDA2LmVzbS5qcyc7XG5pbXBvcnQgeyBsIGFzIGxlcnAsIGYgYXMgZmFkZSB9IGZyb20gJy4vbWlzYy0xOWEzZWM0Ni5lc20uanMnO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbi8qXG4gKiBBIHNwZWVkLWltcHJvdmVkIHBlcmxpbiBhbmQgc2ltcGxleCBub2lzZSBhbGdvcml0aG1zIGZvciAyRC5cbiAqXG4gKiBCYXNlZCBvbiBleGFtcGxlIGNvZGUgYnkgU3RlZmFuIEd1c3RhdnNvbiAoc3RlZ3VAaXRuLmxpdS5zZSkuXG4gKiBPcHRpbWlzYXRpb25zIGJ5IFBldGVyIEVhc3RtYW4gKHBlYXN0bWFuQGRyaXp6bGUuc3RhbmZvcmQuZWR1KS5cbiAqIEJldHRlciByYW5rIG9yZGVyaW5nIG1ldGhvZCBieSBTdGVmYW4gR3VzdGF2c29uIGluIDIwMTIuXG4gKiBDb252ZXJ0ZWQgdG8gSmF2YXNjcmlwdCBieSBKb3NlcGggR2VudGxlLlxuICpcbiAqIFZlcnNpb24gMjAxMi0wMy0wOVxuICpcbiAqIFRoaXMgY29kZSB3YXMgcGxhY2VkIGluIHRoZSBwdWJsaWMgZG9tYWluIGJ5IGl0cyBvcmlnaW5hbCBhdXRob3IsXG4gKiBTdGVmYW4gR3VzdGF2c29uLiBZb3UgbWF5IHVzZSBpdCBhcyB5b3Ugc2VlIGZpdCwgYnV0XG4gKiBhdHRyaWJ1dGlvbiBpcyBhcHByZWNpYXRlZC5cbiAqXG4gKi9cblxudmFyIEdyYWQgPSBmdW5jdGlvbiBHcmFkKHgsIHksIHopIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JhZCk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZG90MlwiLCBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiBfdGhpcy54ICogeCArIF90aGlzLnkgKiB5O1xuICB9KTtcblxuICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb3QzXCIsIGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgcmV0dXJuIF90aGlzLnggKiB4ICsgX3RoaXMueSAqIHkgKyBfdGhpcy56ICogejtcbiAgfSk7XG5cbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbiAgdGhpcy56ID0gejtcbn07XG5cbnZhciBncmFkMyA9IFtuZXcgR3JhZCgxLCAxLCAwKSwgbmV3IEdyYWQoLTEsIDEsIDApLCBuZXcgR3JhZCgxLCAtMSwgMCksIG5ldyBHcmFkKC0xLCAtMSwgMCksIG5ldyBHcmFkKDEsIDAsIDEpLCBuZXcgR3JhZCgtMSwgMCwgMSksIG5ldyBHcmFkKDEsIDAsIC0xKSwgbmV3IEdyYWQoLTEsIDAsIC0xKSwgbmV3IEdyYWQoMCwgMSwgMSksIG5ldyBHcmFkKDAsIC0xLCAxKSwgbmV3IEdyYWQoMCwgMSwgLTEpLCBuZXcgR3JhZCgwLCAtMSwgLTEpXTtcbnZhciBwID0gWzE1MSwgMTYwLCAxMzcsIDkxLCA5MCwgMTUsIDEzMSwgMTMsIDIwMSwgOTUsIDk2LCA1MywgMTk0LCAyMzMsIDcsIDIyNSwgMTQwLCAzNiwgMTAzLCAzMCwgNjksIDE0MiwgOCwgOTksIDM3LCAyNDAsIDIxLCAxMCwgMjMsIDE5MCwgNiwgMTQ4LCAyNDcsIDEyMCwgMjM0LCA3NSwgMCwgMjYsIDE5NywgNjIsIDk0LCAyNTIsIDIxOSwgMjAzLCAxMTcsIDM1LCAxMSwgMzIsIDU3LCAxNzcsIDMzLCA4OCwgMjM3LCAxNDksIDU2LCA4NywgMTc0LCAyMCwgMTI1LCAxMzYsIDE3MSwgMTY4LCA2OCwgMTc1LCA3NCwgMTY1LCA3MSwgMTM0LCAxMzksIDQ4LCAyNywgMTY2LCA3NywgMTQ2LCAxNTgsIDIzMSwgODMsIDExMSwgMjI5LCAxMjIsIDYwLCAyMTEsIDEzMywgMjMwLCAyMjAsIDEwNSwgOTIsIDQxLCA1NSwgNDYsIDI0NSwgNDAsIDI0NCwgMTAyLCAxNDMsIDU0LCA2NSwgMjUsIDYzLCAxNjEsIDEsIDIxNiwgODAsIDczLCAyMDksIDc2LCAxMzIsIDE4NywgMjA4LCA4OSwgMTgsIDE2OSwgMjAwLCAxOTYsIDEzNSwgMTMwLCAxMTYsIDE4OCwgMTU5LCA4NiwgMTY0LCAxMDAsIDEwOSwgMTk4LCAxNzMsIDE4NiwgMywgNjQsIDUyLCAyMTcsIDIyNiwgMjUwLCAxMjQsIDEyMywgNSwgMjAyLCAzOCwgMTQ3LCAxMTgsIDEyNiwgMjU1LCA4MiwgODUsIDIxMiwgMjA3LCAyMDYsIDU5LCAyMjcsIDQ3LCAxNiwgNTgsIDE3LCAxODIsIDE4OSwgMjgsIDQyLCAyMjMsIDE4MywgMTcwLCAyMTMsIDExOSwgMjQ4LCAxNTIsIDIsIDQ0LCAxNTQsIDE2MywgNzAsIDIyMSwgMTUzLCAxMDEsIDE1NSwgMTY3LCA0MywgMTcyLCA5LCAxMjksIDIyLCAzOSwgMjUzLCAxOSwgOTgsIDEwOCwgMTEwLCA3OSwgMTEzLCAyMjQsIDIzMiwgMTc4LCAxODUsIDExMiwgMTA0LCAyMTgsIDI0NiwgOTcsIDIyOCwgMjUxLCAzNCwgMjQyLCAxOTMsIDIzOCwgMjEwLCAxNDQsIDEyLCAxOTEsIDE3OSwgMTYyLCAyNDEsIDgxLCA1MSwgMTQ1LCAyMzUsIDI0OSwgMTQsIDIzOSwgMTA3LCA0OSwgMTkyLCAyMTQsIDMxLCAxODEsIDE5OSwgMTA2LCAxNTcsIDE4NCwgODQsIDIwNCwgMTc2LCAxMTUsIDEyMSwgNTAsIDQ1LCAxMjcsIDQsIDE1MCwgMjU0LCAxMzgsIDIzNiwgMjA1LCA5MywgMjIyLCAxMTQsIDY3LCAyOSwgMjQsIDcyLCAyNDMsIDE0MSwgMTI4LCAxOTUsIDc4LCA2NiwgMjE1LCA2MSwgMTU2LCAxODBdOyAvLyBUbyByZW1vdmUgdGhlIG5lZWQgZm9yIGluZGV4IHdyYXBwaW5nLCBkb3VibGUgdGhlIHBlcm11dGF0aW9uIHRhYmxlIGxlbmd0aFxuXG52YXIgcGVybSA9IG5ldyBBcnJheSg1MTIpO1xudmFyIGdyYWRQID0gbmV3IEFycmF5KDUxMik7IC8vIFRoaXMgaXNuJ3QgYSB2ZXJ5IGdvb2Qgc2VlZGluZyBmdW5jdGlvbiwgYnV0IGl0IHdvcmtzIG9rLiBJdCBzdXBwb3J0cyAyXjE2XG4vLyBkaWZmZXJlbnQgc2VlZCB2YWx1ZXMuIFdyaXRlIHNvbWV0aGluZyBiZXR0ZXIgaWYgeW91IG5lZWQgbW9yZSBzZWVkcy5cblxudmFyIHNlZWQgPSBmdW5jdGlvbiBzZWVkKF9zZWVkKSB7XG4gIGlmIChfc2VlZCA+IDAgJiYgX3NlZWQgPCAxKSB7XG4gICAgLy8gU2NhbGUgdGhlIHNlZWQgb3V0XG4gICAgX3NlZWQgKj0gNjU1MzY7XG4gIH1cblxuICBfc2VlZCA9IE1hdGguZmxvb3IoX3NlZWQpO1xuXG4gIGlmIChfc2VlZCA8IDI1Nikge1xuICAgIF9zZWVkIHw9IF9zZWVkIDw8IDg7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgdmFyIHY7XG5cbiAgICBpZiAoaSAmIDEpIHtcbiAgICAgIHYgPSBwW2ldIF4gX3NlZWQgJiAyNTU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHYgPSBwW2ldIF4gX3NlZWQgPj4gOCAmIDI1NTtcbiAgICB9XG5cbiAgICBwZXJtW2ldID0gcGVybVtpICsgMjU2XSA9IHY7XG4gICAgZ3JhZFBbaV0gPSBncmFkUFtpICsgMjU2XSA9IGdyYWQzW3YgJSAxMl07XG4gIH1cbn07XG5zZWVkKDApO1xuLypcbiAgZm9yKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgICBwZXJtW2ldID0gcGVybVtpICsgMjU2XSA9IHBbaV07XG4gICAgZ3JhZFBbaV0gPSBncmFkUFtpICsgMjU2XSA9IGdyYWQzW3Blcm1baV0gJSAxMl07XG4gIH0qL1xuLy8gU2tld2luZyBhbmQgdW5za2V3aW5nIGZhY3RvcnMgZm9yIDIsIDMsIGFuZCA0IGRpbWVuc2lvbnNcblxudmFyIEYyID0gMC41ICogKE1hdGguc3FydCgzKSAtIDEpO1xudmFyIEcyID0gKDMgLSBNYXRoLnNxcnQoMykpIC8gNjtcbnZhciBGMyA9IDEgLyAzO1xudmFyIEczID0gMSAvIDY7IC8vIDJEIHNpbXBsZXggbm9pc2VcblxudmFyIHNpbXBsZXgyID0gZnVuY3Rpb24gc2ltcGxleDIoeGluLCB5aW4pIHtcbiAgdmFyIG4wLCBuMSwgbjI7IC8vIE5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgdGhyZWUgY29ybmVyc1xuICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG5cbiAgdmFyIHMgPSAoeGluICsgeWluKSAqIEYyOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXG5cbiAgdmFyIGkgPSBNYXRoLmZsb29yKHhpbiArIHMpO1xuICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XG4gIHZhciB0ID0gKGkgKyBqKSAqIEcyO1xuICB2YXIgeDAgPSB4aW4gLSBpICsgdDsgLy8gVGhlIHgseSBkaXN0YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW4sIHVuc2tld2VkLlxuXG4gIHZhciB5MCA9IHlpbiAtIGogKyB0OyAvLyBGb3IgdGhlIDJEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlLlxuICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXG5cbiAgdmFyIGkxLCBqMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIChtaWRkbGUpIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGopIGNvb3Jkc1xuXG4gIGlmICh4MCA+IHkwKSB7XG4gICAgLy8gbG93ZXIgdHJpYW5nbGUsIFhZIG9yZGVyOiAoMCwwKS0+KDEsMCktPigxLDEpXG4gICAgaTEgPSAxO1xuICAgIGoxID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cHBlciB0cmlhbmdsZSwgWVggb3JkZXI6ICgwLDApLT4oMCwxKS0+KDEsMSlcbiAgICBpMSA9IDA7XG4gICAgajEgPSAxO1xuICB9IC8vIEEgc3RlcCBvZiAoMSwwKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYykgaW4gKHgseSksIGFuZFxuICAvLyBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMpIGluICh4LHkpLCB3aGVyZVxuICAvLyBjID0gKDMtc3FydCgzKSkvNlxuXG5cbiAgdmFyIHgxID0geDAgLSBpMSArIEcyOyAvLyBPZmZzZXRzIGZvciBtaWRkbGUgY29ybmVyIGluICh4LHkpIHVuc2tld2VkIGNvb3Jkc1xuXG4gIHZhciB5MSA9IHkwIC0gajEgKyBHMjtcbiAgdmFyIHgyID0geDAgLSAxICsgMiAqIEcyOyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcblxuICB2YXIgeTIgPSB5MCAtIDEgKyAyICogRzI7IC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgdGhyZWUgc2ltcGxleCBjb3JuZXJzXG5cbiAgaSAmPSAyNTU7XG4gIGogJj0gMjU1O1xuICB2YXIgZ2kwID0gZ3JhZFBbaSArIHBlcm1bal1dO1xuICB2YXIgZ2kxID0gZ3JhZFBbaSArIGkxICsgcGVybVtqICsgajFdXTtcbiAgdmFyIGdpMiA9IGdyYWRQW2kgKyAxICsgcGVybVtqICsgMV1dOyAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXG5cbiAgdmFyIHQwID0gMC41IC0geDAgKiB4MCAtIHkwICogeTA7XG5cbiAgaWYgKHQwIDwgMCkge1xuICAgIG4wID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MCAqPSB0MDtcbiAgICBuMCA9IHQwICogdDAgKiBnaTAuZG90Mih4MCwgeTApOyAvLyAoeCx5KSBvZiBncmFkMyB1c2VkIGZvciAyRCBncmFkaWVudFxuICB9XG5cbiAgdmFyIHQxID0gMC41IC0geDEgKiB4MSAtIHkxICogeTE7XG5cbiAgaWYgKHQxIDwgMCkge1xuICAgIG4xID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MSAqPSB0MTtcbiAgICBuMSA9IHQxICogdDEgKiBnaTEuZG90Mih4MSwgeTEpO1xuICB9XG5cbiAgdmFyIHQyID0gMC41IC0geDIgKiB4MiAtIHkyICogeTI7XG5cbiAgaWYgKHQyIDwgMCkge1xuICAgIG4yID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MiAqPSB0MjtcbiAgICBuMiA9IHQyICogdDIgKiBnaTIuZG90Mih4MiwgeTIpO1xuICB9IC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgaW50ZXJ2YWwgWy0xLDFdLlxuXG5cbiAgcmV0dXJuIDcwICogKG4wICsgbjEgKyBuMik7XG59OyAvLyAzRCBzaW1wbGV4IG5vaXNlXG5cbnZhciBzaW1wbGV4MyA9IGZ1bmN0aW9uIHNpbXBsZXgzKHhpbiwgeWluLCB6aW4pIHtcbiAgdmFyIG4wLCBuMSwgbjIsIG4zOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIGZvdXIgY29ybmVyc1xuICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG5cbiAgdmFyIHMgPSAoeGluICsgeWluICsgemluKSAqIEYzOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXG5cbiAgdmFyIGkgPSBNYXRoLmZsb29yKHhpbiArIHMpO1xuICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XG4gIHZhciBrID0gTWF0aC5mbG9vcih6aW4gKyBzKTtcbiAgdmFyIHQgPSAoaSArIGogKyBrKSAqIEczO1xuICB2YXIgeDAgPSB4aW4gLSBpICsgdDsgLy8gVGhlIHgseSBkaXN0YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW4sIHVuc2tld2VkLlxuXG4gIHZhciB5MCA9IHlpbiAtIGogKyB0O1xuICB2YXIgejAgPSB6aW4gLSBrICsgdDsgLy8gRm9yIHRoZSAzRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhIHNsaWdodGx5IGlycmVndWxhciB0ZXRyYWhlZHJvbi5cbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLlxuXG4gIHZhciBpMSwgajEsIGsxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcblxuICB2YXIgaTIsIGoyLCBrMjsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcblxuICBpZiAoeDAgPj0geTApIHtcbiAgICBpZiAoeTAgPj0gejApIHtcbiAgICAgIGkxID0gMTtcbiAgICAgIGoxID0gMDtcbiAgICAgIGsxID0gMDtcbiAgICAgIGkyID0gMTtcbiAgICAgIGoyID0gMTtcbiAgICAgIGsyID0gMDtcbiAgICB9IGVsc2UgaWYgKHgwID49IHowKSB7XG4gICAgICBpMSA9IDE7XG4gICAgICBqMSA9IDA7XG4gICAgICBrMSA9IDA7XG4gICAgICBpMiA9IDE7XG4gICAgICBqMiA9IDA7XG4gICAgICBrMiA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkxID0gMDtcbiAgICAgIGoxID0gMDtcbiAgICAgIGsxID0gMTtcbiAgICAgIGkyID0gMTtcbiAgICAgIGoyID0gMDtcbiAgICAgIGsyID0gMTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHkwIDwgejApIHtcbiAgICAgIGkxID0gMDtcbiAgICAgIGoxID0gMDtcbiAgICAgIGsxID0gMTtcbiAgICAgIGkyID0gMDtcbiAgICAgIGoyID0gMTtcbiAgICAgIGsyID0gMTtcbiAgICB9IGVsc2UgaWYgKHgwIDwgejApIHtcbiAgICAgIGkxID0gMDtcbiAgICAgIGoxID0gMTtcbiAgICAgIGsxID0gMDtcbiAgICAgIGkyID0gMDtcbiAgICAgIGoyID0gMTtcbiAgICAgIGsyID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaTEgPSAwO1xuICAgICAgajEgPSAxO1xuICAgICAgazEgPSAwO1xuICAgICAgaTIgPSAxO1xuICAgICAgajIgPSAxO1xuICAgICAgazIgPSAwO1xuICAgIH1cbiAgfSAvLyBBIHN0ZXAgb2YgKDEsMCwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jLC1jKSBpbiAoeCx5LHopLFxuICAvLyBhIHN0ZXAgb2YgKDAsMSwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jLC1jKSBpbiAoeCx5LHopLCBhbmRcbiAgLy8gYSBzdGVwIG9mICgwLDAsMSkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKC1jLC1jLDEtYykgaW4gKHgseSx6KSwgd2hlcmVcbiAgLy8gYyA9IDEvNi5cblxuXG4gIHZhciB4MSA9IHgwIC0gaTEgKyBHMzsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lclxuXG4gIHZhciB5MSA9IHkwIC0gajEgKyBHMztcbiAgdmFyIHoxID0gejAgLSBrMSArIEczO1xuICB2YXIgeDIgPSB4MCAtIGkyICsgMiAqIEczOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXJcblxuICB2YXIgeTIgPSB5MCAtIGoyICsgMiAqIEczO1xuICB2YXIgejIgPSB6MCAtIGsyICsgMiAqIEczO1xuICB2YXIgeDMgPSB4MCAtIDEgKyAzICogRzM7IC8vIE9mZnNldHMgZm9yIGZvdXJ0aCBjb3JuZXJcblxuICB2YXIgeTMgPSB5MCAtIDEgKyAzICogRzM7XG4gIHZhciB6MyA9IHowIC0gMSArIDMgKiBHMzsgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmb3VyIHNpbXBsZXggY29ybmVyc1xuXG4gIGkgJj0gMjU1O1xuICBqICY9IDI1NTtcbiAgayAmPSAyNTU7XG4gIHZhciBnaTAgPSBncmFkUFtpICsgcGVybVtqICsgcGVybVtrXV1dO1xuICB2YXIgZ2kxID0gZ3JhZFBbaSArIGkxICsgcGVybVtqICsgajEgKyBwZXJtW2sgKyBrMV1dXTtcbiAgdmFyIGdpMiA9IGdyYWRQW2kgKyBpMiArIHBlcm1baiArIGoyICsgcGVybVtrICsgazJdXV07XG4gIHZhciBnaTMgPSBncmFkUFtpICsgMSArIHBlcm1baiArIDEgKyBwZXJtW2sgKyAxXV1dOyAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBmb3VyIGNvcm5lcnNcblxuICB2YXIgdDAgPSAwLjYgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejA7XG5cbiAgaWYgKHQwIDwgMCkge1xuICAgIG4wID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MCAqPSB0MDtcbiAgICBuMCA9IHQwICogdDAgKiBnaTAuZG90Myh4MCwgeTAsIHowKTsgLy8gKHgseSkgb2YgZ3JhZDMgdXNlZCBmb3IgMkQgZ3JhZGllbnRcbiAgfVxuXG4gIHZhciB0MSA9IDAuNiAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MTtcblxuICBpZiAodDEgPCAwKSB7XG4gICAgbjEgPSAwO1xuICB9IGVsc2Uge1xuICAgIHQxICo9IHQxO1xuICAgIG4xID0gdDEgKiB0MSAqIGdpMS5kb3QzKHgxLCB5MSwgejEpO1xuICB9XG5cbiAgdmFyIHQyID0gMC42IC0geDIgKiB4MiAtIHkyICogeTIgLSB6MiAqIHoyO1xuXG4gIGlmICh0MiA8IDApIHtcbiAgICBuMiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdDIgKj0gdDI7XG4gICAgbjIgPSB0MiAqIHQyICogZ2kyLmRvdDMoeDIsIHkyLCB6Mik7XG4gIH1cblxuICB2YXIgdDMgPSAwLjYgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejM7XG5cbiAgaWYgKHQzIDwgMCkge1xuICAgIG4zID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MyAqPSB0MztcbiAgICBuMyA9IHQzICogdDMgKiBnaTMuZG90Myh4MywgeTMsIHozKTtcbiAgfSAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuXG4gIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHJldHVybiB2YWx1ZXMgaW4gdGhlIGludGVydmFsIFstMSwxXS5cblxuXG4gIHJldHVybiAzMiAqIChuMCArIG4xICsgbjIgKyBuMyk7XG59OyAvLyAjIyMjIyBQZXJsaW4gbm9pc2Ugc3R1ZmZcbi8vIDJEIFBlcmxpbiBOb2lzZVxuXG52YXIgcGVybGluMiA9IGZ1bmN0aW9uIHBlcmxpbjIoeCwgeSkge1xuICAvLyBGaW5kIHVuaXQgZ3JpZCBjZWxsIGNvbnRhaW5pbmcgcG9pbnRcbiAgdmFyIFggPSBNYXRoLmZsb29yKHgpLFxuICAgICAgWSA9IE1hdGguZmxvb3IoeSk7IC8vIEdldCByZWxhdGl2ZSB4eSBjb29yZGluYXRlcyBvZiBwb2ludCB3aXRoaW4gdGhhdCBjZWxsXG5cbiAgeCA9IHggLSBYO1xuICB5ID0geSAtIFk7IC8vIFdyYXAgdGhlIGludGVnZXIgY2VsbHMgYXQgMjU1IChzbWFsbGVyIGludGVnZXIgcGVyaW9kIGNhbiBiZSBpbnRyb2R1Y2VkIGhlcmUpXG5cbiAgWCA9IFggJiAyNTU7XG4gIFkgPSBZICYgMjU1OyAvLyBDYWxjdWxhdGUgbm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggb2YgdGhlIGZvdXIgY29ybmVyc1xuXG4gIHZhciBuMDAgPSBncmFkUFtYICsgcGVybVtZXV0uZG90Mih4LCB5KTtcbiAgdmFyIG4wMSA9IGdyYWRQW1ggKyBwZXJtW1kgKyAxXV0uZG90Mih4LCB5IC0gMSk7XG4gIHZhciBuMTAgPSBncmFkUFtYICsgMSArIHBlcm1bWV1dLmRvdDIoeCAtIDEsIHkpO1xuICB2YXIgbjExID0gZ3JhZFBbWCArIDEgKyBwZXJtW1kgKyAxXV0uZG90Mih4IC0gMSwgeSAtIDEpOyAvLyBDb21wdXRlIHRoZSBmYWRlIGN1cnZlIHZhbHVlIGZvciB4XG5cbiAgdmFyIHUgPSBmYWRlKHgpOyAvLyBJbnRlcnBvbGF0ZSB0aGUgZm91ciByZXN1bHRzXG5cbiAgcmV0dXJuIGxlcnAobGVycChuMDAsIG4xMCwgdSksIGxlcnAobjAxLCBuMTEsIHUpLCBmYWRlKHkpKTtcbn07IC8vIDNEIFBlcmxpbiBOb2lzZVxuXG52YXIgcGVybGluMyA9IGZ1bmN0aW9uIHBlcmxpbjMoeCwgeSwgeikge1xuICAvLyBGaW5kIHVuaXQgZ3JpZCBjZWxsIGNvbnRhaW5pbmcgcG9pbnRcbiAgdmFyIFggPSBNYXRoLmZsb29yKHgpLFxuICAgICAgWSA9IE1hdGguZmxvb3IoeSksXG4gICAgICBaID0gTWF0aC5mbG9vcih6KTsgLy8gR2V0IHJlbGF0aXZlIHh5eiBjb29yZGluYXRlcyBvZiBwb2ludCB3aXRoaW4gdGhhdCBjZWxsXG5cbiAgeCA9IHggLSBYO1xuICB5ID0geSAtIFk7XG4gIHogPSB6IC0gWjsgLy8gV3JhcCB0aGUgaW50ZWdlciBjZWxscyBhdCAyNTUgKHNtYWxsZXIgaW50ZWdlciBwZXJpb2QgY2FuIGJlIGludHJvZHVjZWQgaGVyZSlcblxuICBYID0gWCAmIDI1NTtcbiAgWSA9IFkgJiAyNTU7XG4gIFogPSBaICYgMjU1OyAvLyBDYWxjdWxhdGUgbm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggb2YgdGhlIGVpZ2h0IGNvcm5lcnNcblxuICB2YXIgbjAwMCA9IGdyYWRQW1ggKyBwZXJtW1kgKyBwZXJtW1pdXV0uZG90Myh4LCB5LCB6KTtcbiAgdmFyIG4wMDEgPSBncmFkUFtYICsgcGVybVtZICsgcGVybVtaICsgMV1dXS5kb3QzKHgsIHksIHogLSAxKTtcbiAgdmFyIG4wMTAgPSBncmFkUFtYICsgcGVybVtZICsgMSArIHBlcm1bWl1dXS5kb3QzKHgsIHkgLSAxLCB6KTtcbiAgdmFyIG4wMTEgPSBncmFkUFtYICsgcGVybVtZICsgMSArIHBlcm1bWiArIDFdXV0uZG90Myh4LCB5IC0gMSwgeiAtIDEpO1xuICB2YXIgbjEwMCA9IGdyYWRQW1ggKyAxICsgcGVybVtZICsgcGVybVtaXV1dLmRvdDMoeCAtIDEsIHksIHopO1xuICB2YXIgbjEwMSA9IGdyYWRQW1ggKyAxICsgcGVybVtZICsgcGVybVtaICsgMV1dXS5kb3QzKHggLSAxLCB5LCB6IC0gMSk7XG4gIHZhciBuMTEwID0gZ3JhZFBbWCArIDEgKyBwZXJtW1kgKyAxICsgcGVybVtaXV1dLmRvdDMoeCAtIDEsIHkgLSAxLCB6KTtcbiAgdmFyIG4xMTEgPSBncmFkUFtYICsgMSArIHBlcm1bWSArIDEgKyBwZXJtW1ogKyAxXV1dLmRvdDMoeCAtIDEsIHkgLSAxLCB6IC0gMSk7IC8vIENvbXB1dGUgdGhlIGZhZGUgY3VydmUgdmFsdWUgZm9yIHgsIHksIHpcblxuICB2YXIgdSA9IGZhZGUoeCk7XG4gIHZhciB2ID0gZmFkZSh5KTtcbiAgdmFyIHcgPSBmYWRlKHopOyAvLyBJbnRlcnBvbGF0ZVxuXG4gIHJldHVybiBsZXJwKGxlcnAobGVycChuMDAwLCBuMTAwLCB1KSwgbGVycChuMDAxLCBuMTAxLCB1KSwgdyksIGxlcnAobGVycChuMDEwLCBuMTEwLCB1KSwgbGVycChuMDExLCBuMTExLCB1KSwgdyksIHYpO1xufTtcblxudmFyIG5vaXNlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHNlZWQ6IHNlZWQsXG4gIHNpbXBsZXgyOiBzaW1wbGV4MixcbiAgc2ltcGxleDM6IHNpbXBsZXgzLFxuICBwZXJsaW4yOiBwZXJsaW4yLFxuICBwZXJsaW4zOiBwZXJsaW4zXG59KTtcblxudmFyIFRBVSA9IE1hdGguUEkgKiAyO1xudmFyIEZsYXNoR2VuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmxhc2hHZW4ocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmxhc2hHZW4pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmV4dEJ1cnN0VGltZVwiLCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5leHRGbGFzaEVuZFRpbWVcIiwgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmbGFzaGVzRG9uZVwiLCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzRmxhc2hpbmdcIiwgZmFsc2UpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY3VycmVudENvdW50XCIsIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmxhc2hJbnRlbnNpdHlcIiwgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc0RlY2F5aW5nXCIsIGZhbHNlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CdXJzdFwiLCB0cnVlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlY2F5U3BlZWRcIiwgNDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWluSW50ZXJ2YWxcIiwgNTAwMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhJbnRlcnZhbFwiLCAxMDAwMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtaW5EdXJhdGlvblwiLCA1MCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhEdXJhdGlvblwiLCAzMDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY291bnRcIiwgNSk7XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGbGFzaEdlbiwgW3tcbiAgICBrZXk6IFwic2NoZWR1bGVOZXh0QnVyc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NoZWR1bGVOZXh0QnVyc3QoY3VycmVudFRpbWUpIHtcbiAgICAgIHZhciBidXJzdEludGVydmFsID0gTWF0aC5yYW5kb20oKSAqICh0aGlzLm1heEludGVydmFsIC0gdGhpcy5taW5JbnRlcnZhbCkgKyB0aGlzLm1pbkludGVydmFsO1xuICAgICAgdGhpcy5uZXh0QnVyc3RUaW1lID0gY3VycmVudFRpbWUgKyBidXJzdEludGVydmFsIC8gMTAwMDtcbiAgICAgIHRoaXMuZmxhc2hlc0RvbmUgPSAwO1xuICAgICAgdGhpcy5pc0ZsYXNoaW5nID0gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1cnN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1cnN0KCkge1xuICAgICAgdGhpcy5uZXh0QnVyc3RUaW1lID0gMDtcbiAgICAgIHRoaXMuZmxhc2hlc0RvbmUgPSAwO1xuICAgICAgdGhpcy5pc0ZsYXNoaW5nID0gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoY3VycmVudFRpbWUsIGRlbHRhKSB7XG4gICAgICBpZiAoY3VycmVudFRpbWUgPiB0aGlzLm5leHRCdXJzdFRpbWUgJiYgdGhpcy5jdXJyZW50Q291bnQgPT09IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Q291bnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLmNvdW50KSArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZsYXNoZXNEb25lIDwgdGhpcy5jdXJyZW50Q291bnQgJiYgY3VycmVudFRpbWUgPiB0aGlzLm5leHRCdXJzdFRpbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRmxhc2hpbmcpIHtcbiAgICAgICAgICB0aGlzLmlzRmxhc2hpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZmxhc2hJbnRlbnNpdHkgPSAxO1xuICAgICAgICAgIHZhciBmbGFzaER1cmF0aW9uID0gTWF0aC5yYW5kb20oKSAqICh0aGlzLm1heER1cmF0aW9uIC0gdGhpcy5taW5EdXJhdGlvbikgKyB0aGlzLm1pbkR1cmF0aW9uO1xuICAgICAgICAgIHRoaXMubmV4dEZsYXNoRW5kVGltZSA9IGN1cnJlbnRUaW1lICsgZmxhc2hEdXJhdGlvbiAvIDEwMDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0ZsYXNoaW5nICYmIGN1cnJlbnRUaW1lID4gdGhpcy5uZXh0Rmxhc2hFbmRUaW1lKSB7XG4gICAgICAgICAgdGhpcy5pc0ZsYXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5pc0RlY2F5aW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmZsYXNoZXNEb25lKys7XG5cbiAgICAgICAgICBpZiAodGhpcy5mbGFzaGVzRG9uZSA+PSB0aGlzLmN1cnJlbnRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q291bnQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0J1cnN0KSB0aGlzLnNjaGVkdWxlTmV4dEJ1cnN0KGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEZWNheWluZykge1xuICAgICAgICB0aGlzLmZsYXNoSW50ZW5zaXR5IC09IGRlbHRhICogdGhpcy5kZWNheVNwZWVkO1xuICAgICAgICB0aGlzLmZsYXNoSW50ZW5zaXR5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy5mbGFzaEludGVuc2l0eSkpO1xuXG4gICAgICAgIGlmICh0aGlzLmZsYXNoSW50ZW5zaXR5IDw9IDApIHtcbiAgICAgICAgICB0aGlzLmlzRGVjYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmZsYXNoSW50ZW5zaXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5mbGFzaEludGVuc2l0eTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmxhc2hHZW47XG59KCk7IC8vIENyZWRpdHMgQGtjaGFwZWxpZXIgaHR0cHM6Ly9naXRodWIuY29tL2tjaGFwZWxpZXIvd2F2ZWZ1bmN0aW9uY29sbGFwc2UvYmxvYi9tYXN0ZXIvZXhhbXBsZS9sY2cuanMjTDIyLUwzMFxuXG5mdW5jdGlvbiBub3JtYWxpemVTZWVkKHNlZWQpIHtcbiAgaWYgKHR5cGVvZiBzZWVkID09PSBcIm51bWJlclwiKSB7XG4gICAgc2VlZCA9IE1hdGguYWJzKHNlZWQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgdmFyIHN0cmluZyA9IHNlZWQ7XG4gICAgc2VlZCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgc2VlZCA9IChzZWVkICsgKGkgKyAxKSAqIChzdHJpbmcuY2hhckNvZGVBdChpKSAlIDk2KSkgJSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZWVkID09PSAwKSB7XG4gICAgc2VlZCA9IDMxMTtcbiAgfVxuXG4gIHJldHVybiBzZWVkO1xufVxuXG5mdW5jdGlvbiBsY2dSYW5kb20oc2VlZCkge1xuICB2YXIgc3RhdGUgPSBub3JtYWxpemVTZWVkKHNlZWQpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZSAqIDQ4MjcxICUgMjE0NzQ4MzY0NztcbiAgICBzdGF0ZSA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0IC8gMjE0NzQ4MzY0NztcbiAgfTtcbn1cblxudmFyIEdlbmVyYXRvciA9IGZ1bmN0aW9uIEdlbmVyYXRvcihfc2VlZCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHZW5lcmF0b3IpO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlZWRcIiwgMCk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5pdFwiLCBmdW5jdGlvbiAoc2VlZCkge1xuICAgIF90aGlzLnNlZWQgPSBzZWVkO1xuICAgIF90aGlzLnZhbHVlID0gbGNnUmFuZG9tKHNlZWQpO1xuICB9KTtcblxuICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCBsY2dSYW5kb20odGhpcy5zZWVkKSk7XG5cbiAgdGhpcy5pbml0KF9zZWVkKTtcbn07XG52YXIgZGVmYXVsdEdlbiA9IG5ldyBHZW5lcmF0b3IoTWF0aC5yYW5kb20oKSk7XG4vKioqXG4gKiBbM0RdIFNwaGVyZVxuICovXG5cbnZhciBkZWZhdWx0U3BoZXJlID0ge1xuICByYWRpdXM6IDEsXG4gIGNlbnRlcjogWzAsIDAsIDBdXG59OyAvLyByYW5kb20gb24gc3VyZmFjZSBvZiBzcGhlcmVcbi8vIC0gaHR0cHM6Ly90d2l0dGVyLmNvbS9mZXJtYXRzbGlicmFyeS9zdGF0dXMvMTQzMDkzMjUwMzU3ODIyNjY4OFxuLy8gLSBodHRwczovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9TcGhlcmVQb2ludFBpY2tpbmcuaHRtbFxuXG5mdW5jdGlvbiBvblNwaGVyZShidWZmZXIsIHNwaGVyZSkge1xuICB2YXIgcm5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBkZWZhdWx0R2VuO1xuXG4gIHZhciBfZGVmYXVsdFNwaGVyZSRzcGhlcmUgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdFNwaGVyZSksIHNwaGVyZSksXG4gICAgICByYWRpdXMgPSBfZGVmYXVsdFNwaGVyZSRzcGhlcmUucmFkaXVzLFxuICAgICAgY2VudGVyID0gX2RlZmF1bHRTcGhlcmUkc3BoZXJlLmNlbnRlcjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMykge1xuICAgIHZhciB1ID0gcm5nLnZhbHVlKCk7XG4gICAgdmFyIHYgPSBybmcudmFsdWUoKTtcbiAgICB2YXIgdGhldGEgPSBNYXRoLmFjb3MoMiAqIHYgLSAxKTtcbiAgICB2YXIgcGhpID0gVEFVICogdTtcbiAgICBidWZmZXJbaV0gPSBNYXRoLnNpbih0aGV0YSkgKiBNYXRoLmNvcyhwaGkpICogcmFkaXVzICsgY2VudGVyWzBdO1xuICAgIGJ1ZmZlcltpICsgMV0gPSBNYXRoLnNpbih0aGV0YSkgKiBNYXRoLnNpbihwaGkpICogcmFkaXVzICsgY2VudGVyWzFdO1xuICAgIGJ1ZmZlcltpICsgMl0gPSBNYXRoLmNvcyh0aGV0YSkgKiByYWRpdXMgKyBjZW50ZXJbMl07XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufSAvLyBmcm9tIFwiQW5vdGhlciBNZXRob2RcIiBodHRwczovL2RhdGFnZW5ldGljcy5jb20vYmxvZy9qYW51YXJ5MzIwMjAvaW5kZXguaHRtbFxuXG5mdW5jdGlvbiBpblNwaGVyZShidWZmZXIsIHNwaGVyZSkge1xuICB2YXIgcm5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBkZWZhdWx0R2VuO1xuXG4gIHZhciBfZGVmYXVsdFNwaGVyZSRzcGhlcmUyID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRTcGhlcmUpLCBzcGhlcmUpLFxuICAgICAgcmFkaXVzID0gX2RlZmF1bHRTcGhlcmUkc3BoZXJlMi5yYWRpdXMsXG4gICAgICBjZW50ZXIgPSBfZGVmYXVsdFNwaGVyZSRzcGhlcmUyLmNlbnRlcjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMykge1xuICAgIHZhciB1ID0gTWF0aC5wb3cocm5nLnZhbHVlKCksIDEgLyAzKTtcbiAgICB2YXIgeCA9IHJuZy52YWx1ZSgpICogMiAtIDE7XG4gICAgdmFyIHkgPSBybmcudmFsdWUoKSAqIDIgLSAxO1xuICAgIHZhciB6ID0gcm5nLnZhbHVlKCkgKiAyIC0gMTtcbiAgICB2YXIgbWFnID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gICAgeCA9IHUgKiB4IC8gbWFnO1xuICAgIHkgPSB1ICogeSAvIG1hZztcbiAgICB6ID0gdSAqIHogLyBtYWc7XG4gICAgYnVmZmVyW2ldID0geCAqIHJhZGl1cyArIGNlbnRlclswXTtcbiAgICBidWZmZXJbaSArIDFdID0geSAqIHJhZGl1cyArIGNlbnRlclsxXTtcbiAgICBidWZmZXJbaSArIDJdID0geiAqIHJhZGl1cyArIGNlbnRlclsyXTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59XG4vKioqXG4gKiBbMkRdIENpcmNsZVxuICovXG5cbnZhciBkZWZhdWx0Q2lyY2xlID0ge1xuICByYWRpdXM6IDEsXG4gIGNlbnRlcjogWzAsIDBdXG59OyAvLyByYW5kb20gY2lyY2xlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81MDc0NjQwOVxuXG5mdW5jdGlvbiBpbkNpcmNsZShidWZmZXIsIGNpcmNsZSkge1xuICB2YXIgcm5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBkZWZhdWx0R2VuO1xuXG4gIHZhciBfZGVmYXVsdENpcmNsZSRjaXJjbGUgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdENpcmNsZSksIGNpcmNsZSksXG4gICAgICByYWRpdXMgPSBfZGVmYXVsdENpcmNsZSRjaXJjbGUucmFkaXVzLFxuICAgICAgY2VudGVyID0gX2RlZmF1bHRDaXJjbGUkY2lyY2xlLmNlbnRlcjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciByID0gcmFkaXVzICogTWF0aC5zcXJ0KHJuZy52YWx1ZSgpKTtcbiAgICB2YXIgdGhldGEgPSBybmcudmFsdWUoKSAqIFRBVTtcbiAgICBidWZmZXJbaV0gPSBNYXRoLnNpbih0aGV0YSkgKiByICsgY2VudGVyWzBdO1xuICAgIGJ1ZmZlcltpICsgMV0gPSBNYXRoLmNvcyh0aGV0YSkgKiByICsgY2VudGVyWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIG9uQ2lyY2xlKGJ1ZmZlciwgY2lyY2xlKSB7XG4gIHZhciBybmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGRlZmF1bHRHZW47XG5cbiAgdmFyIF9kZWZhdWx0Q2lyY2xlJGNpcmNsZTIgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdENpcmNsZSksIGNpcmNsZSksXG4gICAgICByYWRpdXMgPSBfZGVmYXVsdENpcmNsZSRjaXJjbGUyLnJhZGl1cyxcbiAgICAgIGNlbnRlciA9IF9kZWZhdWx0Q2lyY2xlJGNpcmNsZTIuY2VudGVyO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHRoZXRhID0gcm5nLnZhbHVlKCkgKiBUQVU7XG4gICAgYnVmZmVyW2ldID0gTWF0aC5zaW4odGhldGEpICogcmFkaXVzICsgY2VudGVyWzBdO1xuICAgIGJ1ZmZlcltpICsgMV0gPSBNYXRoLmNvcyh0aGV0YSkgKiByYWRpdXMgKyBjZW50ZXJbMV07XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufVxuLyoqXG4gKiBbMkRdIFBsYW5lXG4gKi9cblxudmFyIGRlZmF1bHRSZWN0ID0ge1xuICBzaWRlczogMSxcbiAgY2VudGVyOiBbMCwgMF1cbn07XG5mdW5jdGlvbiBpblJlY3QoYnVmZmVyLCByZWN0KSB7XG4gIHZhciBybmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGRlZmF1bHRHZW47XG5cbiAgdmFyIF9kZWZhdWx0UmVjdCRyZWN0ID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRSZWN0KSwgcmVjdCksXG4gICAgICBzaWRlcyA9IF9kZWZhdWx0UmVjdCRyZWN0LnNpZGVzLFxuICAgICAgY2VudGVyID0gX2RlZmF1bHRSZWN0JHJlY3QuY2VudGVyO1xuXG4gIHZhciBzaWRlWCA9IHR5cGVvZiBzaWRlcyA9PT0gXCJudW1iZXJcIiA/IHNpZGVzIDogc2lkZXNbMF07XG4gIHZhciBzaWRlWSA9IHR5cGVvZiBzaWRlcyA9PT0gXCJudW1iZXJcIiA/IHNpZGVzIDogc2lkZXNbMV07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBidWZmZXJbaV0gPSAocm5nLnZhbHVlKCkgLSAwLjUpICogc2lkZVggKyBjZW50ZXJbMF07XG4gICAgYnVmZmVyW2kgKyAxXSA9IChybmcudmFsdWUoKSAtIDAuNSkgKiBzaWRlWSArIGNlbnRlclsxXTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBvblJlY3QoYnVmZmVyLCByZWN0KSB7XG4gIHJldHVybiBidWZmZXI7XG59XG4vKioqXG4gKiBbM0RdIEJveFxuICovXG5cbmZ1bmN0aW9uIGluQm94KGJ1ZmZlciwgYm94KSB7XG4gIHZhciBybmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGRlZmF1bHRHZW47XG5cbiAgdmFyIF9kZWZhdWx0Qm94JGJveCA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0Qm94KSwgYm94KSxcbiAgICAgIHNpZGVzID0gX2RlZmF1bHRCb3gkYm94LnNpZGVzLFxuICAgICAgY2VudGVyID0gX2RlZmF1bHRCb3gkYm94LmNlbnRlcjtcblxuICB2YXIgc2lkZVggPSB0eXBlb2Ygc2lkZXMgPT09IFwibnVtYmVyXCIgPyBzaWRlcyA6IHNpZGVzWzBdO1xuICB2YXIgc2lkZVkgPSB0eXBlb2Ygc2lkZXMgPT09IFwibnVtYmVyXCIgPyBzaWRlcyA6IHNpZGVzWzFdO1xuICB2YXIgc2lkZVogPSB0eXBlb2Ygc2lkZXMgPT09IFwibnVtYmVyXCIgPyBzaWRlcyA6IHNpZGVzWzJdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgYnVmZmVyW2ldID0gKHJuZy52YWx1ZSgpIC0gMC41KSAqIHNpZGVYICsgY2VudGVyWzBdO1xuICAgIGJ1ZmZlcltpICsgMV0gPSAocm5nLnZhbHVlKCkgLSAwLjUpICogc2lkZVkgKyBjZW50ZXJbMV07XG4gICAgYnVmZmVyW2kgKyAyXSA9IChybmcudmFsdWUoKSAtIDAuNSkgKiBzaWRlWiArIGNlbnRlclsyXTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59XG52YXIgZGVmYXVsdEJveCA9IHtcbiAgc2lkZXM6IDEsXG4gIGNlbnRlcjogWzAsIDAsIDBdXG59O1xuZnVuY3Rpb24gb25Cb3goYnVmZmVyLCBib3gpIHtcbiAgdmFyIHJuZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZGVmYXVsdEdlbjtcblxuICB2YXIgX2RlZmF1bHRCb3gkYm94MiA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0Qm94KSwgYm94KSxcbiAgICAgIHNpZGVzID0gX2RlZmF1bHRCb3gkYm94Mi5zaWRlcyxcbiAgICAgIGNlbnRlciA9IF9kZWZhdWx0Qm94JGJveDIuY2VudGVyO1xuXG4gIHZhciBzaWRlWCA9IHR5cGVvZiBzaWRlcyA9PT0gXCJudW1iZXJcIiA/IHNpZGVzIDogc2lkZXNbMF07XG4gIHZhciBzaWRlWSA9IHR5cGVvZiBzaWRlcyA9PT0gXCJudW1iZXJcIiA/IHNpZGVzIDogc2lkZXNbMV07XG4gIHZhciBzaWRlWiA9IHR5cGVvZiBzaWRlcyA9PT0gXCJudW1iZXJcIiA/IHNpZGVzIDogc2lkZXNbMl07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBidWZmZXJbaV0gPSAocm5nLnZhbHVlKCkgLSAwLjUpICogc2lkZVggKyBjZW50ZXJbMF07XG4gICAgYnVmZmVyW2kgKyAxXSA9IChybmcudmFsdWUoKSAtIDAuNSkgKiBzaWRlWSArIGNlbnRlclsxXTtcbiAgICBidWZmZXJbaSArIDJdID0gKHJuZy52YWx1ZSgpIC0gMC41KSAqIHNpZGVaICsgY2VudGVyWzJdO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxudmFyIGluZGV4ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEZsYXNoR2VuOiBGbGFzaEdlbixcbiAgR2VuZXJhdG9yOiBHZW5lcmF0b3IsXG4gIG9uU3BoZXJlOiBvblNwaGVyZSxcbiAgaW5TcGhlcmU6IGluU3BoZXJlLFxuICBpbkNpcmNsZTogaW5DaXJjbGUsXG4gIG9uQ2lyY2xlOiBvbkNpcmNsZSxcbiAgaW5SZWN0OiBpblJlY3QsXG4gIG9uUmVjdDogb25SZWN0LFxuICBpbkJveDogaW5Cb3gsXG4gIG9uQm94OiBvbkJveCxcbiAgbm9pc2U6IG5vaXNlXG59KTtcblxuZXhwb3J0IHsgRmxhc2hHZW4gYXMgRiwgR2VuZXJhdG9yIGFzIEcsIGluU3BoZXJlIGFzIGEsIGluQ2lyY2xlIGFzIGIsIG9uQ2lyY2xlIGFzIGMsIGluUmVjdCBhcyBkLCBvblJlY3QgYXMgZSwgaW5Cb3ggYXMgZiwgb25Cb3ggYXMgZywgaW5kZXggYXMgaSwgbm9pc2UgYXMgbiwgb25TcGhlcmUgYXMgbyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/index-0332b2ed.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/index-26fb8954.cjs.dev.js":
/*!***********************************************************!*\
  !*** ./node_modules/maath/dist/index-26fb8954.cjs.dev.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar objectSpread2 = __webpack_require__(/*! ./objectSpread2-32cd2c34.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/objectSpread2-32cd2c34.cjs.dev.js\");\nvar classCallCheck = __webpack_require__(/*! ./classCallCheck-eaf0efc7.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/classCallCheck-eaf0efc7.cjs.dev.js\");\nvar misc_dist_maathMisc = __webpack_require__(/*! ./misc-fce4d494.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/misc-fce4d494.cjs.dev.js\");\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/*\n * A speed-improved perlin and simplex noise algorithms for 2D.\n *\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n * Converted to Javascript by Joseph Gentle.\n *\n * Version 2012-03-09\n *\n * This code was placed in the public domain by its original author,\n * Stefan Gustavson. You may use it as you see fit, but\n * attribution is appreciated.\n *\n */\n\nvar Grad = function Grad(x, y, z) {\n  var _this = this;\n\n  classCallCheck._classCallCheck(this, Grad);\n\n  objectSpread2._defineProperty(this, \"dot2\", function (x, y) {\n    return _this.x * x + _this.y * y;\n  });\n\n  objectSpread2._defineProperty(this, \"dot3\", function (x, y, z) {\n    return _this.x * x + _this.y * y + _this.z * z;\n  });\n\n  this.x = x;\n  this.y = y;\n  this.z = z;\n};\n\nvar grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\nvar p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]; // To remove the need for index wrapping, double the permutation table length\n\nvar perm = new Array(512);\nvar gradP = new Array(512); // This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\n\nvar seed = function seed(_seed) {\n  if (_seed > 0 && _seed < 1) {\n    // Scale the seed out\n    _seed *= 65536;\n  }\n\n  _seed = Math.floor(_seed);\n\n  if (_seed < 256) {\n    _seed |= _seed << 8;\n  }\n\n  for (var i = 0; i < 256; i++) {\n    var v;\n\n    if (i & 1) {\n      v = p[i] ^ _seed & 255;\n    } else {\n      v = p[i] ^ _seed >> 8 & 255;\n    }\n\n    perm[i] = perm[i + 256] = v;\n    gradP[i] = gradP[i + 256] = grad3[v % 12];\n  }\n};\nseed(0);\n/*\n  for(var i=0; i<256; i++) {\n    perm[i] = perm[i + 256] = p[i];\n    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\n  }*/\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\n\nvar F2 = 0.5 * (Math.sqrt(3) - 1);\nvar G2 = (3 - Math.sqrt(3)) / 6;\nvar F3 = 1 / 3;\nvar G3 = 1 / 6; // 2D simplex noise\n\nvar simplex2 = function simplex2(xin, yin) {\n  var n0, n1, n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n\n  var s = (xin + yin) * F2; // Hairy factor for 2D\n\n  var i = Math.floor(xin + s);\n  var j = Math.floor(yin + s);\n  var t = (i + j) * G2;\n  var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\n  var y0 = yin - j + t; // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n\n  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\n  if (x0 > y0) {\n    // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n    i1 = 1;\n    j1 = 0;\n  } else {\n    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n    i1 = 0;\n    j1 = 1;\n  } // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n\n\n  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\n  var y1 = y0 - j1 + G2;\n  var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n\n  var y2 = y0 - 1 + 2 * G2; // Work out the hashed gradient indices of the three simplex corners\n\n  i &= 255;\n  j &= 255;\n  var gi0 = gradP[i + perm[j]];\n  var gi1 = gradP[i + i1 + perm[j + j1]];\n  var gi2 = gradP[i + 1 + perm[j + 1]]; // Calculate the contribution from the three corners\n\n  var t0 = 0.5 - x0 * x0 - y0 * y0;\n\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient\n  }\n\n  var t1 = 0.5 - x1 * x1 - y1 * y1;\n\n  if (t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot2(x1, y1);\n  }\n\n  var t2 = 0.5 - x2 * x2 - y2 * y2;\n\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot2(x2, y2);\n  } // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n\n\n  return 70 * (n0 + n1 + n2);\n}; // 3D simplex noise\n\nvar simplex3 = function simplex3(xin, yin, zin) {\n  var n0, n1, n2, n3; // Noise contributions from the four corners\n  // Skew the input space to determine which simplex cell we're in\n\n  var s = (xin + yin + zin) * F3; // Hairy factor for 2D\n\n  var i = Math.floor(xin + s);\n  var j = Math.floor(yin + s);\n  var k = Math.floor(zin + s);\n  var t = (i + j + k) * G3;\n  var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\n  var y0 = yin - j + t;\n  var z0 = zin - k + t; // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n  // Determine which simplex we are in.\n\n  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\n  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\n  if (x0 >= y0) {\n    if (y0 >= z0) {\n      i1 = 1;\n      j1 = 0;\n      k1 = 0;\n      i2 = 1;\n      j2 = 1;\n      k2 = 0;\n    } else if (x0 >= z0) {\n      i1 = 1;\n      j1 = 0;\n      k1 = 0;\n      i2 = 1;\n      j2 = 0;\n      k2 = 1;\n    } else {\n      i1 = 0;\n      j1 = 0;\n      k1 = 1;\n      i2 = 1;\n      j2 = 0;\n      k2 = 1;\n    }\n  } else {\n    if (y0 < z0) {\n      i1 = 0;\n      j1 = 0;\n      k1 = 1;\n      i2 = 0;\n      j2 = 1;\n      k2 = 1;\n    } else if (x0 < z0) {\n      i1 = 0;\n      j1 = 1;\n      k1 = 0;\n      i2 = 0;\n      j2 = 1;\n      k2 = 1;\n    } else {\n      i1 = 0;\n      j1 = 1;\n      k1 = 0;\n      i2 = 1;\n      j2 = 1;\n      k2 = 0;\n    }\n  } // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n  // c = 1/6.\n\n\n  var x1 = x0 - i1 + G3; // Offsets for second corner\n\n  var y1 = y0 - j1 + G3;\n  var z1 = z0 - k1 + G3;\n  var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n\n  var y2 = y0 - j2 + 2 * G3;\n  var z2 = z0 - k2 + 2 * G3;\n  var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n\n  var y3 = y0 - 1 + 3 * G3;\n  var z3 = z0 - 1 + 3 * G3; // Work out the hashed gradient indices of the four simplex corners\n\n  i &= 255;\n  j &= 255;\n  k &= 255;\n  var gi0 = gradP[i + perm[j + perm[k]]];\n  var gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];\n  var gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];\n  var gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]]; // Calculate the contribution from the four corners\n\n  var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot3(x0, y0, z0); // (x,y) of grad3 used for 2D gradient\n  }\n\n  var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n\n  if (t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n  }\n\n  var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n  }\n\n  var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n\n  if (t3 < 0) {\n    n3 = 0;\n  } else {\n    t3 *= t3;\n    n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n  } // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n\n\n  return 32 * (n0 + n1 + n2 + n3);\n}; // ##### Perlin noise stuff\n// 2D Perlin Noise\n\nvar perlin2 = function perlin2(x, y) {\n  // Find unit grid cell containing point\n  var X = Math.floor(x),\n      Y = Math.floor(y); // Get relative xy coordinates of point within that cell\n\n  x = x - X;\n  y = y - Y; // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n\n  X = X & 255;\n  Y = Y & 255; // Calculate noise contributions from each of the four corners\n\n  var n00 = gradP[X + perm[Y]].dot2(x, y);\n  var n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);\n  var n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);\n  var n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1); // Compute the fade curve value for x\n\n  var u = misc_dist_maathMisc.fade(x); // Interpolate the four results\n\n  return misc_dist_maathMisc.lerp(misc_dist_maathMisc.lerp(n00, n10, u), misc_dist_maathMisc.lerp(n01, n11, u), misc_dist_maathMisc.fade(y));\n}; // 3D Perlin Noise\n\nvar perlin3 = function perlin3(x, y, z) {\n  // Find unit grid cell containing point\n  var X = Math.floor(x),\n      Y = Math.floor(y),\n      Z = Math.floor(z); // Get relative xyz coordinates of point within that cell\n\n  x = x - X;\n  y = y - Y;\n  z = z - Z; // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n\n  X = X & 255;\n  Y = Y & 255;\n  Z = Z & 255; // Calculate noise contributions from each of the eight corners\n\n  var n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);\n  var n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);\n  var n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);\n  var n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);\n  var n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);\n  var n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);\n  var n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);\n  var n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(x - 1, y - 1, z - 1); // Compute the fade curve value for x, y, z\n\n  var u = misc_dist_maathMisc.fade(x);\n  var v = misc_dist_maathMisc.fade(y);\n  var w = misc_dist_maathMisc.fade(z); // Interpolate\n\n  return misc_dist_maathMisc.lerp(misc_dist_maathMisc.lerp(misc_dist_maathMisc.lerp(n000, n100, u), misc_dist_maathMisc.lerp(n001, n101, u), w), misc_dist_maathMisc.lerp(misc_dist_maathMisc.lerp(n010, n110, u), misc_dist_maathMisc.lerp(n011, n111, u), w), v);\n};\n\nvar noise = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  seed: seed,\n  simplex2: simplex2,\n  simplex3: simplex3,\n  perlin2: perlin2,\n  perlin3: perlin3\n});\n\nvar TAU = Math.PI * 2;\nvar FlashGen = /*#__PURE__*/function () {\n  function FlashGen(props) {\n    classCallCheck._classCallCheck(this, FlashGen);\n\n    objectSpread2._defineProperty(this, \"nextBurstTime\", 0);\n\n    objectSpread2._defineProperty(this, \"nextFlashEndTime\", 0);\n\n    objectSpread2._defineProperty(this, \"flashesDone\", 0);\n\n    objectSpread2._defineProperty(this, \"isFlashing\", false);\n\n    objectSpread2._defineProperty(this, \"currentCount\", 0);\n\n    objectSpread2._defineProperty(this, \"flashIntensity\", 0);\n\n    objectSpread2._defineProperty(this, \"isDecaying\", false);\n\n    objectSpread2._defineProperty(this, \"autoBurst\", true);\n\n    objectSpread2._defineProperty(this, \"decaySpeed\", 40);\n\n    objectSpread2._defineProperty(this, \"minInterval\", 5000);\n\n    objectSpread2._defineProperty(this, \"maxInterval\", 10000);\n\n    objectSpread2._defineProperty(this, \"minDuration\", 50);\n\n    objectSpread2._defineProperty(this, \"maxDuration\", 300);\n\n    objectSpread2._defineProperty(this, \"count\", 5);\n\n    Object.assign(this, props);\n  }\n\n  _createClass(FlashGen, [{\n    key: \"scheduleNextBurst\",\n    value: function scheduleNextBurst(currentTime) {\n      var burstInterval = Math.random() * (this.maxInterval - this.minInterval) + this.minInterval;\n      this.nextBurstTime = currentTime + burstInterval / 1000;\n      this.flashesDone = 0;\n      this.isFlashing = false;\n    }\n  }, {\n    key: \"burst\",\n    value: function burst() {\n      this.nextBurstTime = 0;\n      this.flashesDone = 0;\n      this.isFlashing = false;\n    }\n  }, {\n    key: \"update\",\n    value: function update(currentTime, delta) {\n      if (currentTime > this.nextBurstTime && this.currentCount === 0) {\n        this.currentCount = Math.floor(Math.random() * this.count) + 1;\n      }\n\n      if (this.flashesDone < this.currentCount && currentTime > this.nextBurstTime) {\n        if (!this.isFlashing) {\n          this.isFlashing = true;\n          this.flashIntensity = 1;\n          var flashDuration = Math.random() * (this.maxDuration - this.minDuration) + this.minDuration;\n          this.nextFlashEndTime = currentTime + flashDuration / 1000;\n        } else if (this.isFlashing && currentTime > this.nextFlashEndTime) {\n          this.isFlashing = false;\n          this.isDecaying = true;\n          this.flashesDone++;\n\n          if (this.flashesDone >= this.currentCount) {\n            this.currentCount = 0;\n            if (this.autoBurst) this.scheduleNextBurst(currentTime);\n          }\n        }\n      }\n\n      if (this.isDecaying) {\n        this.flashIntensity -= delta * this.decaySpeed;\n        this.flashIntensity = Math.max(0, Math.min(1, this.flashIntensity));\n\n        if (this.flashIntensity <= 0) {\n          this.isDecaying = false;\n          this.flashIntensity = 0;\n        }\n      }\n\n      return this.flashIntensity;\n    }\n  }]);\n\n  return FlashGen;\n}(); // Credits @kchapelier https://github.com/kchapelier/wavefunctioncollapse/blob/master/example/lcg.js#L22-L30\n\nfunction normalizeSeed(seed) {\n  if (typeof seed === \"number\") {\n    seed = Math.abs(seed);\n  } else if (typeof seed === \"string\") {\n    var string = seed;\n    seed = 0;\n\n    for (var i = 0; i < string.length; i++) {\n      seed = (seed + (i + 1) * (string.charCodeAt(i) % 96)) % 2147483647;\n    }\n  }\n\n  if (seed === 0) {\n    seed = 311;\n  }\n\n  return seed;\n}\n\nfunction lcgRandom(seed) {\n  var state = normalizeSeed(seed);\n  return function () {\n    var result = state * 48271 % 2147483647;\n    state = result;\n    return result / 2147483647;\n  };\n}\n\nvar Generator = function Generator(_seed) {\n  var _this = this;\n\n  classCallCheck._classCallCheck(this, Generator);\n\n  objectSpread2._defineProperty(this, \"seed\", 0);\n\n  objectSpread2._defineProperty(this, \"init\", function (seed) {\n    _this.seed = seed;\n    _this.value = lcgRandom(seed);\n  });\n\n  objectSpread2._defineProperty(this, \"value\", lcgRandom(this.seed));\n\n  this.init(_seed);\n};\nvar defaultGen = new Generator(Math.random());\n/***\n * [3D] Sphere\n */\n\nvar defaultSphere = {\n  radius: 1,\n  center: [0, 0, 0]\n}; // random on surface of sphere\n// - https://twitter.com/fermatslibrary/status/1430932503578226688\n// - https://mathworld.wolfram.com/SpherePointPicking.html\n\nfunction onSphere(buffer, sphere) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultSphere$sphere = objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, defaultSphere), sphere),\n      radius = _defaultSphere$sphere.radius,\n      center = _defaultSphere$sphere.center;\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    var u = rng.value();\n    var v = rng.value();\n    var theta = Math.acos(2 * v - 1);\n    var phi = TAU * u;\n    buffer[i] = Math.sin(theta) * Math.cos(phi) * radius + center[0];\n    buffer[i + 1] = Math.sin(theta) * Math.sin(phi) * radius + center[1];\n    buffer[i + 2] = Math.cos(theta) * radius + center[2];\n  }\n\n  return buffer;\n} // from \"Another Method\" https://datagenetics.com/blog/january32020/index.html\n\nfunction inSphere(buffer, sphere) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultSphere$sphere2 = objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, defaultSphere), sphere),\n      radius = _defaultSphere$sphere2.radius,\n      center = _defaultSphere$sphere2.center;\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    var u = Math.pow(rng.value(), 1 / 3);\n    var x = rng.value() * 2 - 1;\n    var y = rng.value() * 2 - 1;\n    var z = rng.value() * 2 - 1;\n    var mag = Math.sqrt(x * x + y * y + z * z);\n    x = u * x / mag;\n    y = u * y / mag;\n    z = u * z / mag;\n    buffer[i] = x * radius + center[0];\n    buffer[i + 1] = y * radius + center[1];\n    buffer[i + 2] = z * radius + center[2];\n  }\n\n  return buffer;\n}\n/***\n * [2D] Circle\n */\n\nvar defaultCircle = {\n  radius: 1,\n  center: [0, 0]\n}; // random circle https://stackoverflow.com/a/50746409\n\nfunction inCircle(buffer, circle) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultCircle$circle = objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, defaultCircle), circle),\n      radius = _defaultCircle$circle.radius,\n      center = _defaultCircle$circle.center;\n\n  for (var i = 0; i < buffer.length; i += 2) {\n    var r = radius * Math.sqrt(rng.value());\n    var theta = rng.value() * TAU;\n    buffer[i] = Math.sin(theta) * r + center[0];\n    buffer[i + 1] = Math.cos(theta) * r + center[1];\n  }\n\n  return buffer;\n}\nfunction onCircle(buffer, circle) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultCircle$circle2 = objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, defaultCircle), circle),\n      radius = _defaultCircle$circle2.radius,\n      center = _defaultCircle$circle2.center;\n\n  for (var i = 0; i < buffer.length; i += 2) {\n    var theta = rng.value() * TAU;\n    buffer[i] = Math.sin(theta) * radius + center[0];\n    buffer[i + 1] = Math.cos(theta) * radius + center[1];\n  }\n\n  return buffer;\n}\n/**\n * [2D] Plane\n */\n\nvar defaultRect = {\n  sides: 1,\n  center: [0, 0]\n};\nfunction inRect(buffer, rect) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultRect$rect = objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, defaultRect), rect),\n      sides = _defaultRect$rect.sides,\n      center = _defaultRect$rect.center;\n\n  var sideX = typeof sides === \"number\" ? sides : sides[0];\n  var sideY = typeof sides === \"number\" ? sides : sides[1];\n\n  for (var i = 0; i < buffer.length; i += 2) {\n    buffer[i] = (rng.value() - 0.5) * sideX + center[0];\n    buffer[i + 1] = (rng.value() - 0.5) * sideY + center[1];\n  }\n\n  return buffer;\n}\nfunction onRect(buffer, rect) {\n  return buffer;\n}\n/***\n * [3D] Box\n */\n\nfunction inBox(buffer, box) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultBox$box = objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, defaultBox), box),\n      sides = _defaultBox$box.sides,\n      center = _defaultBox$box.center;\n\n  var sideX = typeof sides === \"number\" ? sides : sides[0];\n  var sideY = typeof sides === \"number\" ? sides : sides[1];\n  var sideZ = typeof sides === \"number\" ? sides : sides[2];\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    buffer[i] = (rng.value() - 0.5) * sideX + center[0];\n    buffer[i + 1] = (rng.value() - 0.5) * sideY + center[1];\n    buffer[i + 2] = (rng.value() - 0.5) * sideZ + center[2];\n  }\n\n  return buffer;\n}\nvar defaultBox = {\n  sides: 1,\n  center: [0, 0, 0]\n};\nfunction onBox(buffer, box) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultBox$box2 = objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, defaultBox), box),\n      sides = _defaultBox$box2.sides,\n      center = _defaultBox$box2.center;\n\n  var sideX = typeof sides === \"number\" ? sides : sides[0];\n  var sideY = typeof sides === \"number\" ? sides : sides[1];\n  var sideZ = typeof sides === \"number\" ? sides : sides[2];\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    buffer[i] = (rng.value() - 0.5) * sideX + center[0];\n    buffer[i + 1] = (rng.value() - 0.5) * sideY + center[1];\n    buffer[i + 2] = (rng.value() - 0.5) * sideZ + center[2];\n  }\n\n  return buffer;\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  FlashGen: FlashGen,\n  Generator: Generator,\n  onSphere: onSphere,\n  inSphere: inSphere,\n  inCircle: inCircle,\n  onCircle: onCircle,\n  inRect: inRect,\n  onRect: onRect,\n  inBox: inBox,\n  onBox: onBox,\n  noise: noise\n});\n\nexports.FlashGen = FlashGen;\nexports.Generator = Generator;\nexports.inBox = inBox;\nexports.inCircle = inCircle;\nexports.inRect = inRect;\nexports.inSphere = inSphere;\nexports.index = index;\nexports.noise = noise;\nexports.onBox = onBox;\nexports.onCircle = onCircle;\nexports.onRect = onRect;\nexports.onSphere = onSphere;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9pbmRleC0yNmZiODk1NC5janMuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLDhHQUFxQztBQUNqRSxxQkFBcUIsbUJBQU8sQ0FBQyxnSEFBc0M7QUFDbkUsMEJBQTBCLG1CQUFPLENBQUMsNEZBQTRCOztBQUU5RDtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRwQ0FBNHBDOztBQUU1cEM7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCLHdCQUF3QjtBQUN4Qjs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQSx5QkFBeUI7O0FBRXpCO0FBQ0EsNEJBQTRCOztBQUU1Qiw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBLGtCQUFrQjs7QUFFbEIsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRCx1Q0FBdUM7O0FBRXZDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7O0FBRWpGO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwRkFBMEY7QUFDMUY7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsMkZBQTJGO0FBQzNGO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsMEZBQTBGO0FBQzFGO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJGQUEyRjtBQUMzRjtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0ZBQXNGO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0ZBQW9GO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxRkFBcUY7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYWNlcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvaW5kZXgtMjZmYjg5NTQuY2pzLmRldi5qcz85ZTNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIG9iamVjdFNwcmVhZDIgPSByZXF1aXJlKCcuL29iamVjdFNwcmVhZDItMzJjZDJjMzQuY2pzLmRldi5qcycpO1xudmFyIGNsYXNzQ2FsbENoZWNrID0gcmVxdWlyZSgnLi9jbGFzc0NhbGxDaGVjay1lYWYwZWZjNy5janMuZGV2LmpzJyk7XG52YXIgbWlzY19kaXN0X21hYXRoTWlzYyA9IHJlcXVpcmUoJy4vbWlzYy1mY2U0ZDQ5NC5janMuZGV2LmpzJyk7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuLypcbiAqIEEgc3BlZWQtaW1wcm92ZWQgcGVybGluIGFuZCBzaW1wbGV4IG5vaXNlIGFsZ29yaXRobXMgZm9yIDJELlxuICpcbiAqIEJhc2VkIG9uIGV4YW1wbGUgY29kZSBieSBTdGVmYW4gR3VzdGF2c29uIChzdGVndUBpdG4ubGl1LnNlKS5cbiAqIE9wdGltaXNhdGlvbnMgYnkgUGV0ZXIgRWFzdG1hbiAocGVhc3RtYW5AZHJpenpsZS5zdGFuZm9yZC5lZHUpLlxuICogQmV0dGVyIHJhbmsgb3JkZXJpbmcgbWV0aG9kIGJ5IFN0ZWZhbiBHdXN0YXZzb24gaW4gMjAxMi5cbiAqIENvbnZlcnRlZCB0byBKYXZhc2NyaXB0IGJ5IEpvc2VwaCBHZW50bGUuXG4gKlxuICogVmVyc2lvbiAyMDEyLTAzLTA5XG4gKlxuICogVGhpcyBjb2RlIHdhcyBwbGFjZWQgaW4gdGhlIHB1YmxpYyBkb21haW4gYnkgaXRzIG9yaWdpbmFsIGF1dGhvcixcbiAqIFN0ZWZhbiBHdXN0YXZzb24uIFlvdSBtYXkgdXNlIGl0IGFzIHlvdSBzZWUgZml0LCBidXRcbiAqIGF0dHJpYnV0aW9uIGlzIGFwcHJlY2lhdGVkLlxuICpcbiAqL1xuXG52YXIgR3JhZCA9IGZ1bmN0aW9uIEdyYWQoeCwgeSwgeikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGNsYXNzQ2FsbENoZWNrLl9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmFkKTtcblxuICBvYmplY3RTcHJlYWQyLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvdDJcIiwgZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gX3RoaXMueCAqIHggKyBfdGhpcy55ICogeTtcbiAgfSk7XG5cbiAgb2JqZWN0U3ByZWFkMi5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb3QzXCIsIGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgcmV0dXJuIF90aGlzLnggKiB4ICsgX3RoaXMueSAqIHkgKyBfdGhpcy56ICogejtcbiAgfSk7XG5cbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbiAgdGhpcy56ID0gejtcbn07XG5cbnZhciBncmFkMyA9IFtuZXcgR3JhZCgxLCAxLCAwKSwgbmV3IEdyYWQoLTEsIDEsIDApLCBuZXcgR3JhZCgxLCAtMSwgMCksIG5ldyBHcmFkKC0xLCAtMSwgMCksIG5ldyBHcmFkKDEsIDAsIDEpLCBuZXcgR3JhZCgtMSwgMCwgMSksIG5ldyBHcmFkKDEsIDAsIC0xKSwgbmV3IEdyYWQoLTEsIDAsIC0xKSwgbmV3IEdyYWQoMCwgMSwgMSksIG5ldyBHcmFkKDAsIC0xLCAxKSwgbmV3IEdyYWQoMCwgMSwgLTEpLCBuZXcgR3JhZCgwLCAtMSwgLTEpXTtcbnZhciBwID0gWzE1MSwgMTYwLCAxMzcsIDkxLCA5MCwgMTUsIDEzMSwgMTMsIDIwMSwgOTUsIDk2LCA1MywgMTk0LCAyMzMsIDcsIDIyNSwgMTQwLCAzNiwgMTAzLCAzMCwgNjksIDE0MiwgOCwgOTksIDM3LCAyNDAsIDIxLCAxMCwgMjMsIDE5MCwgNiwgMTQ4LCAyNDcsIDEyMCwgMjM0LCA3NSwgMCwgMjYsIDE5NywgNjIsIDk0LCAyNTIsIDIxOSwgMjAzLCAxMTcsIDM1LCAxMSwgMzIsIDU3LCAxNzcsIDMzLCA4OCwgMjM3LCAxNDksIDU2LCA4NywgMTc0LCAyMCwgMTI1LCAxMzYsIDE3MSwgMTY4LCA2OCwgMTc1LCA3NCwgMTY1LCA3MSwgMTM0LCAxMzksIDQ4LCAyNywgMTY2LCA3NywgMTQ2LCAxNTgsIDIzMSwgODMsIDExMSwgMjI5LCAxMjIsIDYwLCAyMTEsIDEzMywgMjMwLCAyMjAsIDEwNSwgOTIsIDQxLCA1NSwgNDYsIDI0NSwgNDAsIDI0NCwgMTAyLCAxNDMsIDU0LCA2NSwgMjUsIDYzLCAxNjEsIDEsIDIxNiwgODAsIDczLCAyMDksIDc2LCAxMzIsIDE4NywgMjA4LCA4OSwgMTgsIDE2OSwgMjAwLCAxOTYsIDEzNSwgMTMwLCAxMTYsIDE4OCwgMTU5LCA4NiwgMTY0LCAxMDAsIDEwOSwgMTk4LCAxNzMsIDE4NiwgMywgNjQsIDUyLCAyMTcsIDIyNiwgMjUwLCAxMjQsIDEyMywgNSwgMjAyLCAzOCwgMTQ3LCAxMTgsIDEyNiwgMjU1LCA4MiwgODUsIDIxMiwgMjA3LCAyMDYsIDU5LCAyMjcsIDQ3LCAxNiwgNTgsIDE3LCAxODIsIDE4OSwgMjgsIDQyLCAyMjMsIDE4MywgMTcwLCAyMTMsIDExOSwgMjQ4LCAxNTIsIDIsIDQ0LCAxNTQsIDE2MywgNzAsIDIyMSwgMTUzLCAxMDEsIDE1NSwgMTY3LCA0MywgMTcyLCA5LCAxMjksIDIyLCAzOSwgMjUzLCAxOSwgOTgsIDEwOCwgMTEwLCA3OSwgMTEzLCAyMjQsIDIzMiwgMTc4LCAxODUsIDExMiwgMTA0LCAyMTgsIDI0NiwgOTcsIDIyOCwgMjUxLCAzNCwgMjQyLCAxOTMsIDIzOCwgMjEwLCAxNDQsIDEyLCAxOTEsIDE3OSwgMTYyLCAyNDEsIDgxLCA1MSwgMTQ1LCAyMzUsIDI0OSwgMTQsIDIzOSwgMTA3LCA0OSwgMTkyLCAyMTQsIDMxLCAxODEsIDE5OSwgMTA2LCAxNTcsIDE4NCwgODQsIDIwNCwgMTc2LCAxMTUsIDEyMSwgNTAsIDQ1LCAxMjcsIDQsIDE1MCwgMjU0LCAxMzgsIDIzNiwgMjA1LCA5MywgMjIyLCAxMTQsIDY3LCAyOSwgMjQsIDcyLCAyNDMsIDE0MSwgMTI4LCAxOTUsIDc4LCA2NiwgMjE1LCA2MSwgMTU2LCAxODBdOyAvLyBUbyByZW1vdmUgdGhlIG5lZWQgZm9yIGluZGV4IHdyYXBwaW5nLCBkb3VibGUgdGhlIHBlcm11dGF0aW9uIHRhYmxlIGxlbmd0aFxuXG52YXIgcGVybSA9IG5ldyBBcnJheSg1MTIpO1xudmFyIGdyYWRQID0gbmV3IEFycmF5KDUxMik7IC8vIFRoaXMgaXNuJ3QgYSB2ZXJ5IGdvb2Qgc2VlZGluZyBmdW5jdGlvbiwgYnV0IGl0IHdvcmtzIG9rLiBJdCBzdXBwb3J0cyAyXjE2XG4vLyBkaWZmZXJlbnQgc2VlZCB2YWx1ZXMuIFdyaXRlIHNvbWV0aGluZyBiZXR0ZXIgaWYgeW91IG5lZWQgbW9yZSBzZWVkcy5cblxudmFyIHNlZWQgPSBmdW5jdGlvbiBzZWVkKF9zZWVkKSB7XG4gIGlmIChfc2VlZCA+IDAgJiYgX3NlZWQgPCAxKSB7XG4gICAgLy8gU2NhbGUgdGhlIHNlZWQgb3V0XG4gICAgX3NlZWQgKj0gNjU1MzY7XG4gIH1cblxuICBfc2VlZCA9IE1hdGguZmxvb3IoX3NlZWQpO1xuXG4gIGlmIChfc2VlZCA8IDI1Nikge1xuICAgIF9zZWVkIHw9IF9zZWVkIDw8IDg7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgdmFyIHY7XG5cbiAgICBpZiAoaSAmIDEpIHtcbiAgICAgIHYgPSBwW2ldIF4gX3NlZWQgJiAyNTU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHYgPSBwW2ldIF4gX3NlZWQgPj4gOCAmIDI1NTtcbiAgICB9XG5cbiAgICBwZXJtW2ldID0gcGVybVtpICsgMjU2XSA9IHY7XG4gICAgZ3JhZFBbaV0gPSBncmFkUFtpICsgMjU2XSA9IGdyYWQzW3YgJSAxMl07XG4gIH1cbn07XG5zZWVkKDApO1xuLypcbiAgZm9yKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgICBwZXJtW2ldID0gcGVybVtpICsgMjU2XSA9IHBbaV07XG4gICAgZ3JhZFBbaV0gPSBncmFkUFtpICsgMjU2XSA9IGdyYWQzW3Blcm1baV0gJSAxMl07XG4gIH0qL1xuLy8gU2tld2luZyBhbmQgdW5za2V3aW5nIGZhY3RvcnMgZm9yIDIsIDMsIGFuZCA0IGRpbWVuc2lvbnNcblxudmFyIEYyID0gMC41ICogKE1hdGguc3FydCgzKSAtIDEpO1xudmFyIEcyID0gKDMgLSBNYXRoLnNxcnQoMykpIC8gNjtcbnZhciBGMyA9IDEgLyAzO1xudmFyIEczID0gMSAvIDY7IC8vIDJEIHNpbXBsZXggbm9pc2VcblxudmFyIHNpbXBsZXgyID0gZnVuY3Rpb24gc2ltcGxleDIoeGluLCB5aW4pIHtcbiAgdmFyIG4wLCBuMSwgbjI7IC8vIE5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgdGhyZWUgY29ybmVyc1xuICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG5cbiAgdmFyIHMgPSAoeGluICsgeWluKSAqIEYyOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXG5cbiAgdmFyIGkgPSBNYXRoLmZsb29yKHhpbiArIHMpO1xuICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XG4gIHZhciB0ID0gKGkgKyBqKSAqIEcyO1xuICB2YXIgeDAgPSB4aW4gLSBpICsgdDsgLy8gVGhlIHgseSBkaXN0YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW4sIHVuc2tld2VkLlxuXG4gIHZhciB5MCA9IHlpbiAtIGogKyB0OyAvLyBGb3IgdGhlIDJEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlLlxuICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXG5cbiAgdmFyIGkxLCBqMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIChtaWRkbGUpIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGopIGNvb3Jkc1xuXG4gIGlmICh4MCA+IHkwKSB7XG4gICAgLy8gbG93ZXIgdHJpYW5nbGUsIFhZIG9yZGVyOiAoMCwwKS0+KDEsMCktPigxLDEpXG4gICAgaTEgPSAxO1xuICAgIGoxID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cHBlciB0cmlhbmdsZSwgWVggb3JkZXI6ICgwLDApLT4oMCwxKS0+KDEsMSlcbiAgICBpMSA9IDA7XG4gICAgajEgPSAxO1xuICB9IC8vIEEgc3RlcCBvZiAoMSwwKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYykgaW4gKHgseSksIGFuZFxuICAvLyBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMpIGluICh4LHkpLCB3aGVyZVxuICAvLyBjID0gKDMtc3FydCgzKSkvNlxuXG5cbiAgdmFyIHgxID0geDAgLSBpMSArIEcyOyAvLyBPZmZzZXRzIGZvciBtaWRkbGUgY29ybmVyIGluICh4LHkpIHVuc2tld2VkIGNvb3Jkc1xuXG4gIHZhciB5MSA9IHkwIC0gajEgKyBHMjtcbiAgdmFyIHgyID0geDAgLSAxICsgMiAqIEcyOyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcblxuICB2YXIgeTIgPSB5MCAtIDEgKyAyICogRzI7IC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgdGhyZWUgc2ltcGxleCBjb3JuZXJzXG5cbiAgaSAmPSAyNTU7XG4gIGogJj0gMjU1O1xuICB2YXIgZ2kwID0gZ3JhZFBbaSArIHBlcm1bal1dO1xuICB2YXIgZ2kxID0gZ3JhZFBbaSArIGkxICsgcGVybVtqICsgajFdXTtcbiAgdmFyIGdpMiA9IGdyYWRQW2kgKyAxICsgcGVybVtqICsgMV1dOyAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXG5cbiAgdmFyIHQwID0gMC41IC0geDAgKiB4MCAtIHkwICogeTA7XG5cbiAgaWYgKHQwIDwgMCkge1xuICAgIG4wID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MCAqPSB0MDtcbiAgICBuMCA9IHQwICogdDAgKiBnaTAuZG90Mih4MCwgeTApOyAvLyAoeCx5KSBvZiBncmFkMyB1c2VkIGZvciAyRCBncmFkaWVudFxuICB9XG5cbiAgdmFyIHQxID0gMC41IC0geDEgKiB4MSAtIHkxICogeTE7XG5cbiAgaWYgKHQxIDwgMCkge1xuICAgIG4xID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MSAqPSB0MTtcbiAgICBuMSA9IHQxICogdDEgKiBnaTEuZG90Mih4MSwgeTEpO1xuICB9XG5cbiAgdmFyIHQyID0gMC41IC0geDIgKiB4MiAtIHkyICogeTI7XG5cbiAgaWYgKHQyIDwgMCkge1xuICAgIG4yID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MiAqPSB0MjtcbiAgICBuMiA9IHQyICogdDIgKiBnaTIuZG90Mih4MiwgeTIpO1xuICB9IC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgaW50ZXJ2YWwgWy0xLDFdLlxuXG5cbiAgcmV0dXJuIDcwICogKG4wICsgbjEgKyBuMik7XG59OyAvLyAzRCBzaW1wbGV4IG5vaXNlXG5cbnZhciBzaW1wbGV4MyA9IGZ1bmN0aW9uIHNpbXBsZXgzKHhpbiwgeWluLCB6aW4pIHtcbiAgdmFyIG4wLCBuMSwgbjIsIG4zOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIGZvdXIgY29ybmVyc1xuICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG5cbiAgdmFyIHMgPSAoeGluICsgeWluICsgemluKSAqIEYzOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXG5cbiAgdmFyIGkgPSBNYXRoLmZsb29yKHhpbiArIHMpO1xuICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XG4gIHZhciBrID0gTWF0aC5mbG9vcih6aW4gKyBzKTtcbiAgdmFyIHQgPSAoaSArIGogKyBrKSAqIEczO1xuICB2YXIgeDAgPSB4aW4gLSBpICsgdDsgLy8gVGhlIHgseSBkaXN0YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW4sIHVuc2tld2VkLlxuXG4gIHZhciB5MCA9IHlpbiAtIGogKyB0O1xuICB2YXIgejAgPSB6aW4gLSBrICsgdDsgLy8gRm9yIHRoZSAzRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhIHNsaWdodGx5IGlycmVndWxhciB0ZXRyYWhlZHJvbi5cbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLlxuXG4gIHZhciBpMSwgajEsIGsxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcblxuICB2YXIgaTIsIGoyLCBrMjsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcblxuICBpZiAoeDAgPj0geTApIHtcbiAgICBpZiAoeTAgPj0gejApIHtcbiAgICAgIGkxID0gMTtcbiAgICAgIGoxID0gMDtcbiAgICAgIGsxID0gMDtcbiAgICAgIGkyID0gMTtcbiAgICAgIGoyID0gMTtcbiAgICAgIGsyID0gMDtcbiAgICB9IGVsc2UgaWYgKHgwID49IHowKSB7XG4gICAgICBpMSA9IDE7XG4gICAgICBqMSA9IDA7XG4gICAgICBrMSA9IDA7XG4gICAgICBpMiA9IDE7XG4gICAgICBqMiA9IDA7XG4gICAgICBrMiA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkxID0gMDtcbiAgICAgIGoxID0gMDtcbiAgICAgIGsxID0gMTtcbiAgICAgIGkyID0gMTtcbiAgICAgIGoyID0gMDtcbiAgICAgIGsyID0gMTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHkwIDwgejApIHtcbiAgICAgIGkxID0gMDtcbiAgICAgIGoxID0gMDtcbiAgICAgIGsxID0gMTtcbiAgICAgIGkyID0gMDtcbiAgICAgIGoyID0gMTtcbiAgICAgIGsyID0gMTtcbiAgICB9IGVsc2UgaWYgKHgwIDwgejApIHtcbiAgICAgIGkxID0gMDtcbiAgICAgIGoxID0gMTtcbiAgICAgIGsxID0gMDtcbiAgICAgIGkyID0gMDtcbiAgICAgIGoyID0gMTtcbiAgICAgIGsyID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaTEgPSAwO1xuICAgICAgajEgPSAxO1xuICAgICAgazEgPSAwO1xuICAgICAgaTIgPSAxO1xuICAgICAgajIgPSAxO1xuICAgICAgazIgPSAwO1xuICAgIH1cbiAgfSAvLyBBIHN0ZXAgb2YgKDEsMCwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jLC1jKSBpbiAoeCx5LHopLFxuICAvLyBhIHN0ZXAgb2YgKDAsMSwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jLC1jKSBpbiAoeCx5LHopLCBhbmRcbiAgLy8gYSBzdGVwIG9mICgwLDAsMSkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKC1jLC1jLDEtYykgaW4gKHgseSx6KSwgd2hlcmVcbiAgLy8gYyA9IDEvNi5cblxuXG4gIHZhciB4MSA9IHgwIC0gaTEgKyBHMzsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lclxuXG4gIHZhciB5MSA9IHkwIC0gajEgKyBHMztcbiAgdmFyIHoxID0gejAgLSBrMSArIEczO1xuICB2YXIgeDIgPSB4MCAtIGkyICsgMiAqIEczOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXJcblxuICB2YXIgeTIgPSB5MCAtIGoyICsgMiAqIEczO1xuICB2YXIgejIgPSB6MCAtIGsyICsgMiAqIEczO1xuICB2YXIgeDMgPSB4MCAtIDEgKyAzICogRzM7IC8vIE9mZnNldHMgZm9yIGZvdXJ0aCBjb3JuZXJcblxuICB2YXIgeTMgPSB5MCAtIDEgKyAzICogRzM7XG4gIHZhciB6MyA9IHowIC0gMSArIDMgKiBHMzsgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmb3VyIHNpbXBsZXggY29ybmVyc1xuXG4gIGkgJj0gMjU1O1xuICBqICY9IDI1NTtcbiAgayAmPSAyNTU7XG4gIHZhciBnaTAgPSBncmFkUFtpICsgcGVybVtqICsgcGVybVtrXV1dO1xuICB2YXIgZ2kxID0gZ3JhZFBbaSArIGkxICsgcGVybVtqICsgajEgKyBwZXJtW2sgKyBrMV1dXTtcbiAgdmFyIGdpMiA9IGdyYWRQW2kgKyBpMiArIHBlcm1baiArIGoyICsgcGVybVtrICsgazJdXV07XG4gIHZhciBnaTMgPSBncmFkUFtpICsgMSArIHBlcm1baiArIDEgKyBwZXJtW2sgKyAxXV1dOyAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBmb3VyIGNvcm5lcnNcblxuICB2YXIgdDAgPSAwLjYgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejA7XG5cbiAgaWYgKHQwIDwgMCkge1xuICAgIG4wID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MCAqPSB0MDtcbiAgICBuMCA9IHQwICogdDAgKiBnaTAuZG90Myh4MCwgeTAsIHowKTsgLy8gKHgseSkgb2YgZ3JhZDMgdXNlZCBmb3IgMkQgZ3JhZGllbnRcbiAgfVxuXG4gIHZhciB0MSA9IDAuNiAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MTtcblxuICBpZiAodDEgPCAwKSB7XG4gICAgbjEgPSAwO1xuICB9IGVsc2Uge1xuICAgIHQxICo9IHQxO1xuICAgIG4xID0gdDEgKiB0MSAqIGdpMS5kb3QzKHgxLCB5MSwgejEpO1xuICB9XG5cbiAgdmFyIHQyID0gMC42IC0geDIgKiB4MiAtIHkyICogeTIgLSB6MiAqIHoyO1xuXG4gIGlmICh0MiA8IDApIHtcbiAgICBuMiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdDIgKj0gdDI7XG4gICAgbjIgPSB0MiAqIHQyICogZ2kyLmRvdDMoeDIsIHkyLCB6Mik7XG4gIH1cblxuICB2YXIgdDMgPSAwLjYgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejM7XG5cbiAgaWYgKHQzIDwgMCkge1xuICAgIG4zID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MyAqPSB0MztcbiAgICBuMyA9IHQzICogdDMgKiBnaTMuZG90Myh4MywgeTMsIHozKTtcbiAgfSAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuXG4gIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHJldHVybiB2YWx1ZXMgaW4gdGhlIGludGVydmFsIFstMSwxXS5cblxuXG4gIHJldHVybiAzMiAqIChuMCArIG4xICsgbjIgKyBuMyk7XG59OyAvLyAjIyMjIyBQZXJsaW4gbm9pc2Ugc3R1ZmZcbi8vIDJEIFBlcmxpbiBOb2lzZVxuXG52YXIgcGVybGluMiA9IGZ1bmN0aW9uIHBlcmxpbjIoeCwgeSkge1xuICAvLyBGaW5kIHVuaXQgZ3JpZCBjZWxsIGNvbnRhaW5pbmcgcG9pbnRcbiAgdmFyIFggPSBNYXRoLmZsb29yKHgpLFxuICAgICAgWSA9IE1hdGguZmxvb3IoeSk7IC8vIEdldCByZWxhdGl2ZSB4eSBjb29yZGluYXRlcyBvZiBwb2ludCB3aXRoaW4gdGhhdCBjZWxsXG5cbiAgeCA9IHggLSBYO1xuICB5ID0geSAtIFk7IC8vIFdyYXAgdGhlIGludGVnZXIgY2VsbHMgYXQgMjU1IChzbWFsbGVyIGludGVnZXIgcGVyaW9kIGNhbiBiZSBpbnRyb2R1Y2VkIGhlcmUpXG5cbiAgWCA9IFggJiAyNTU7XG4gIFkgPSBZICYgMjU1OyAvLyBDYWxjdWxhdGUgbm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggb2YgdGhlIGZvdXIgY29ybmVyc1xuXG4gIHZhciBuMDAgPSBncmFkUFtYICsgcGVybVtZXV0uZG90Mih4LCB5KTtcbiAgdmFyIG4wMSA9IGdyYWRQW1ggKyBwZXJtW1kgKyAxXV0uZG90Mih4LCB5IC0gMSk7XG4gIHZhciBuMTAgPSBncmFkUFtYICsgMSArIHBlcm1bWV1dLmRvdDIoeCAtIDEsIHkpO1xuICB2YXIgbjExID0gZ3JhZFBbWCArIDEgKyBwZXJtW1kgKyAxXV0uZG90Mih4IC0gMSwgeSAtIDEpOyAvLyBDb21wdXRlIHRoZSBmYWRlIGN1cnZlIHZhbHVlIGZvciB4XG5cbiAgdmFyIHUgPSBtaXNjX2Rpc3RfbWFhdGhNaXNjLmZhZGUoeCk7IC8vIEludGVycG9sYXRlIHRoZSBmb3VyIHJlc3VsdHNcblxuICByZXR1cm4gbWlzY19kaXN0X21hYXRoTWlzYy5sZXJwKG1pc2NfZGlzdF9tYWF0aE1pc2MubGVycChuMDAsIG4xMCwgdSksIG1pc2NfZGlzdF9tYWF0aE1pc2MubGVycChuMDEsIG4xMSwgdSksIG1pc2NfZGlzdF9tYWF0aE1pc2MuZmFkZSh5KSk7XG59OyAvLyAzRCBQZXJsaW4gTm9pc2VcblxudmFyIHBlcmxpbjMgPSBmdW5jdGlvbiBwZXJsaW4zKHgsIHksIHopIHtcbiAgLy8gRmluZCB1bml0IGdyaWQgY2VsbCBjb250YWluaW5nIHBvaW50XG4gIHZhciBYID0gTWF0aC5mbG9vcih4KSxcbiAgICAgIFkgPSBNYXRoLmZsb29yKHkpLFxuICAgICAgWiA9IE1hdGguZmxvb3Ioeik7IC8vIEdldCByZWxhdGl2ZSB4eXogY29vcmRpbmF0ZXMgb2YgcG9pbnQgd2l0aGluIHRoYXQgY2VsbFxuXG4gIHggPSB4IC0gWDtcbiAgeSA9IHkgLSBZO1xuICB6ID0geiAtIFo7IC8vIFdyYXAgdGhlIGludGVnZXIgY2VsbHMgYXQgMjU1IChzbWFsbGVyIGludGVnZXIgcGVyaW9kIGNhbiBiZSBpbnRyb2R1Y2VkIGhlcmUpXG5cbiAgWCA9IFggJiAyNTU7XG4gIFkgPSBZICYgMjU1O1xuICBaID0gWiAmIDI1NTsgLy8gQ2FsY3VsYXRlIG5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIG9mIHRoZSBlaWdodCBjb3JuZXJzXG5cbiAgdmFyIG4wMDAgPSBncmFkUFtYICsgcGVybVtZICsgcGVybVtaXV1dLmRvdDMoeCwgeSwgeik7XG4gIHZhciBuMDAxID0gZ3JhZFBbWCArIHBlcm1bWSArIHBlcm1bWiArIDFdXV0uZG90Myh4LCB5LCB6IC0gMSk7XG4gIHZhciBuMDEwID0gZ3JhZFBbWCArIHBlcm1bWSArIDEgKyBwZXJtW1pdXV0uZG90Myh4LCB5IC0gMSwgeik7XG4gIHZhciBuMDExID0gZ3JhZFBbWCArIHBlcm1bWSArIDEgKyBwZXJtW1ogKyAxXV1dLmRvdDMoeCwgeSAtIDEsIHogLSAxKTtcbiAgdmFyIG4xMDAgPSBncmFkUFtYICsgMSArIHBlcm1bWSArIHBlcm1bWl1dXS5kb3QzKHggLSAxLCB5LCB6KTtcbiAgdmFyIG4xMDEgPSBncmFkUFtYICsgMSArIHBlcm1bWSArIHBlcm1bWiArIDFdXV0uZG90Myh4IC0gMSwgeSwgeiAtIDEpO1xuICB2YXIgbjExMCA9IGdyYWRQW1ggKyAxICsgcGVybVtZICsgMSArIHBlcm1bWl1dXS5kb3QzKHggLSAxLCB5IC0gMSwgeik7XG4gIHZhciBuMTExID0gZ3JhZFBbWCArIDEgKyBwZXJtW1kgKyAxICsgcGVybVtaICsgMV1dXS5kb3QzKHggLSAxLCB5IC0gMSwgeiAtIDEpOyAvLyBDb21wdXRlIHRoZSBmYWRlIGN1cnZlIHZhbHVlIGZvciB4LCB5LCB6XG5cbiAgdmFyIHUgPSBtaXNjX2Rpc3RfbWFhdGhNaXNjLmZhZGUoeCk7XG4gIHZhciB2ID0gbWlzY19kaXN0X21hYXRoTWlzYy5mYWRlKHkpO1xuICB2YXIgdyA9IG1pc2NfZGlzdF9tYWF0aE1pc2MuZmFkZSh6KTsgLy8gSW50ZXJwb2xhdGVcblxuICByZXR1cm4gbWlzY19kaXN0X21hYXRoTWlzYy5sZXJwKG1pc2NfZGlzdF9tYWF0aE1pc2MubGVycChtaXNjX2Rpc3RfbWFhdGhNaXNjLmxlcnAobjAwMCwgbjEwMCwgdSksIG1pc2NfZGlzdF9tYWF0aE1pc2MubGVycChuMDAxLCBuMTAxLCB1KSwgdyksIG1pc2NfZGlzdF9tYWF0aE1pc2MubGVycChtaXNjX2Rpc3RfbWFhdGhNaXNjLmxlcnAobjAxMCwgbjExMCwgdSksIG1pc2NfZGlzdF9tYWF0aE1pc2MubGVycChuMDExLCBuMTExLCB1KSwgdyksIHYpO1xufTtcblxudmFyIG5vaXNlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHNlZWQ6IHNlZWQsXG4gIHNpbXBsZXgyOiBzaW1wbGV4MixcbiAgc2ltcGxleDM6IHNpbXBsZXgzLFxuICBwZXJsaW4yOiBwZXJsaW4yLFxuICBwZXJsaW4zOiBwZXJsaW4zXG59KTtcblxudmFyIFRBVSA9IE1hdGguUEkgKiAyO1xudmFyIEZsYXNoR2VuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmxhc2hHZW4ocHJvcHMpIHtcbiAgICBjbGFzc0NhbGxDaGVjay5fY2xhc3NDYWxsQ2hlY2sodGhpcywgRmxhc2hHZW4pO1xuXG4gICAgb2JqZWN0U3ByZWFkMi5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJuZXh0QnVyc3RUaW1lXCIsIDApO1xuXG4gICAgb2JqZWN0U3ByZWFkMi5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJuZXh0Rmxhc2hFbmRUaW1lXCIsIDApO1xuXG4gICAgb2JqZWN0U3ByZWFkMi5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJmbGFzaGVzRG9uZVwiLCAwKTtcblxuICAgIG9iamVjdFNwcmVhZDIuX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNGbGFzaGluZ1wiLCBmYWxzZSk7XG5cbiAgICBvYmplY3RTcHJlYWQyLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImN1cnJlbnRDb3VudFwiLCAwKTtcblxuICAgIG9iamVjdFNwcmVhZDIuX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmxhc2hJbnRlbnNpdHlcIiwgMCk7XG5cbiAgICBvYmplY3RTcHJlYWQyLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzRGVjYXlpbmdcIiwgZmFsc2UpO1xuXG4gICAgb2JqZWN0U3ByZWFkMi5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQnVyc3RcIiwgdHJ1ZSk7XG5cbiAgICBvYmplY3RTcHJlYWQyLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlY2F5U3BlZWRcIiwgNDApO1xuXG4gICAgb2JqZWN0U3ByZWFkMi5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJtaW5JbnRlcnZhbFwiLCA1MDAwKTtcblxuICAgIG9iamVjdFNwcmVhZDIuX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4SW50ZXJ2YWxcIiwgMTAwMDApO1xuXG4gICAgb2JqZWN0U3ByZWFkMi5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJtaW5EdXJhdGlvblwiLCA1MCk7XG5cbiAgICBvYmplY3RTcHJlYWQyLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heER1cmF0aW9uXCIsIDMwMCk7XG5cbiAgICBvYmplY3RTcHJlYWQyLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvdW50XCIsIDUpO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRmxhc2hHZW4sIFt7XG4gICAga2V5OiBcInNjaGVkdWxlTmV4dEJ1cnN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjaGVkdWxlTmV4dEJ1cnN0KGN1cnJlbnRUaW1lKSB7XG4gICAgICB2YXIgYnVyc3RJbnRlcnZhbCA9IE1hdGgucmFuZG9tKCkgKiAodGhpcy5tYXhJbnRlcnZhbCAtIHRoaXMubWluSW50ZXJ2YWwpICsgdGhpcy5taW5JbnRlcnZhbDtcbiAgICAgIHRoaXMubmV4dEJ1cnN0VGltZSA9IGN1cnJlbnRUaW1lICsgYnVyc3RJbnRlcnZhbCAvIDEwMDA7XG4gICAgICB0aGlzLmZsYXNoZXNEb25lID0gMDtcbiAgICAgIHRoaXMuaXNGbGFzaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidXJzdCgpIHtcbiAgICAgIHRoaXMubmV4dEJ1cnN0VGltZSA9IDA7XG4gICAgICB0aGlzLmZsYXNoZXNEb25lID0gMDtcbiAgICAgIHRoaXMuaXNGbGFzaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGN1cnJlbnRUaW1lLCBkZWx0YSkge1xuICAgICAgaWYgKGN1cnJlbnRUaW1lID4gdGhpcy5uZXh0QnVyc3RUaW1lICYmIHRoaXMuY3VycmVudENvdW50ID09PSAwKSB7XG4gICAgICAgIHRoaXMuY3VycmVudENvdW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5jb3VudCkgKyAxO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5mbGFzaGVzRG9uZSA8IHRoaXMuY3VycmVudENvdW50ICYmIGN1cnJlbnRUaW1lID4gdGhpcy5uZXh0QnVyc3RUaW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0ZsYXNoaW5nKSB7XG4gICAgICAgICAgdGhpcy5pc0ZsYXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmZsYXNoSW50ZW5zaXR5ID0gMTtcbiAgICAgICAgICB2YXIgZmxhc2hEdXJhdGlvbiA9IE1hdGgucmFuZG9tKCkgKiAodGhpcy5tYXhEdXJhdGlvbiAtIHRoaXMubWluRHVyYXRpb24pICsgdGhpcy5taW5EdXJhdGlvbjtcbiAgICAgICAgICB0aGlzLm5leHRGbGFzaEVuZFRpbWUgPSBjdXJyZW50VGltZSArIGZsYXNoRHVyYXRpb24gLyAxMDAwO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNGbGFzaGluZyAmJiBjdXJyZW50VGltZSA+IHRoaXMubmV4dEZsYXNoRW5kVGltZSkge1xuICAgICAgICAgIHRoaXMuaXNGbGFzaGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaXNEZWNheWluZyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5mbGFzaGVzRG9uZSsrO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZmxhc2hlc0RvbmUgPj0gdGhpcy5jdXJyZW50Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvdW50ID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9CdXJzdCkgdGhpcy5zY2hlZHVsZU5leHRCdXJzdChjdXJyZW50VGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRGVjYXlpbmcpIHtcbiAgICAgICAgdGhpcy5mbGFzaEludGVuc2l0eSAtPSBkZWx0YSAqIHRoaXMuZGVjYXlTcGVlZDtcbiAgICAgICAgdGhpcy5mbGFzaEludGVuc2l0eSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMuZmxhc2hJbnRlbnNpdHkpKTtcblxuICAgICAgICBpZiAodGhpcy5mbGFzaEludGVuc2l0eSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5pc0RlY2F5aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5mbGFzaEludGVuc2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZmxhc2hJbnRlbnNpdHk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZsYXNoR2VuO1xufSgpOyAvLyBDcmVkaXRzIEBrY2hhcGVsaWVyIGh0dHBzOi8vZ2l0aHViLmNvbS9rY2hhcGVsaWVyL3dhdmVmdW5jdGlvbmNvbGxhcHNlL2Jsb2IvbWFzdGVyL2V4YW1wbGUvbGNnLmpzI0wyMi1MMzBcblxuZnVuY3Rpb24gbm9ybWFsaXplU2VlZChzZWVkKSB7XG4gIGlmICh0eXBlb2Ygc2VlZCA9PT0gXCJudW1iZXJcIikge1xuICAgIHNlZWQgPSBNYXRoLmFicyhzZWVkKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhciBzdHJpbmcgPSBzZWVkO1xuICAgIHNlZWQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlZWQgPSAoc2VlZCArIChpICsgMSkgKiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgJSA5NikpICUgMjE0NzQ4MzY0NztcbiAgICB9XG4gIH1cblxuICBpZiAoc2VlZCA9PT0gMCkge1xuICAgIHNlZWQgPSAzMTE7XG4gIH1cblxuICByZXR1cm4gc2VlZDtcbn1cblxuZnVuY3Rpb24gbGNnUmFuZG9tKHNlZWQpIHtcbiAgdmFyIHN0YXRlID0gbm9ybWFsaXplU2VlZChzZWVkKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGUgKiA0ODI3MSAlIDIxNDc0ODM2NDc7XG4gICAgc3RhdGUgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdCAvIDIxNDc0ODM2NDc7XG4gIH07XG59XG5cbnZhciBHZW5lcmF0b3IgPSBmdW5jdGlvbiBHZW5lcmF0b3IoX3NlZWQpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBjbGFzc0NhbGxDaGVjay5fY2xhc3NDYWxsQ2hlY2sodGhpcywgR2VuZXJhdG9yKTtcblxuICBvYmplY3RTcHJlYWQyLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlZWRcIiwgMCk7XG5cbiAgb2JqZWN0U3ByZWFkMi5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbml0XCIsIGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgX3RoaXMuc2VlZCA9IHNlZWQ7XG4gICAgX3RoaXMudmFsdWUgPSBsY2dSYW5kb20oc2VlZCk7XG4gIH0pO1xuXG4gIG9iamVjdFNwcmVhZDIuX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgbGNnUmFuZG9tKHRoaXMuc2VlZCkpO1xuXG4gIHRoaXMuaW5pdChfc2VlZCk7XG59O1xudmFyIGRlZmF1bHRHZW4gPSBuZXcgR2VuZXJhdG9yKE1hdGgucmFuZG9tKCkpO1xuLyoqKlxuICogWzNEXSBTcGhlcmVcbiAqL1xuXG52YXIgZGVmYXVsdFNwaGVyZSA9IHtcbiAgcmFkaXVzOiAxLFxuICBjZW50ZXI6IFswLCAwLCAwXVxufTsgLy8gcmFuZG9tIG9uIHN1cmZhY2Ugb2Ygc3BoZXJlXG4vLyAtIGh0dHBzOi8vdHdpdHRlci5jb20vZmVybWF0c2xpYnJhcnkvc3RhdHVzLzE0MzA5MzI1MDM1NzgyMjY2ODhcbi8vIC0gaHR0cHM6Ly9tYXRod29ybGQud29sZnJhbS5jb20vU3BoZXJlUG9pbnRQaWNraW5nLmh0bWxcblxuZnVuY3Rpb24gb25TcGhlcmUoYnVmZmVyLCBzcGhlcmUpIHtcbiAgdmFyIHJuZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZGVmYXVsdEdlbjtcblxuICB2YXIgX2RlZmF1bHRTcGhlcmUkc3BoZXJlID0gb2JqZWN0U3ByZWFkMi5fb2JqZWN0U3ByZWFkMihvYmplY3RTcHJlYWQyLl9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0U3BoZXJlKSwgc3BoZXJlKSxcbiAgICAgIHJhZGl1cyA9IF9kZWZhdWx0U3BoZXJlJHNwaGVyZS5yYWRpdXMsXG4gICAgICBjZW50ZXIgPSBfZGVmYXVsdFNwaGVyZSRzcGhlcmUuY2VudGVyO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgdmFyIHUgPSBybmcudmFsdWUoKTtcbiAgICB2YXIgdiA9IHJuZy52YWx1ZSgpO1xuICAgIHZhciB0aGV0YSA9IE1hdGguYWNvcygyICogdiAtIDEpO1xuICAgIHZhciBwaGkgPSBUQVUgKiB1O1xuICAgIGJ1ZmZlcltpXSA9IE1hdGguc2luKHRoZXRhKSAqIE1hdGguY29zKHBoaSkgKiByYWRpdXMgKyBjZW50ZXJbMF07XG4gICAgYnVmZmVyW2kgKyAxXSA9IE1hdGguc2luKHRoZXRhKSAqIE1hdGguc2luKHBoaSkgKiByYWRpdXMgKyBjZW50ZXJbMV07XG4gICAgYnVmZmVyW2kgKyAyXSA9IE1hdGguY29zKHRoZXRhKSAqIHJhZGl1cyArIGNlbnRlclsyXTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59IC8vIGZyb20gXCJBbm90aGVyIE1ldGhvZFwiIGh0dHBzOi8vZGF0YWdlbmV0aWNzLmNvbS9ibG9nL2phbnVhcnkzMjAyMC9pbmRleC5odG1sXG5cbmZ1bmN0aW9uIGluU3BoZXJlKGJ1ZmZlciwgc3BoZXJlKSB7XG4gIHZhciBybmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGRlZmF1bHRHZW47XG5cbiAgdmFyIF9kZWZhdWx0U3BoZXJlJHNwaGVyZTIgPSBvYmplY3RTcHJlYWQyLl9vYmplY3RTcHJlYWQyKG9iamVjdFNwcmVhZDIuX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRTcGhlcmUpLCBzcGhlcmUpLFxuICAgICAgcmFkaXVzID0gX2RlZmF1bHRTcGhlcmUkc3BoZXJlMi5yYWRpdXMsXG4gICAgICBjZW50ZXIgPSBfZGVmYXVsdFNwaGVyZSRzcGhlcmUyLmNlbnRlcjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMykge1xuICAgIHZhciB1ID0gTWF0aC5wb3cocm5nLnZhbHVlKCksIDEgLyAzKTtcbiAgICB2YXIgeCA9IHJuZy52YWx1ZSgpICogMiAtIDE7XG4gICAgdmFyIHkgPSBybmcudmFsdWUoKSAqIDIgLSAxO1xuICAgIHZhciB6ID0gcm5nLnZhbHVlKCkgKiAyIC0gMTtcbiAgICB2YXIgbWFnID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gICAgeCA9IHUgKiB4IC8gbWFnO1xuICAgIHkgPSB1ICogeSAvIG1hZztcbiAgICB6ID0gdSAqIHogLyBtYWc7XG4gICAgYnVmZmVyW2ldID0geCAqIHJhZGl1cyArIGNlbnRlclswXTtcbiAgICBidWZmZXJbaSArIDFdID0geSAqIHJhZGl1cyArIGNlbnRlclsxXTtcbiAgICBidWZmZXJbaSArIDJdID0geiAqIHJhZGl1cyArIGNlbnRlclsyXTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59XG4vKioqXG4gKiBbMkRdIENpcmNsZVxuICovXG5cbnZhciBkZWZhdWx0Q2lyY2xlID0ge1xuICByYWRpdXM6IDEsXG4gIGNlbnRlcjogWzAsIDBdXG59OyAvLyByYW5kb20gY2lyY2xlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81MDc0NjQwOVxuXG5mdW5jdGlvbiBpbkNpcmNsZShidWZmZXIsIGNpcmNsZSkge1xuICB2YXIgcm5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBkZWZhdWx0R2VuO1xuXG4gIHZhciBfZGVmYXVsdENpcmNsZSRjaXJjbGUgPSBvYmplY3RTcHJlYWQyLl9vYmplY3RTcHJlYWQyKG9iamVjdFNwcmVhZDIuX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRDaXJjbGUpLCBjaXJjbGUpLFxuICAgICAgcmFkaXVzID0gX2RlZmF1bHRDaXJjbGUkY2lyY2xlLnJhZGl1cyxcbiAgICAgIGNlbnRlciA9IF9kZWZhdWx0Q2lyY2xlJGNpcmNsZS5jZW50ZXI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgciA9IHJhZGl1cyAqIE1hdGguc3FydChybmcudmFsdWUoKSk7XG4gICAgdmFyIHRoZXRhID0gcm5nLnZhbHVlKCkgKiBUQVU7XG4gICAgYnVmZmVyW2ldID0gTWF0aC5zaW4odGhldGEpICogciArIGNlbnRlclswXTtcbiAgICBidWZmZXJbaSArIDFdID0gTWF0aC5jb3ModGhldGEpICogciArIGNlbnRlclsxXTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBvbkNpcmNsZShidWZmZXIsIGNpcmNsZSkge1xuICB2YXIgcm5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBkZWZhdWx0R2VuO1xuXG4gIHZhciBfZGVmYXVsdENpcmNsZSRjaXJjbGUyID0gb2JqZWN0U3ByZWFkMi5fb2JqZWN0U3ByZWFkMihvYmplY3RTcHJlYWQyLl9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0Q2lyY2xlKSwgY2lyY2xlKSxcbiAgICAgIHJhZGl1cyA9IF9kZWZhdWx0Q2lyY2xlJGNpcmNsZTIucmFkaXVzLFxuICAgICAgY2VudGVyID0gX2RlZmF1bHRDaXJjbGUkY2lyY2xlMi5jZW50ZXI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgdGhldGEgPSBybmcudmFsdWUoKSAqIFRBVTtcbiAgICBidWZmZXJbaV0gPSBNYXRoLnNpbih0aGV0YSkgKiByYWRpdXMgKyBjZW50ZXJbMF07XG4gICAgYnVmZmVyW2kgKyAxXSA9IE1hdGguY29zKHRoZXRhKSAqIHJhZGl1cyArIGNlbnRlclsxXTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59XG4vKipcbiAqIFsyRF0gUGxhbmVcbiAqL1xuXG52YXIgZGVmYXVsdFJlY3QgPSB7XG4gIHNpZGVzOiAxLFxuICBjZW50ZXI6IFswLCAwXVxufTtcbmZ1bmN0aW9uIGluUmVjdChidWZmZXIsIHJlY3QpIHtcbiAgdmFyIHJuZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZGVmYXVsdEdlbjtcblxuICB2YXIgX2RlZmF1bHRSZWN0JHJlY3QgPSBvYmplY3RTcHJlYWQyLl9vYmplY3RTcHJlYWQyKG9iamVjdFNwcmVhZDIuX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRSZWN0KSwgcmVjdCksXG4gICAgICBzaWRlcyA9IF9kZWZhdWx0UmVjdCRyZWN0LnNpZGVzLFxuICAgICAgY2VudGVyID0gX2RlZmF1bHRSZWN0JHJlY3QuY2VudGVyO1xuXG4gIHZhciBzaWRlWCA9IHR5cGVvZiBzaWRlcyA9PT0gXCJudW1iZXJcIiA/IHNpZGVzIDogc2lkZXNbMF07XG4gIHZhciBzaWRlWSA9IHR5cGVvZiBzaWRlcyA9PT0gXCJudW1iZXJcIiA/IHNpZGVzIDogc2lkZXNbMV07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBidWZmZXJbaV0gPSAocm5nLnZhbHVlKCkgLSAwLjUpICogc2lkZVggKyBjZW50ZXJbMF07XG4gICAgYnVmZmVyW2kgKyAxXSA9IChybmcudmFsdWUoKSAtIDAuNSkgKiBzaWRlWSArIGNlbnRlclsxXTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBvblJlY3QoYnVmZmVyLCByZWN0KSB7XG4gIHJldHVybiBidWZmZXI7XG59XG4vKioqXG4gKiBbM0RdIEJveFxuICovXG5cbmZ1bmN0aW9uIGluQm94KGJ1ZmZlciwgYm94KSB7XG4gIHZhciBybmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGRlZmF1bHRHZW47XG5cbiAgdmFyIF9kZWZhdWx0Qm94JGJveCA9IG9iamVjdFNwcmVhZDIuX29iamVjdFNwcmVhZDIob2JqZWN0U3ByZWFkMi5fb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdEJveCksIGJveCksXG4gICAgICBzaWRlcyA9IF9kZWZhdWx0Qm94JGJveC5zaWRlcyxcbiAgICAgIGNlbnRlciA9IF9kZWZhdWx0Qm94JGJveC5jZW50ZXI7XG5cbiAgdmFyIHNpZGVYID0gdHlwZW9mIHNpZGVzID09PSBcIm51bWJlclwiID8gc2lkZXMgOiBzaWRlc1swXTtcbiAgdmFyIHNpZGVZID0gdHlwZW9mIHNpZGVzID09PSBcIm51bWJlclwiID8gc2lkZXMgOiBzaWRlc1sxXTtcbiAgdmFyIHNpZGVaID0gdHlwZW9mIHNpZGVzID09PSBcIm51bWJlclwiID8gc2lkZXMgOiBzaWRlc1syXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMykge1xuICAgIGJ1ZmZlcltpXSA9IChybmcudmFsdWUoKSAtIDAuNSkgKiBzaWRlWCArIGNlbnRlclswXTtcbiAgICBidWZmZXJbaSArIDFdID0gKHJuZy52YWx1ZSgpIC0gMC41KSAqIHNpZGVZICsgY2VudGVyWzFdO1xuICAgIGJ1ZmZlcltpICsgMl0gPSAocm5nLnZhbHVlKCkgLSAwLjUpICogc2lkZVogKyBjZW50ZXJbMl07XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufVxudmFyIGRlZmF1bHRCb3ggPSB7XG4gIHNpZGVzOiAxLFxuICBjZW50ZXI6IFswLCAwLCAwXVxufTtcbmZ1bmN0aW9uIG9uQm94KGJ1ZmZlciwgYm94KSB7XG4gIHZhciBybmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGRlZmF1bHRHZW47XG5cbiAgdmFyIF9kZWZhdWx0Qm94JGJveDIgPSBvYmplY3RTcHJlYWQyLl9vYmplY3RTcHJlYWQyKG9iamVjdFNwcmVhZDIuX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRCb3gpLCBib3gpLFxuICAgICAgc2lkZXMgPSBfZGVmYXVsdEJveCRib3gyLnNpZGVzLFxuICAgICAgY2VudGVyID0gX2RlZmF1bHRCb3gkYm94Mi5jZW50ZXI7XG5cbiAgdmFyIHNpZGVYID0gdHlwZW9mIHNpZGVzID09PSBcIm51bWJlclwiID8gc2lkZXMgOiBzaWRlc1swXTtcbiAgdmFyIHNpZGVZID0gdHlwZW9mIHNpZGVzID09PSBcIm51bWJlclwiID8gc2lkZXMgOiBzaWRlc1sxXTtcbiAgdmFyIHNpZGVaID0gdHlwZW9mIHNpZGVzID09PSBcIm51bWJlclwiID8gc2lkZXMgOiBzaWRlc1syXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMykge1xuICAgIGJ1ZmZlcltpXSA9IChybmcudmFsdWUoKSAtIDAuNSkgKiBzaWRlWCArIGNlbnRlclswXTtcbiAgICBidWZmZXJbaSArIDFdID0gKHJuZy52YWx1ZSgpIC0gMC41KSAqIHNpZGVZICsgY2VudGVyWzFdO1xuICAgIGJ1ZmZlcltpICsgMl0gPSAocm5nLnZhbHVlKCkgLSAwLjUpICogc2lkZVogKyBjZW50ZXJbMl07XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgRmxhc2hHZW46IEZsYXNoR2VuLFxuICBHZW5lcmF0b3I6IEdlbmVyYXRvcixcbiAgb25TcGhlcmU6IG9uU3BoZXJlLFxuICBpblNwaGVyZTogaW5TcGhlcmUsXG4gIGluQ2lyY2xlOiBpbkNpcmNsZSxcbiAgb25DaXJjbGU6IG9uQ2lyY2xlLFxuICBpblJlY3Q6IGluUmVjdCxcbiAgb25SZWN0OiBvblJlY3QsXG4gIGluQm94OiBpbkJveCxcbiAgb25Cb3g6IG9uQm94LFxuICBub2lzZTogbm9pc2Vcbn0pO1xuXG5leHBvcnRzLkZsYXNoR2VuID0gRmxhc2hHZW47XG5leHBvcnRzLkdlbmVyYXRvciA9IEdlbmVyYXRvcjtcbmV4cG9ydHMuaW5Cb3ggPSBpbkJveDtcbmV4cG9ydHMuaW5DaXJjbGUgPSBpbkNpcmNsZTtcbmV4cG9ydHMuaW5SZWN0ID0gaW5SZWN0O1xuZXhwb3J0cy5pblNwaGVyZSA9IGluU3BoZXJlO1xuZXhwb3J0cy5pbmRleCA9IGluZGV4O1xuZXhwb3J0cy5ub2lzZSA9IG5vaXNlO1xuZXhwb3J0cy5vbkJveCA9IG9uQm94O1xuZXhwb3J0cy5vbkNpcmNsZSA9IG9uQ2lyY2xlO1xuZXhwb3J0cy5vblJlY3QgPSBvblJlY3Q7XG5leHBvcnRzLm9uU3BoZXJlID0gb25TcGhlcmU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/index-26fb8954.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/isNativeReflectConstruct-5594d075.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/maath/dist/isNativeReflectConstruct-5594d075.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _setPrototypeOf),\n/* harmony export */   a: () => (/* binding */ _isNativeReflectConstruct)\n/* harmony export */ });\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QtNTU5NGQwNzUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFZ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9tYWF0aC9kaXN0L2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC01NTk0ZDA3NS5lc20uanM/YjZhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCB7IF9zZXRQcm90b3R5cGVPZiBhcyBfLCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IGFzIGEgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/isNativeReflectConstruct-5594d075.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/isNativeReflectConstruct-ddc4ebc1.cjs.dev.js":
/*!******************************************************************************!*\
  !*** ./node_modules/maath/dist/isNativeReflectConstruct-ddc4ebc1.cjs.dev.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nexports._isNativeReflectConstruct = _isNativeReflectConstruct;\nexports._setPrototypeOf = _setPrototypeOf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QtZGRjNGViYzEuY2pzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQyx1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9tYWF0aC9kaXN0L2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC1kZGM0ZWJjMS5janMuZGV2LmpzPzI0MmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3Q7XG5leHBvcnRzLl9zZXRQcm90b3R5cGVPZiA9IF9zZXRQcm90b3R5cGVPZjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/isNativeReflectConstruct-ddc4ebc1.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/maath.cjs.dev.js":
/*!**************************************************!*\
  !*** ./node_modules/maath/dist/maath.cjs.dev.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar buffer_dist_maathBuffer = __webpack_require__(/*! ./buffer-6b4e8456.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/buffer-6b4e8456.cjs.dev.js\");\nvar random_dist_maathRandom = __webpack_require__(/*! ./index-26fb8954.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/index-26fb8954.cjs.dev.js\");\nvar easing_dist_maathEasing = __webpack_require__(/*! ./easing-104c3902.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/easing-104c3902.cjs.dev.js\");\nvar geometry_dist_maathGeometry = __webpack_require__(/*! ./geometry-358de1c4.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/geometry-358de1c4.cjs.dev.js\");\nvar matrix_dist_maathMatrix = __webpack_require__(/*! ./matrix-fb190f60.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/matrix-fb190f60.cjs.dev.js\");\nvar misc_dist_maathMisc = __webpack_require__(/*! ./misc-fce4d494.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/misc-fce4d494.cjs.dev.js\");\nvar three_dist_maathThree = __webpack_require__(/*! ./three-87cc244e.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/three-87cc244e.cjs.dev.js\");\nvar triangle_dist_maathTriangle = __webpack_require__(/*! ./triangle-33ffdfef.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/triangle-33ffdfef.cjs.dev.js\");\nvar vector2_dist_maathVector2 = __webpack_require__(/*! ./vector2-f44fd63e.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/vector2-f44fd63e.cjs.dev.js\");\nvar vector3_dist_maathVector3 = __webpack_require__(/*! ./vector3-5e723d1a.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/vector3-5e723d1a.cjs.dev.js\");\n__webpack_require__(/*! ./objectSpread2-32cd2c34.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/objectSpread2-32cd2c34.cjs.dev.js\");\n__webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\n__webpack_require__(/*! ./classCallCheck-eaf0efc7.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/classCallCheck-eaf0efc7.cjs.dev.js\");\n__webpack_require__(/*! ./isNativeReflectConstruct-ddc4ebc1.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/isNativeReflectConstruct-ddc4ebc1.cjs.dev.js\");\n\n\n\nexports.buffer = buffer_dist_maathBuffer.buffer;\nexports.random = random_dist_maathRandom.index;\nexports.easing = easing_dist_maathEasing.easing;\nexports.geometry = geometry_dist_maathGeometry.geometry;\nexports.matrix = matrix_dist_maathMatrix.matrix;\nexports.misc = misc_dist_maathMisc.misc;\nexports.three = three_dist_maathThree.three;\nexports.triangle = triangle_dist_maathTriangle.triangle;\nexports.vector2 = vector2_dist_maathVector2.vector2;\nexports.vector3 = vector3_dist_maathVector3.vector3;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9tYWF0aC5janMuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsOEJBQThCLG1CQUFPLENBQUMsZ0dBQThCO0FBQ3BFLDhCQUE4QixtQkFBTyxDQUFDLDhGQUE2QjtBQUNuRSw4QkFBOEIsbUJBQU8sQ0FBQyxnR0FBOEI7QUFDcEUsa0NBQWtDLG1CQUFPLENBQUMsb0dBQWdDO0FBQzFFLDhCQUE4QixtQkFBTyxDQUFDLGdHQUE4QjtBQUNwRSwwQkFBMEIsbUJBQU8sQ0FBQyw0RkFBNEI7QUFDOUQsNEJBQTRCLG1CQUFPLENBQUMsOEZBQTZCO0FBQ2pFLGtDQUFrQyxtQkFBTyxDQUFDLG9HQUFnQztBQUMxRSxnQ0FBZ0MsbUJBQU8sQ0FBQyxrR0FBK0I7QUFDdkUsZ0NBQWdDLG1CQUFPLENBQUMsa0dBQStCO0FBQ3ZFLG1CQUFPLENBQUMsOEdBQXFDO0FBQzdDLG1CQUFPLENBQUMseURBQU87QUFDZixtQkFBTyxDQUFDLGdIQUFzQztBQUM5QyxtQkFBTyxDQUFDLG9JQUFnRDs7OztBQUl4RCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLFlBQVk7QUFDWixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9tYWF0aC5janMuZGV2LmpzP2ViYzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYnVmZmVyX2Rpc3RfbWFhdGhCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci02YjRlODQ1Ni5janMuZGV2LmpzJyk7XG52YXIgcmFuZG9tX2Rpc3RfbWFhdGhSYW5kb20gPSByZXF1aXJlKCcuL2luZGV4LTI2ZmI4OTU0LmNqcy5kZXYuanMnKTtcbnZhciBlYXNpbmdfZGlzdF9tYWF0aEVhc2luZyA9IHJlcXVpcmUoJy4vZWFzaW5nLTEwNGMzOTAyLmNqcy5kZXYuanMnKTtcbnZhciBnZW9tZXRyeV9kaXN0X21hYXRoR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dlb21ldHJ5LTM1OGRlMWM0LmNqcy5kZXYuanMnKTtcbnZhciBtYXRyaXhfZGlzdF9tYWF0aE1hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4LWZiMTkwZjYwLmNqcy5kZXYuanMnKTtcbnZhciBtaXNjX2Rpc3RfbWFhdGhNaXNjID0gcmVxdWlyZSgnLi9taXNjLWZjZTRkNDk0LmNqcy5kZXYuanMnKTtcbnZhciB0aHJlZV9kaXN0X21hYXRoVGhyZWUgPSByZXF1aXJlKCcuL3RocmVlLTg3Y2MyNDRlLmNqcy5kZXYuanMnKTtcbnZhciB0cmlhbmdsZV9kaXN0X21hYXRoVHJpYW5nbGUgPSByZXF1aXJlKCcuL3RyaWFuZ2xlLTMzZmZkZmVmLmNqcy5kZXYuanMnKTtcbnZhciB2ZWN0b3IyX2Rpc3RfbWFhdGhWZWN0b3IyID0gcmVxdWlyZSgnLi92ZWN0b3IyLWY0NGZkNjNlLmNqcy5kZXYuanMnKTtcbnZhciB2ZWN0b3IzX2Rpc3RfbWFhdGhWZWN0b3IzID0gcmVxdWlyZSgnLi92ZWN0b3IzLTVlNzIzZDFhLmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJy4vb2JqZWN0U3ByZWFkMi0zMmNkMmMzNC5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCd0aHJlZScpO1xucmVxdWlyZSgnLi9jbGFzc0NhbGxDaGVjay1lYWYwZWZjNy5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCcuL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC1kZGM0ZWJjMS5janMuZGV2LmpzJyk7XG5cblxuXG5leHBvcnRzLmJ1ZmZlciA9IGJ1ZmZlcl9kaXN0X21hYXRoQnVmZmVyLmJ1ZmZlcjtcbmV4cG9ydHMucmFuZG9tID0gcmFuZG9tX2Rpc3RfbWFhdGhSYW5kb20uaW5kZXg7XG5leHBvcnRzLmVhc2luZyA9IGVhc2luZ19kaXN0X21hYXRoRWFzaW5nLmVhc2luZztcbmV4cG9ydHMuZ2VvbWV0cnkgPSBnZW9tZXRyeV9kaXN0X21hYXRoR2VvbWV0cnkuZ2VvbWV0cnk7XG5leHBvcnRzLm1hdHJpeCA9IG1hdHJpeF9kaXN0X21hYXRoTWF0cml4Lm1hdHJpeDtcbmV4cG9ydHMubWlzYyA9IG1pc2NfZGlzdF9tYWF0aE1pc2MubWlzYztcbmV4cG9ydHMudGhyZWUgPSB0aHJlZV9kaXN0X21hYXRoVGhyZWUudGhyZWU7XG5leHBvcnRzLnRyaWFuZ2xlID0gdHJpYW5nbGVfZGlzdF9tYWF0aFRyaWFuZ2xlLnRyaWFuZ2xlO1xuZXhwb3J0cy52ZWN0b3IyID0gdmVjdG9yMl9kaXN0X21hYXRoVmVjdG9yMi52ZWN0b3IyO1xuZXhwb3J0cy52ZWN0b3IzID0gdmVjdG9yM19kaXN0X21hYXRoVmVjdG9yMy52ZWN0b3IzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/maath.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/maath.cjs.js":
/*!**********************************************!*\
  !*** ./node_modules/maath/dist/maath.cjs.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./maath.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/maath.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9tYWF0aC5janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGtIQUE4QztBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYWNlcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvbWFhdGguY2pzLmpzPzAzMjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbWFhdGguY2pzLnByb2QuanNcIik7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL21hYXRoLmNqcy5kZXYuanNcIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/maath.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/matrix-baa530bf.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/maath/dist/matrix-baa530bf.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ matrixSum3),\n/* harmony export */   b: () => (/* binding */ determinant2),\n/* harmony export */   c: () => (/* binding */ determinant4),\n/* harmony export */   d: () => (/* binding */ determinant3),\n/* harmony export */   g: () => (/* binding */ getMinor),\n/* harmony export */   m: () => (/* binding */ matrix)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\n\n/**\n *\n * @param terms\n *\n * | a b |\n * | c d |\n *\n * @returns {number} determinant\n */\n\nfunction determinant2() {\n  for (var _len = arguments.length, terms = new Array(_len), _key = 0; _key < _len; _key++) {\n    terms[_key] = arguments[_key];\n  }\n\n  var a = terms[0],\n      b = terms[1],\n      c = terms[2],\n      d = terms[3];\n  return a * d - b * c;\n}\n/**\n *\n * @param terms\n *\n * | a b c |\n * | d e f |\n * | g h i |\n *\n * @returns {number} determinant\n */\n\nfunction determinant3() {\n  for (var _len2 = arguments.length, terms = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    terms[_key2] = arguments[_key2];\n  }\n\n  var a = terms[0],\n      b = terms[1],\n      c = terms[2],\n      d = terms[3],\n      e = terms[4],\n      f = terms[5],\n      g = terms[6],\n      h = terms[7],\n      i = terms[8];\n  return a * e * i + b * f * g + c * d * h - c * e * g - b * d * i - a * f * h;\n}\n/**\n *\n * @param terms\n *\n * | a b c g |\n * | h i j k |\n * | l m n o |\n *\n * @returns {number} determinant\n */\n\nfunction determinant4() {\n  for (var _len3 = arguments.length, terms = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    terms[_key3] = arguments[_key3];\n  }\n\n  terms[0];\n      terms[1];\n      terms[2];\n      terms[3];\n      terms[4];\n      terms[5];\n      terms[6];\n      terms[7];\n      terms[8];\n      terms[9];\n      terms[10];\n      terms[11];\n      terms[12];\n      terms[13];\n      terms[14]; // TODO\n}\n/**\n *\n * Get the determinant of matrix m without row r and col c\n *\n * @param {matrix} m Starter matrix\n * @param r row to remove\n * @param c col to remove\n *\n *     | a b c |\n * m = | d e f |\n *     | g h i |\n *\n * getMinor(m, 1, 1) would result in this determinant\n *\n * | a c |\n * | g i |\n *\n * @returns {number} determinant\n */\n\nfunction getMinor(matrix, r, c) {\n  var _matrixTranspose = matrix.clone().transpose();\n\n  var x = [];\n  var l = _matrixTranspose.elements.length;\n  var n = Math.sqrt(l);\n\n  for (var i = 0; i < l; i++) {\n    var element = _matrixTranspose.elements[i];\n    var row = Math.floor(i / n);\n    var col = i % n;\n\n    if (row !== r - 1 && col !== c - 1) {\n      x.push(element);\n    }\n  }\n\n  return determinant3.apply(void 0, x);\n}\n/**\n *\n */\n\nfunction matrixSum3(m1, m2) {\n  var sum = [];\n  var m1Array = m1.toArray();\n  var m2Array = m2.toArray();\n\n  for (var i = 0; i < m1Array.length; i++) {\n    sum[i] = m1Array[i] + m2Array[i];\n  }\n\n  return new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3().fromArray(sum);\n}\n\nvar matrix = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  determinant2: determinant2,\n  determinant3: determinant3,\n  determinant4: determinant4,\n  getMinor: getMinor,\n  matrixSum3: matrixSum3\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9tYXRyaXgtYmFhNTMwYmYuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0EsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0EsMEVBQTBFLGVBQWU7QUFDekY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUEsYUFBYSwwQ0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRStHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9tYXRyaXgtYmFhNTMwYmYuZXNtLmpzP2Q4ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJ3RocmVlJztcblxuLyoqXG4gKlxuICogQHBhcmFtIHRlcm1zXG4gKlxuICogfCBhIGIgfFxuICogfCBjIGQgfFxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRldGVybWluYW50XG4gKi9cblxuZnVuY3Rpb24gZGV0ZXJtaW5hbnQyKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdGVybXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdGVybXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgYSA9IHRlcm1zWzBdLFxuICAgICAgYiA9IHRlcm1zWzFdLFxuICAgICAgYyA9IHRlcm1zWzJdLFxuICAgICAgZCA9IHRlcm1zWzNdO1xuICByZXR1cm4gYSAqIGQgLSBiICogYztcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB0ZXJtc1xuICpcbiAqIHwgYSBiIGMgfFxuICogfCBkIGUgZiB8XG4gKiB8IGcgaCBpIHxcbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkZXRlcm1pbmFudFxuICovXG5cbmZ1bmN0aW9uIGRldGVybWluYW50MygpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB0ZXJtcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIHRlcm1zW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICB2YXIgYSA9IHRlcm1zWzBdLFxuICAgICAgYiA9IHRlcm1zWzFdLFxuICAgICAgYyA9IHRlcm1zWzJdLFxuICAgICAgZCA9IHRlcm1zWzNdLFxuICAgICAgZSA9IHRlcm1zWzRdLFxuICAgICAgZiA9IHRlcm1zWzVdLFxuICAgICAgZyA9IHRlcm1zWzZdLFxuICAgICAgaCA9IHRlcm1zWzddLFxuICAgICAgaSA9IHRlcm1zWzhdO1xuICByZXR1cm4gYSAqIGUgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnIC0gYiAqIGQgKiBpIC0gYSAqIGYgKiBoO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHRlcm1zXG4gKlxuICogfCBhIGIgYyBnIHxcbiAqIHwgaCBpIGogayB8XG4gKiB8IGwgbSBuIG8gfFxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRldGVybWluYW50XG4gKi9cblxuZnVuY3Rpb24gZGV0ZXJtaW5hbnQ0KCkge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHRlcm1zID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgdGVybXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHRlcm1zWzBdO1xuICAgICAgdGVybXNbMV07XG4gICAgICB0ZXJtc1syXTtcbiAgICAgIHRlcm1zWzNdO1xuICAgICAgdGVybXNbNF07XG4gICAgICB0ZXJtc1s1XTtcbiAgICAgIHRlcm1zWzZdO1xuICAgICAgdGVybXNbN107XG4gICAgICB0ZXJtc1s4XTtcbiAgICAgIHRlcm1zWzldO1xuICAgICAgdGVybXNbMTBdO1xuICAgICAgdGVybXNbMTFdO1xuICAgICAgdGVybXNbMTJdO1xuICAgICAgdGVybXNbMTNdO1xuICAgICAgdGVybXNbMTRdOyAvLyBUT0RPXG59XG4vKipcbiAqXG4gKiBHZXQgdGhlIGRldGVybWluYW50IG9mIG1hdHJpeCBtIHdpdGhvdXQgcm93IHIgYW5kIGNvbCBjXG4gKlxuICogQHBhcmFtIHttYXRyaXh9IG0gU3RhcnRlciBtYXRyaXhcbiAqIEBwYXJhbSByIHJvdyB0byByZW1vdmVcbiAqIEBwYXJhbSBjIGNvbCB0byByZW1vdmVcbiAqXG4gKiAgICAgfCBhIGIgYyB8XG4gKiBtID0gfCBkIGUgZiB8XG4gKiAgICAgfCBnIGggaSB8XG4gKlxuICogZ2V0TWlub3IobSwgMSwgMSkgd291bGQgcmVzdWx0IGluIHRoaXMgZGV0ZXJtaW5hbnRcbiAqXG4gKiB8IGEgYyB8XG4gKiB8IGcgaSB8XG4gKlxuICogQHJldHVybnMge251bWJlcn0gZGV0ZXJtaW5hbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRNaW5vcihtYXRyaXgsIHIsIGMpIHtcbiAgdmFyIF9tYXRyaXhUcmFuc3Bvc2UgPSBtYXRyaXguY2xvbmUoKS50cmFuc3Bvc2UoKTtcblxuICB2YXIgeCA9IFtdO1xuICB2YXIgbCA9IF9tYXRyaXhUcmFuc3Bvc2UuZWxlbWVudHMubGVuZ3RoO1xuICB2YXIgbiA9IE1hdGguc3FydChsKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBlbGVtZW50ID0gX21hdHJpeFRyYW5zcG9zZS5lbGVtZW50c1tpXTtcbiAgICB2YXIgcm93ID0gTWF0aC5mbG9vcihpIC8gbik7XG4gICAgdmFyIGNvbCA9IGkgJSBuO1xuXG4gICAgaWYgKHJvdyAhPT0gciAtIDEgJiYgY29sICE9PSBjIC0gMSkge1xuICAgICAgeC5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXRlcm1pbmFudDMuYXBwbHkodm9pZCAwLCB4KTtcbn1cbi8qKlxuICpcbiAqL1xuXG5mdW5jdGlvbiBtYXRyaXhTdW0zKG0xLCBtMikge1xuICB2YXIgc3VtID0gW107XG4gIHZhciBtMUFycmF5ID0gbTEudG9BcnJheSgpO1xuICB2YXIgbTJBcnJheSA9IG0yLnRvQXJyYXkoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0xQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBzdW1baV0gPSBtMUFycmF5W2ldICsgbTJBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgTWF0cml4MygpLmZyb21BcnJheShzdW0pO1xufVxuXG52YXIgbWF0cml4ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRldGVybWluYW50MjogZGV0ZXJtaW5hbnQyLFxuICBkZXRlcm1pbmFudDM6IGRldGVybWluYW50MyxcbiAgZGV0ZXJtaW5hbnQ0OiBkZXRlcm1pbmFudDQsXG4gIGdldE1pbm9yOiBnZXRNaW5vcixcbiAgbWF0cml4U3VtMzogbWF0cml4U3VtM1xufSk7XG5cbmV4cG9ydCB7IG1hdHJpeFN1bTMgYXMgYSwgZGV0ZXJtaW5hbnQyIGFzIGIsIGRldGVybWluYW50NCBhcyBjLCBkZXRlcm1pbmFudDMgYXMgZCwgZ2V0TWlub3IgYXMgZywgbWF0cml4IGFzIG0gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/matrix-baa530bf.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/matrix-fb190f60.cjs.dev.js":
/*!************************************************************!*\
  !*** ./node_modules/maath/dist/matrix-fb190f60.cjs.dev.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\n\n/**\n *\n * @param terms\n *\n * | a b |\n * | c d |\n *\n * @returns {number} determinant\n */\n\nfunction determinant2() {\n  for (var _len = arguments.length, terms = new Array(_len), _key = 0; _key < _len; _key++) {\n    terms[_key] = arguments[_key];\n  }\n\n  var a = terms[0],\n      b = terms[1],\n      c = terms[2],\n      d = terms[3];\n  return a * d - b * c;\n}\n/**\n *\n * @param terms\n *\n * | a b c |\n * | d e f |\n * | g h i |\n *\n * @returns {number} determinant\n */\n\nfunction determinant3() {\n  for (var _len2 = arguments.length, terms = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    terms[_key2] = arguments[_key2];\n  }\n\n  var a = terms[0],\n      b = terms[1],\n      c = terms[2],\n      d = terms[3],\n      e = terms[4],\n      f = terms[5],\n      g = terms[6],\n      h = terms[7],\n      i = terms[8];\n  return a * e * i + b * f * g + c * d * h - c * e * g - b * d * i - a * f * h;\n}\n/**\n *\n * @param terms\n *\n * | a b c g |\n * | h i j k |\n * | l m n o |\n *\n * @returns {number} determinant\n */\n\nfunction determinant4() {\n  for (var _len3 = arguments.length, terms = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    terms[_key3] = arguments[_key3];\n  }\n\n  terms[0];\n      terms[1];\n      terms[2];\n      terms[3];\n      terms[4];\n      terms[5];\n      terms[6];\n      terms[7];\n      terms[8];\n      terms[9];\n      terms[10];\n      terms[11];\n      terms[12];\n      terms[13];\n      terms[14]; // TODO\n}\n/**\n *\n * Get the determinant of matrix m without row r and col c\n *\n * @param {matrix} m Starter matrix\n * @param r row to remove\n * @param c col to remove\n *\n *     | a b c |\n * m = | d e f |\n *     | g h i |\n *\n * getMinor(m, 1, 1) would result in this determinant\n *\n * | a c |\n * | g i |\n *\n * @returns {number} determinant\n */\n\nfunction getMinor(matrix, r, c) {\n  var _matrixTranspose = matrix.clone().transpose();\n\n  var x = [];\n  var l = _matrixTranspose.elements.length;\n  var n = Math.sqrt(l);\n\n  for (var i = 0; i < l; i++) {\n    var element = _matrixTranspose.elements[i];\n    var row = Math.floor(i / n);\n    var col = i % n;\n\n    if (row !== r - 1 && col !== c - 1) {\n      x.push(element);\n    }\n  }\n\n  return determinant3.apply(void 0, x);\n}\n/**\n *\n */\n\nfunction matrixSum3(m1, m2) {\n  var sum = [];\n  var m1Array = m1.toArray();\n  var m2Array = m2.toArray();\n\n  for (var i = 0; i < m1Array.length; i++) {\n    sum[i] = m1Array[i] + m2Array[i];\n  }\n\n  return new THREE.Matrix3().fromArray(sum);\n}\n\nvar matrix = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  determinant2: determinant2,\n  determinant3: determinant3,\n  determinant4: determinant4,\n  getMinor: getMinor,\n  matrixSum3: matrixSum3\n});\n\nexports.determinant2 = determinant2;\nexports.determinant3 = determinant3;\nexports.determinant4 = determinant4;\nexports.getMinor = getMinor;\nexports.matrix = matrix;\nexports.matrixSum3 = matrixSum3;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9tYXRyaXgtZmIxOTBmNjAuY2pzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMseURBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0EsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0EsMEVBQTBFLGVBQWU7QUFDekY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9tYWF0aC9kaXN0L21hdHJpeC1mYjE5MGY2MC5janMuZGV2LmpzP2Y4YTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gdGVybXNcbiAqXG4gKiB8IGEgYiB8XG4gKiB8IGMgZCB8XG4gKlxuICogQHJldHVybnMge251bWJlcn0gZGV0ZXJtaW5hbnRcbiAqL1xuXG5mdW5jdGlvbiBkZXRlcm1pbmFudDIoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB0ZXJtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB0ZXJtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBhID0gdGVybXNbMF0sXG4gICAgICBiID0gdGVybXNbMV0sXG4gICAgICBjID0gdGVybXNbMl0sXG4gICAgICBkID0gdGVybXNbM107XG4gIHJldHVybiBhICogZCAtIGIgKiBjO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHRlcm1zXG4gKlxuICogfCBhIGIgYyB8XG4gKiB8IGQgZSBmIHxcbiAqIHwgZyBoIGkgfFxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRldGVybWluYW50XG4gKi9cblxuZnVuY3Rpb24gZGV0ZXJtaW5hbnQzKCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHRlcm1zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgdGVybXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIHZhciBhID0gdGVybXNbMF0sXG4gICAgICBiID0gdGVybXNbMV0sXG4gICAgICBjID0gdGVybXNbMl0sXG4gICAgICBkID0gdGVybXNbM10sXG4gICAgICBlID0gdGVybXNbNF0sXG4gICAgICBmID0gdGVybXNbNV0sXG4gICAgICBnID0gdGVybXNbNl0sXG4gICAgICBoID0gdGVybXNbN10sXG4gICAgICBpID0gdGVybXNbOF07XG4gIHJldHVybiBhICogZSAqIGkgKyBiICogZiAqIGcgKyBjICogZCAqIGggLSBjICogZSAqIGcgLSBiICogZCAqIGkgLSBhICogZiAqIGg7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdGVybXNcbiAqXG4gKiB8IGEgYiBjIGcgfFxuICogfCBoIGkgaiBrIHxcbiAqIHwgbCBtIG4gbyB8XG4gKlxuICogQHJldHVybnMge251bWJlcn0gZGV0ZXJtaW5hbnRcbiAqL1xuXG5mdW5jdGlvbiBkZXRlcm1pbmFudDQoKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdGVybXMgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICB0ZXJtc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgdGVybXNbMF07XG4gICAgICB0ZXJtc1sxXTtcbiAgICAgIHRlcm1zWzJdO1xuICAgICAgdGVybXNbM107XG4gICAgICB0ZXJtc1s0XTtcbiAgICAgIHRlcm1zWzVdO1xuICAgICAgdGVybXNbNl07XG4gICAgICB0ZXJtc1s3XTtcbiAgICAgIHRlcm1zWzhdO1xuICAgICAgdGVybXNbOV07XG4gICAgICB0ZXJtc1sxMF07XG4gICAgICB0ZXJtc1sxMV07XG4gICAgICB0ZXJtc1sxMl07XG4gICAgICB0ZXJtc1sxM107XG4gICAgICB0ZXJtc1sxNF07IC8vIFRPRE9cbn1cbi8qKlxuICpcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgbWF0cml4IG0gd2l0aG91dCByb3cgciBhbmQgY29sIGNcbiAqXG4gKiBAcGFyYW0ge21hdHJpeH0gbSBTdGFydGVyIG1hdHJpeFxuICogQHBhcmFtIHIgcm93IHRvIHJlbW92ZVxuICogQHBhcmFtIGMgY29sIHRvIHJlbW92ZVxuICpcbiAqICAgICB8IGEgYiBjIHxcbiAqIG0gPSB8IGQgZSBmIHxcbiAqICAgICB8IGcgaCBpIHxcbiAqXG4gKiBnZXRNaW5vcihtLCAxLCAxKSB3b3VsZCByZXN1bHQgaW4gdGhpcyBkZXRlcm1pbmFudFxuICpcbiAqIHwgYSBjIHxcbiAqIHwgZyBpIHxcbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkZXRlcm1pbmFudFxuICovXG5cbmZ1bmN0aW9uIGdldE1pbm9yKG1hdHJpeCwgciwgYykge1xuICB2YXIgX21hdHJpeFRyYW5zcG9zZSA9IG1hdHJpeC5jbG9uZSgpLnRyYW5zcG9zZSgpO1xuXG4gIHZhciB4ID0gW107XG4gIHZhciBsID0gX21hdHJpeFRyYW5zcG9zZS5lbGVtZW50cy5sZW5ndGg7XG4gIHZhciBuID0gTWF0aC5zcXJ0KGwpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBfbWF0cml4VHJhbnNwb3NlLmVsZW1lbnRzW2ldO1xuICAgIHZhciByb3cgPSBNYXRoLmZsb29yKGkgLyBuKTtcbiAgICB2YXIgY29sID0gaSAlIG47XG5cbiAgICBpZiAocm93ICE9PSByIC0gMSAmJiBjb2wgIT09IGMgLSAxKSB7XG4gICAgICB4LnB1c2goZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRldGVybWluYW50My5hcHBseSh2b2lkIDAsIHgpO1xufVxuLyoqXG4gKlxuICovXG5cbmZ1bmN0aW9uIG1hdHJpeFN1bTMobTEsIG0yKSB7XG4gIHZhciBzdW0gPSBbXTtcbiAgdmFyIG0xQXJyYXkgPSBtMS50b0FycmF5KCk7XG4gIHZhciBtMkFycmF5ID0gbTIudG9BcnJheSgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbTFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHN1bVtpXSA9IG0xQXJyYXlbaV0gKyBtMkFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5NYXRyaXgzKCkuZnJvbUFycmF5KHN1bSk7XG59XG5cbnZhciBtYXRyaXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZGV0ZXJtaW5hbnQyOiBkZXRlcm1pbmFudDIsXG4gIGRldGVybWluYW50MzogZGV0ZXJtaW5hbnQzLFxuICBkZXRlcm1pbmFudDQ6IGRldGVybWluYW50NCxcbiAgZ2V0TWlub3I6IGdldE1pbm9yLFxuICBtYXRyaXhTdW0zOiBtYXRyaXhTdW0zXG59KTtcblxuZXhwb3J0cy5kZXRlcm1pbmFudDIgPSBkZXRlcm1pbmFudDI7XG5leHBvcnRzLmRldGVybWluYW50MyA9IGRldGVybWluYW50MztcbmV4cG9ydHMuZGV0ZXJtaW5hbnQ0ID0gZGV0ZXJtaW5hbnQ0O1xuZXhwb3J0cy5nZXRNaW5vciA9IGdldE1pbm9yO1xuZXhwb3J0cy5tYXRyaXggPSBtYXRyaXg7XG5leHBvcnRzLm1hdHJpeFN1bTMgPSBtYXRyaXhTdW0zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/matrix-fb190f60.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/misc-19a3ec46.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/maath/dist/misc-19a3ec46.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ degToRad),\n/* harmony export */   b: () => (/* binding */ radToDeg),\n/* harmony export */   c: () => (/* binding */ clamp),\n/* harmony export */   d: () => (/* binding */ deltaAngle),\n/* harmony export */   e: () => (/* binding */ fibonacciOnSphere),\n/* harmony export */   f: () => (/* binding */ fade),\n/* harmony export */   g: () => (/* binding */ lexicographic),\n/* harmony export */   h: () => (/* binding */ convexHull),\n/* harmony export */   i: () => (/* binding */ remap),\n/* harmony export */   j: () => (/* binding */ inverseLerp),\n/* harmony export */   k: () => (/* binding */ rotateVectorOnVector),\n/* harmony export */   l: () => (/* binding */ lerp),\n/* harmony export */   m: () => (/* binding */ misc),\n/* harmony export */   n: () => (/* binding */ normalize),\n/* harmony export */   o: () => (/* binding */ pointToCoordinate),\n/* harmony export */   p: () => (/* binding */ pointOnCubeToPointOnSphere),\n/* harmony export */   q: () => (/* binding */ coordinateToPoint),\n/* harmony export */   r: () => (/* binding */ repeat),\n/* harmony export */   s: () => (/* binding */ planeSegmentIntersection),\n/* harmony export */   t: () => (/* binding */ pointToPlaneDistance),\n/* harmony export */   u: () => (/* binding */ getIndexFrom3D),\n/* harmony export */   v: () => (/* binding */ vectorEquals),\n/* harmony export */   w: () => (/* binding */ get3DFromIndex),\n/* harmony export */   x: () => (/* binding */ getIndexFrom2D),\n/* harmony export */   y: () => (/* binding */ get2DFromIndex)\n/* harmony export */ });\n/* harmony import */ var _triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./triangle-b62b9067.esm.js */ \"(ssr)/./node_modules/maath/dist/triangle-b62b9067.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix-baa530bf.esm.js */ \"(ssr)/./node_modules/maath/dist/matrix-baa530bf.esm.js\");\n\n\n\n\n/**\n * Clamps a value between a range.\n */\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n} // Loops the value t, so that it is never larger than length and never smaller than 0.\n\nfunction repeat(t, length) {\n  return clamp(t - Math.floor(t / length) * length, 0, length);\n} // Calculates the shortest difference between two given angles.\n\nfunction deltaAngle(current, target) {\n  var delta = repeat(target - current, Math.PI * 2);\n  if (delta > Math.PI) delta -= Math.PI * 2;\n  return delta;\n}\n/**\n * Converts degrees to radians.\n */\n\nfunction degToRad(degrees) {\n  return degrees / 180 * Math.PI;\n}\n/**\n * Converts radians to degrees.\n */\n\nfunction radToDeg(radians) {\n  return radians * 180 / Math.PI;\n} // adapted from https://gist.github.com/stephanbogner/a5f50548a06bec723dcb0991dcbb0856 by https://twitter.com/st_phan\n\nfunction fibonacciOnSphere(buffer, _ref) {\n  var _ref$radius = _ref.radius,\n      radius = _ref$radius === void 0 ? 1 : _ref$radius;\n  var samples = buffer.length / 3;\n  var offset = 2 / samples;\n  var increment = Math.PI * (3 - 2.2360679775);\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    var y = i * offset - 1 + offset / 2;\n    var distance = Math.sqrt(1 - Math.pow(y, 2));\n    var phi = i % samples * increment;\n    var x = Math.cos(phi) * distance;\n    var z = Math.sin(phi) * distance;\n    buffer[i] = x * radius;\n    buffer[i + 1] = y * radius;\n    buffer[i + 2] = z * radius;\n  }\n} // @ts-ignore\n\nfunction vectorEquals(a, b) {\n  var eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.EPSILON;\n  return Math.abs(a.x - b.x) < eps && Math.abs(a.y - b.y) < eps && Math.abs(a.z - b.z) < eps;\n}\n/**\n * Sorts vectors in lexicographic order, works with both v2 and v3\n *\n *  Use as:\n *  const sorted = arrayOfVectors.sort(lexicographicOrder)\n */\n// https://en.wikipedia.org/wiki/Lexicographic_order\n\nfunction lexicographic(a, b) {\n  if (a.x === b.x) {\n    // do a check to see if points is 3D,\n    // in which case add y eq check and sort by z\n    if (typeof a.z !== \"undefined\") {\n      if (a.y === b.y) {\n        return a.z - b.z;\n      }\n    }\n\n    return a.y - b.y;\n  }\n\n  return a.x - b.x;\n}\n/**\n * Convex Hull\n *\n * Returns an array of 2D Vectors representing the convex hull of a set of 2D Vectors\n */\n\n/**\n * Calculate the convex hull of a set of points\n */\n\nfunction convexHull(_points) {\n  var points = _points.sort(lexicographic); // put p1 and p2 in a list lUpper with p1 as the first point\n\n\n  var lUpper = [points[0], points[1]]; // for i <- 3 to n\n\n  for (var i = 2; i < points.length; i++) {\n    lUpper.push(points[i]); // while lUpper contains more than 2 points and the last three points in lUpper do not make a right turn\n\n    while (lUpper.length > 2 && (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)((0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(lUpper.slice(-3)))) {\n      // delete the middle of the last three points from lUpper\n      lUpper.splice(lUpper.length - 2, 1);\n    }\n  } // put pn and pn-1 in a list lLower with pn as the first point\n\n\n  var lLower = [points[points.length - 1], points[points.length - 2]]; // for (i <- n - 2 downto 1)\n\n  for (var _i = points.length - 3; _i >= 0; _i--) {\n    // append pi to lLower\n    lLower.push(points[_i]); // while lLower contains more than 2 points and the last three points in lLower do not make a right turn\n\n    while (lLower.length > 2 && (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)((0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(lLower.slice(-3)))) {\n      // delete the middle of the last three points from lLower\n      lLower.splice(lLower.length - 2, 1);\n    }\n  } // remove the first and last point from lLower to avoid duplication of the points where the upper and lower hull meet\n\n\n  lLower.splice(0, 1);\n  lLower.splice(lLower.length - 1, 1); // prettier-ignore\n\n  var c = [].concat(lUpper, lLower);\n  return c;\n}\nfunction remap(x, _ref2, _ref3) {\n  var _ref4 = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(_ref2, 2),\n      low1 = _ref4[0],\n      high1 = _ref4[1];\n\n  var _ref5 = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(_ref3, 2),\n      low2 = _ref5[0],\n      high2 = _ref5[1];\n\n  return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n/**\n *\n * https://www.desmos.com/calculator/vsnmlaljdu\n *\n * Ease-in-out, goes to -Infinite before 0 and Infinite after 1\n *\n * @param t\n * @returns\n */\n\nfunction fade(t) {\n  return t * t * t * (t * (t * 6 - 15) + 10);\n}\n/**\n *\n * Returns the result of linearly interpolating between input A and input B by input T.\n *\n * @param v0\n * @param v1\n * @param t\n * @returns\n */\n\nfunction lerp(v0, v1, t) {\n  return v0 * (1 - t) + v1 * t;\n}\n/**\n *\n * Returns the linear parameter that produces the interpolant specified by input T within the range of input A to input B.\n *\n * @param v0\n * @param v1\n * @param t\n * @returns\n */\n\nfunction inverseLerp(v0, v1, t) {\n  return (t - v0) / (v1 - v0);\n}\n/**\n *\n */\n\nfunction normalize(x, y, z) {\n  var m = Math.sqrt(x * x + y * y + z * z);\n  return [x / m, y / m, z / m];\n}\n/**\n *\n */\n\nfunction pointOnCubeToPointOnSphere(x, y, z) {\n  var x2 = x * x;\n  var y2 = y * y;\n  var z2 = z * z;\n  var nx = x * Math.sqrt(1 - (y2 + z2) / 2 + y2 * z2 / 3);\n  var ny = y * Math.sqrt(1 - (z2 + x2) / 2 + z2 * x2 / 3);\n  var nz = z * Math.sqrt(1 - (x2 + y2) / 2 + x2 * y2 / 3);\n  return [nx, ny, nz];\n} // https://math.stackexchange.com/questions/180418/calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d\n\n/**\n * Give two unit vectors a and b, returns the transformation matrix that rotates a onto b.\n *\n * */\n\nfunction rotateVectorOnVector(a, b) {\n  var v = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().crossVectors(a, b);\n  var c = a.dot(b);\n  var i = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix3().identity(); //  skew-symmetric cross-product matrix of 𝑣 https://en.wikipedia.org/wiki/Skew-symmetric_matrix\n  // prettier-ignore\n\n  var vx = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix3().set(0, -v.z, v.y, v.z, 0, -v.x, -v.y, v.x, 0);\n  var vxsquared = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix3().multiplyMatrices(vx, vx).multiplyScalar(1 / (1 + c));\n\n  var _final = (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)((0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(i, vx), vxsquared);\n\n  return _final;\n} // calculate latitude and longitude (in radians) from point on unit sphere\n\nfunction pointToCoordinate(x, y, z) {\n  var lat = Math.asin(y);\n  var lon = Math.atan2(x, -z);\n  return [lat, lon];\n} // calculate point on unit sphere given latitude and logitude in radians\n\nfunction coordinateToPoint(lat, lon) {\n  var y = Math.sin(lat);\n  var r = Math.cos(lat);\n  var x = Math.sin(lon) * r;\n  var z = -Math.cos(lon) * r;\n  return [x, y, z];\n}\n/**\n * Given a plane and a segment, return the intersection point if it exists or null it doesn't.\n */\n\nfunction planeSegmentIntersection(plane, segment) {\n  var _segment = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(segment, 2),\n      a = _segment[0],\n      b = _segment[1];\n\n  var matrix = rotateVectorOnVector(plane.normal, new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0));\n  var t = inverseLerp(a.clone().applyMatrix3(matrix).y, b.clone().applyMatrix3(matrix).y, 0);\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().lerpVectors(a, b, t);\n}\n/**\n * Given a plane and a point, return the distance.\n */\n\nfunction pointToPlaneDistance(p, plane) {\n  var d = plane.normal.dot(p); // TODO\n\n  return d;\n}\nfunction getIndexFrom3D(coords, sides) {\n  var _coords = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(coords, 3),\n      ix = _coords[0],\n      iy = _coords[1],\n      iz = _coords[2];\n\n  var _sides = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(sides, 2),\n      rx = _sides[0],\n      ry = _sides[1];\n\n  return iz * rx * ry + iy * rx + ix;\n}\nfunction get3DFromIndex(index, size) {\n  var _size = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(size, 2),\n      rx = _size[0],\n      ry = _size[1];\n\n  var a = rx * ry;\n  var z = index / a;\n  var b = index - a * z;\n  var y = b / rx;\n  var x = b % rx;\n  return [x, y, z];\n}\nfunction getIndexFrom2D(coords, size) {\n  return coords[0] + size[0] * coords[1];\n}\nfunction get2DFromIndex(index, columns) {\n  var x = index % columns;\n  var y = Math.floor(index / columns);\n  return [x, y];\n}\n\nvar misc = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clamp: clamp,\n  repeat: repeat,\n  deltaAngle: deltaAngle,\n  degToRad: degToRad,\n  radToDeg: radToDeg,\n  fibonacciOnSphere: fibonacciOnSphere,\n  vectorEquals: vectorEquals,\n  lexicographic: lexicographic,\n  convexHull: convexHull,\n  remap: remap,\n  fade: fade,\n  lerp: lerp,\n  inverseLerp: inverseLerp,\n  normalize: normalize,\n  pointOnCubeToPointOnSphere: pointOnCubeToPointOnSphere,\n  rotateVectorOnVector: rotateVectorOnVector,\n  pointToCoordinate: pointToCoordinate,\n  coordinateToPoint: coordinateToPoint,\n  planeSegmentIntersection: planeSegmentIntersection,\n  pointToPlaneDistance: pointToPlaneDistance,\n  getIndexFrom3D: getIndexFrom3D,\n  get3DFromIndex: get3DFromIndex,\n  getIndexFrom2D: getIndexFrom2D,\n  get2DFromIndex: get2DFromIndex\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9taXNjLTE5YTNlYzQ2LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdIO0FBQy9FO0FBQ2tCOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDOzs7QUFHNUMsdUNBQXVDOztBQUV2QyxrQkFBa0IsbUJBQW1CO0FBQ3JDLDRCQUE0Qjs7QUFFNUIsZ0NBQWdDLDREQUF1QixDQUFDLDREQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSix1RUFBdUU7O0FBRXZFLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0EsNkJBQTZCOztBQUU3QixnQ0FBZ0MsNERBQXVCLENBQUMsNERBQWtCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNERBQWM7QUFDNUI7QUFDQTs7QUFFQSxjQUFjLDREQUFjO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsMENBQU87QUFDckI7QUFDQSxjQUFjLDBDQUFPLGVBQWU7QUFDcEM7O0FBRUEsZUFBZSwwQ0FBTztBQUN0QixzQkFBc0IsMENBQU87O0FBRTdCLGVBQWUsMERBQVUsQ0FBQywwREFBVTs7QUFFcEM7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw0REFBYztBQUMvQjtBQUNBOztBQUVBLHNEQUFzRCwwQ0FBTztBQUM3RDtBQUNBLGFBQWEsMENBQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBYztBQUM5QjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSw0REFBYztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNERBQWM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRTBlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9taXNjLTE5YTNlYzQ2LmVzbS5qcz9jZTg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGQgYXMgZG9UaHJlZVBvaW50c01ha2VBUmlnaHQsIGEgYXMgX3RvQ29uc3VtYWJsZUFycmF5LCBfIGFzIF9zbGljZWRUb0FycmF5IH0gZnJvbSAnLi90cmlhbmdsZS1iNjJiOTA2Ny5lc20uanMnO1xuaW1wb3J0IHsgVmVjdG9yMywgTWF0cml4MyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IGEgYXMgbWF0cml4U3VtMyB9IGZyb20gJy4vbWF0cml4LWJhYTUzMGJmLmVzbS5qcyc7XG5cbi8qKlxuICogQ2xhbXBzIGEgdmFsdWUgYmV0d2VlbiBhIHJhbmdlLlxuICovXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufSAvLyBMb29wcyB0aGUgdmFsdWUgdCwgc28gdGhhdCBpdCBpcyBuZXZlciBsYXJnZXIgdGhhbiBsZW5ndGggYW5kIG5ldmVyIHNtYWxsZXIgdGhhbiAwLlxuXG5mdW5jdGlvbiByZXBlYXQodCwgbGVuZ3RoKSB7XG4gIHJldHVybiBjbGFtcCh0IC0gTWF0aC5mbG9vcih0IC8gbGVuZ3RoKSAqIGxlbmd0aCwgMCwgbGVuZ3RoKTtcbn0gLy8gQ2FsY3VsYXRlcyB0aGUgc2hvcnRlc3QgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBnaXZlbiBhbmdsZXMuXG5cbmZ1bmN0aW9uIGRlbHRhQW5nbGUoY3VycmVudCwgdGFyZ2V0KSB7XG4gIHZhciBkZWx0YSA9IHJlcGVhdCh0YXJnZXQgLSBjdXJyZW50LCBNYXRoLlBJICogMik7XG4gIGlmIChkZWx0YSA+IE1hdGguUEkpIGRlbHRhIC09IE1hdGguUEkgKiAyO1xuICByZXR1cm4gZGVsdGE7XG59XG4vKipcbiAqIENvbnZlcnRzIGRlZ3JlZXMgdG8gcmFkaWFucy5cbiAqL1xuXG5mdW5jdGlvbiBkZWdUb1JhZChkZWdyZWVzKSB7XG4gIHJldHVybiBkZWdyZWVzIC8gMTgwICogTWF0aC5QSTtcbn1cbi8qKlxuICogQ29udmVydHMgcmFkaWFucyB0byBkZWdyZWVzLlxuICovXG5cbmZ1bmN0aW9uIHJhZFRvRGVnKHJhZGlhbnMpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAxODAgLyBNYXRoLlBJO1xufSAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc3RlcGhhbmJvZ25lci9hNWY1MDU0OGEwNmJlYzcyM2RjYjA5OTFkY2JiMDg1NiBieSBodHRwczovL3R3aXR0ZXIuY29tL3N0X3BoYW5cblxuZnVuY3Rpb24gZmlib25hY2NpT25TcGhlcmUoYnVmZmVyLCBfcmVmKSB7XG4gIHZhciBfcmVmJHJhZGl1cyA9IF9yZWYucmFkaXVzLFxuICAgICAgcmFkaXVzID0gX3JlZiRyYWRpdXMgPT09IHZvaWQgMCA/IDEgOiBfcmVmJHJhZGl1cztcbiAgdmFyIHNhbXBsZXMgPSBidWZmZXIubGVuZ3RoIC8gMztcbiAgdmFyIG9mZnNldCA9IDIgLyBzYW1wbGVzO1xuICB2YXIgaW5jcmVtZW50ID0gTWF0aC5QSSAqICgzIC0gMi4yMzYwNjc5Nzc1KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMykge1xuICAgIHZhciB5ID0gaSAqIG9mZnNldCAtIDEgKyBvZmZzZXQgLyAyO1xuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydCgxIC0gTWF0aC5wb3coeSwgMikpO1xuICAgIHZhciBwaGkgPSBpICUgc2FtcGxlcyAqIGluY3JlbWVudDtcbiAgICB2YXIgeCA9IE1hdGguY29zKHBoaSkgKiBkaXN0YW5jZTtcbiAgICB2YXIgeiA9IE1hdGguc2luKHBoaSkgKiBkaXN0YW5jZTtcbiAgICBidWZmZXJbaV0gPSB4ICogcmFkaXVzO1xuICAgIGJ1ZmZlcltpICsgMV0gPSB5ICogcmFkaXVzO1xuICAgIGJ1ZmZlcltpICsgMl0gPSB6ICogcmFkaXVzO1xuICB9XG59IC8vIEB0cy1pZ25vcmVcblxuZnVuY3Rpb24gdmVjdG9yRXF1YWxzKGEsIGIpIHtcbiAgdmFyIGVwcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogTnVtYmVyLkVQU0lMT047XG4gIHJldHVybiBNYXRoLmFicyhhLnggLSBiLngpIDwgZXBzICYmIE1hdGguYWJzKGEueSAtIGIueSkgPCBlcHMgJiYgTWF0aC5hYnMoYS56IC0gYi56KSA8IGVwcztcbn1cbi8qKlxuICogU29ydHMgdmVjdG9ycyBpbiBsZXhpY29ncmFwaGljIG9yZGVyLCB3b3JrcyB3aXRoIGJvdGggdjIgYW5kIHYzXG4gKlxuICogIFVzZSBhczpcbiAqICBjb25zdCBzb3J0ZWQgPSBhcnJheU9mVmVjdG9ycy5zb3J0KGxleGljb2dyYXBoaWNPcmRlcilcbiAqL1xuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV4aWNvZ3JhcGhpY19vcmRlclxuXG5mdW5jdGlvbiBsZXhpY29ncmFwaGljKGEsIGIpIHtcbiAgaWYgKGEueCA9PT0gYi54KSB7XG4gICAgLy8gZG8gYSBjaGVjayB0byBzZWUgaWYgcG9pbnRzIGlzIDNELFxuICAgIC8vIGluIHdoaWNoIGNhc2UgYWRkIHkgZXEgY2hlY2sgYW5kIHNvcnQgYnkgelxuICAgIGlmICh0eXBlb2YgYS56ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoYS55ID09PSBiLnkpIHtcbiAgICAgICAgcmV0dXJuIGEueiAtIGIuejtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYS55IC0gYi55O1xuICB9XG5cbiAgcmV0dXJuIGEueCAtIGIueDtcbn1cbi8qKlxuICogQ29udmV4IEh1bGxcbiAqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIDJEIFZlY3RvcnMgcmVwcmVzZW50aW5nIHRoZSBjb252ZXggaHVsbCBvZiBhIHNldCBvZiAyRCBWZWN0b3JzXG4gKi9cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGNvbnZleCBodWxsIG9mIGEgc2V0IG9mIHBvaW50c1xuICovXG5cbmZ1bmN0aW9uIGNvbnZleEh1bGwoX3BvaW50cykge1xuICB2YXIgcG9pbnRzID0gX3BvaW50cy5zb3J0KGxleGljb2dyYXBoaWMpOyAvLyBwdXQgcDEgYW5kIHAyIGluIGEgbGlzdCBsVXBwZXIgd2l0aCBwMSBhcyB0aGUgZmlyc3QgcG9pbnRcblxuXG4gIHZhciBsVXBwZXIgPSBbcG9pbnRzWzBdLCBwb2ludHNbMV1dOyAvLyBmb3IgaSA8LSAzIHRvIG5cblxuICBmb3IgKHZhciBpID0gMjsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGxVcHBlci5wdXNoKHBvaW50c1tpXSk7IC8vIHdoaWxlIGxVcHBlciBjb250YWlucyBtb3JlIHRoYW4gMiBwb2ludHMgYW5kIHRoZSBsYXN0IHRocmVlIHBvaW50cyBpbiBsVXBwZXIgZG8gbm90IG1ha2UgYSByaWdodCB0dXJuXG5cbiAgICB3aGlsZSAobFVwcGVyLmxlbmd0aCA+IDIgJiYgZG9UaHJlZVBvaW50c01ha2VBUmlnaHQoX3RvQ29uc3VtYWJsZUFycmF5KGxVcHBlci5zbGljZSgtMykpKSkge1xuICAgICAgLy8gZGVsZXRlIHRoZSBtaWRkbGUgb2YgdGhlIGxhc3QgdGhyZWUgcG9pbnRzIGZyb20gbFVwcGVyXG4gICAgICBsVXBwZXIuc3BsaWNlKGxVcHBlci5sZW5ndGggLSAyLCAxKTtcbiAgICB9XG4gIH0gLy8gcHV0IHBuIGFuZCBwbi0xIGluIGEgbGlzdCBsTG93ZXIgd2l0aCBwbiBhcyB0aGUgZmlyc3QgcG9pbnRcblxuXG4gIHZhciBsTG93ZXIgPSBbcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXV07IC8vIGZvciAoaSA8LSBuIC0gMiBkb3dudG8gMSlcblxuICBmb3IgKHZhciBfaSA9IHBvaW50cy5sZW5ndGggLSAzOyBfaSA+PSAwOyBfaS0tKSB7XG4gICAgLy8gYXBwZW5kIHBpIHRvIGxMb3dlclxuICAgIGxMb3dlci5wdXNoKHBvaW50c1tfaV0pOyAvLyB3aGlsZSBsTG93ZXIgY29udGFpbnMgbW9yZSB0aGFuIDIgcG9pbnRzIGFuZCB0aGUgbGFzdCB0aHJlZSBwb2ludHMgaW4gbExvd2VyIGRvIG5vdCBtYWtlIGEgcmlnaHQgdHVyblxuXG4gICAgd2hpbGUgKGxMb3dlci5sZW5ndGggPiAyICYmIGRvVGhyZWVQb2ludHNNYWtlQVJpZ2h0KF90b0NvbnN1bWFibGVBcnJheShsTG93ZXIuc2xpY2UoLTMpKSkpIHtcbiAgICAgIC8vIGRlbGV0ZSB0aGUgbWlkZGxlIG9mIHRoZSBsYXN0IHRocmVlIHBvaW50cyBmcm9tIGxMb3dlclxuICAgICAgbExvd2VyLnNwbGljZShsTG93ZXIubGVuZ3RoIC0gMiwgMSk7XG4gICAgfVxuICB9IC8vIHJlbW92ZSB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnQgZnJvbSBsTG93ZXIgdG8gYXZvaWQgZHVwbGljYXRpb24gb2YgdGhlIHBvaW50cyB3aGVyZSB0aGUgdXBwZXIgYW5kIGxvd2VyIGh1bGwgbWVldFxuXG5cbiAgbExvd2VyLnNwbGljZSgwLCAxKTtcbiAgbExvd2VyLnNwbGljZShsTG93ZXIubGVuZ3RoIC0gMSwgMSk7IC8vIHByZXR0aWVyLWlnbm9yZVxuXG4gIHZhciBjID0gW10uY29uY2F0KGxVcHBlciwgbExvd2VyKTtcbiAgcmV0dXJuIGM7XG59XG5mdW5jdGlvbiByZW1hcCh4LCBfcmVmMiwgX3JlZjMpIHtcbiAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIsIDIpLFxuICAgICAgbG93MSA9IF9yZWY0WzBdLFxuICAgICAgaGlnaDEgPSBfcmVmNFsxXTtcblxuICB2YXIgX3JlZjUgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICBsb3cyID0gX3JlZjVbMF0sXG4gICAgICBoaWdoMiA9IF9yZWY1WzFdO1xuXG4gIHJldHVybiBsb3cyICsgKHggLSBsb3cxKSAqIChoaWdoMiAtIGxvdzIpIC8gKGhpZ2gxIC0gbG93MSk7XG59XG4vKipcbiAqXG4gKiBodHRwczovL3d3dy5kZXNtb3MuY29tL2NhbGN1bGF0b3IvdnNubWxhbGpkdVxuICpcbiAqIEVhc2UtaW4tb3V0LCBnb2VzIHRvIC1JbmZpbml0ZSBiZWZvcmUgMCBhbmQgSW5maW5pdGUgYWZ0ZXIgMVxuICpcbiAqIEBwYXJhbSB0XG4gKiBAcmV0dXJuc1xuICovXG5cbmZ1bmN0aW9uIGZhZGUodCkge1xuICByZXR1cm4gdCAqIHQgKiB0ICogKHQgKiAodCAqIDYgLSAxNSkgKyAxMCk7XG59XG4vKipcbiAqXG4gKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbGluZWFybHkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIGlucHV0IEEgYW5kIGlucHV0IEIgYnkgaW5wdXQgVC5cbiAqXG4gKiBAcGFyYW0gdjBcbiAqIEBwYXJhbSB2MVxuICogQHBhcmFtIHRcbiAqIEByZXR1cm5zXG4gKi9cblxuZnVuY3Rpb24gbGVycCh2MCwgdjEsIHQpIHtcbiAgcmV0dXJuIHYwICogKDEgLSB0KSArIHYxICogdDtcbn1cbi8qKlxuICpcbiAqIFJldHVybnMgdGhlIGxpbmVhciBwYXJhbWV0ZXIgdGhhdCBwcm9kdWNlcyB0aGUgaW50ZXJwb2xhbnQgc3BlY2lmaWVkIGJ5IGlucHV0IFQgd2l0aGluIHRoZSByYW5nZSBvZiBpbnB1dCBBIHRvIGlucHV0IEIuXG4gKlxuICogQHBhcmFtIHYwXG4gKiBAcGFyYW0gdjFcbiAqIEBwYXJhbSB0XG4gKiBAcmV0dXJuc1xuICovXG5cbmZ1bmN0aW9uIGludmVyc2VMZXJwKHYwLCB2MSwgdCkge1xuICByZXR1cm4gKHQgLSB2MCkgLyAodjEgLSB2MCk7XG59XG4vKipcbiAqXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplKHgsIHksIHopIHtcbiAgdmFyIG0gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgcmV0dXJuIFt4IC8gbSwgeSAvIG0sIHogLyBtXTtcbn1cbi8qKlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwb2ludE9uQ3ViZVRvUG9pbnRPblNwaGVyZSh4LCB5LCB6KSB7XG4gIHZhciB4MiA9IHggKiB4O1xuICB2YXIgeTIgPSB5ICogeTtcbiAgdmFyIHoyID0geiAqIHo7XG4gIHZhciBueCA9IHggKiBNYXRoLnNxcnQoMSAtICh5MiArIHoyKSAvIDIgKyB5MiAqIHoyIC8gMyk7XG4gIHZhciBueSA9IHkgKiBNYXRoLnNxcnQoMSAtICh6MiArIHgyKSAvIDIgKyB6MiAqIHgyIC8gMyk7XG4gIHZhciBueiA9IHogKiBNYXRoLnNxcnQoMSAtICh4MiArIHkyKSAvIDIgKyB4MiAqIHkyIC8gMyk7XG4gIHJldHVybiBbbngsIG55LCBuel07XG59IC8vIGh0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTgwNDE4L2NhbGN1bGF0ZS1yb3RhdGlvbi1tYXRyaXgtdG8tYWxpZ24tdmVjdG9yLWEtdG8tdmVjdG9yLWItaW4tM2RcblxuLyoqXG4gKiBHaXZlIHR3byB1bml0IHZlY3RvcnMgYSBhbmQgYiwgcmV0dXJucyB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRoYXQgcm90YXRlcyBhIG9udG8gYi5cbiAqXG4gKiAqL1xuXG5mdW5jdGlvbiByb3RhdGVWZWN0b3JPblZlY3RvcihhLCBiKSB7XG4gIHZhciB2ID0gbmV3IFZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMoYSwgYik7XG4gIHZhciBjID0gYS5kb3QoYik7XG4gIHZhciBpID0gbmV3IE1hdHJpeDMoKS5pZGVudGl0eSgpOyAvLyAgc2tldy1zeW1tZXRyaWMgY3Jvc3MtcHJvZHVjdCBtYXRyaXggb2Yg8J2RoyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ta2V3LXN5bW1ldHJpY19tYXRyaXhcbiAgLy8gcHJldHRpZXItaWdub3JlXG5cbiAgdmFyIHZ4ID0gbmV3IE1hdHJpeDMoKS5zZXQoMCwgLXYueiwgdi55LCB2LnosIDAsIC12LngsIC12LnksIHYueCwgMCk7XG4gIHZhciB2eHNxdWFyZWQgPSBuZXcgTWF0cml4MygpLm11bHRpcGx5TWF0cmljZXModngsIHZ4KS5tdWx0aXBseVNjYWxhcigxIC8gKDEgKyBjKSk7XG5cbiAgdmFyIF9maW5hbCA9IG1hdHJpeFN1bTMobWF0cml4U3VtMyhpLCB2eCksIHZ4c3F1YXJlZCk7XG5cbiAgcmV0dXJuIF9maW5hbDtcbn0gLy8gY2FsY3VsYXRlIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGluIHJhZGlhbnMpIGZyb20gcG9pbnQgb24gdW5pdCBzcGhlcmVcblxuZnVuY3Rpb24gcG9pbnRUb0Nvb3JkaW5hdGUoeCwgeSwgeikge1xuICB2YXIgbGF0ID0gTWF0aC5hc2luKHkpO1xuICB2YXIgbG9uID0gTWF0aC5hdGFuMih4LCAteik7XG4gIHJldHVybiBbbGF0LCBsb25dO1xufSAvLyBjYWxjdWxhdGUgcG9pbnQgb24gdW5pdCBzcGhlcmUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvZ2l0dWRlIGluIHJhZGlhbnNcblxuZnVuY3Rpb24gY29vcmRpbmF0ZVRvUG9pbnQobGF0LCBsb24pIHtcbiAgdmFyIHkgPSBNYXRoLnNpbihsYXQpO1xuICB2YXIgciA9IE1hdGguY29zKGxhdCk7XG4gIHZhciB4ID0gTWF0aC5zaW4obG9uKSAqIHI7XG4gIHZhciB6ID0gLU1hdGguY29zKGxvbikgKiByO1xuICByZXR1cm4gW3gsIHksIHpdO1xufVxuLyoqXG4gKiBHaXZlbiBhIHBsYW5lIGFuZCBhIHNlZ21lbnQsIHJldHVybiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGlmIGl0IGV4aXN0cyBvciBudWxsIGl0IGRvZXNuJ3QuXG4gKi9cblxuZnVuY3Rpb24gcGxhbmVTZWdtZW50SW50ZXJzZWN0aW9uKHBsYW5lLCBzZWdtZW50KSB7XG4gIHZhciBfc2VnbWVudCA9IF9zbGljZWRUb0FycmF5KHNlZ21lbnQsIDIpLFxuICAgICAgYSA9IF9zZWdtZW50WzBdLFxuICAgICAgYiA9IF9zZWdtZW50WzFdO1xuXG4gIHZhciBtYXRyaXggPSByb3RhdGVWZWN0b3JPblZlY3RvcihwbGFuZS5ub3JtYWwsIG5ldyBWZWN0b3IzKDAsIDEsIDApKTtcbiAgdmFyIHQgPSBpbnZlcnNlTGVycChhLmNsb25lKCkuYXBwbHlNYXRyaXgzKG1hdHJpeCkueSwgYi5jbG9uZSgpLmFwcGx5TWF0cml4MyhtYXRyaXgpLnksIDApO1xuICByZXR1cm4gbmV3IFZlY3RvcjMoKS5sZXJwVmVjdG9ycyhhLCBiLCB0KTtcbn1cbi8qKlxuICogR2l2ZW4gYSBwbGFuZSBhbmQgYSBwb2ludCwgcmV0dXJuIHRoZSBkaXN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBwb2ludFRvUGxhbmVEaXN0YW5jZShwLCBwbGFuZSkge1xuICB2YXIgZCA9IHBsYW5lLm5vcm1hbC5kb3QocCk7IC8vIFRPRE9cblxuICByZXR1cm4gZDtcbn1cbmZ1bmN0aW9uIGdldEluZGV4RnJvbTNEKGNvb3Jkcywgc2lkZXMpIHtcbiAgdmFyIF9jb29yZHMgPSBfc2xpY2VkVG9BcnJheShjb29yZHMsIDMpLFxuICAgICAgaXggPSBfY29vcmRzWzBdLFxuICAgICAgaXkgPSBfY29vcmRzWzFdLFxuICAgICAgaXogPSBfY29vcmRzWzJdO1xuXG4gIHZhciBfc2lkZXMgPSBfc2xpY2VkVG9BcnJheShzaWRlcywgMiksXG4gICAgICByeCA9IF9zaWRlc1swXSxcbiAgICAgIHJ5ID0gX3NpZGVzWzFdO1xuXG4gIHJldHVybiBpeiAqIHJ4ICogcnkgKyBpeSAqIHJ4ICsgaXg7XG59XG5mdW5jdGlvbiBnZXQzREZyb21JbmRleChpbmRleCwgc2l6ZSkge1xuICB2YXIgX3NpemUgPSBfc2xpY2VkVG9BcnJheShzaXplLCAyKSxcbiAgICAgIHJ4ID0gX3NpemVbMF0sXG4gICAgICByeSA9IF9zaXplWzFdO1xuXG4gIHZhciBhID0gcnggKiByeTtcbiAgdmFyIHogPSBpbmRleCAvIGE7XG4gIHZhciBiID0gaW5kZXggLSBhICogejtcbiAgdmFyIHkgPSBiIC8gcng7XG4gIHZhciB4ID0gYiAlIHJ4O1xuICByZXR1cm4gW3gsIHksIHpdO1xufVxuZnVuY3Rpb24gZ2V0SW5kZXhGcm9tMkQoY29vcmRzLCBzaXplKSB7XG4gIHJldHVybiBjb29yZHNbMF0gKyBzaXplWzBdICogY29vcmRzWzFdO1xufVxuZnVuY3Rpb24gZ2V0MkRGcm9tSW5kZXgoaW5kZXgsIGNvbHVtbnMpIHtcbiAgdmFyIHggPSBpbmRleCAlIGNvbHVtbnM7XG4gIHZhciB5ID0gTWF0aC5mbG9vcihpbmRleCAvIGNvbHVtbnMpO1xuICByZXR1cm4gW3gsIHldO1xufVxuXG52YXIgbWlzYyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjbGFtcDogY2xhbXAsXG4gIHJlcGVhdDogcmVwZWF0LFxuICBkZWx0YUFuZ2xlOiBkZWx0YUFuZ2xlLFxuICBkZWdUb1JhZDogZGVnVG9SYWQsXG4gIHJhZFRvRGVnOiByYWRUb0RlZyxcbiAgZmlib25hY2NpT25TcGhlcmU6IGZpYm9uYWNjaU9uU3BoZXJlLFxuICB2ZWN0b3JFcXVhbHM6IHZlY3RvckVxdWFscyxcbiAgbGV4aWNvZ3JhcGhpYzogbGV4aWNvZ3JhcGhpYyxcbiAgY29udmV4SHVsbDogY29udmV4SHVsbCxcbiAgcmVtYXA6IHJlbWFwLFxuICBmYWRlOiBmYWRlLFxuICBsZXJwOiBsZXJwLFxuICBpbnZlcnNlTGVycDogaW52ZXJzZUxlcnAsXG4gIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuICBwb2ludE9uQ3ViZVRvUG9pbnRPblNwaGVyZTogcG9pbnRPbkN1YmVUb1BvaW50T25TcGhlcmUsXG4gIHJvdGF0ZVZlY3Rvck9uVmVjdG9yOiByb3RhdGVWZWN0b3JPblZlY3RvcixcbiAgcG9pbnRUb0Nvb3JkaW5hdGU6IHBvaW50VG9Db29yZGluYXRlLFxuICBjb29yZGluYXRlVG9Qb2ludDogY29vcmRpbmF0ZVRvUG9pbnQsXG4gIHBsYW5lU2VnbWVudEludGVyc2VjdGlvbjogcGxhbmVTZWdtZW50SW50ZXJzZWN0aW9uLFxuICBwb2ludFRvUGxhbmVEaXN0YW5jZTogcG9pbnRUb1BsYW5lRGlzdGFuY2UsXG4gIGdldEluZGV4RnJvbTNEOiBnZXRJbmRleEZyb20zRCxcbiAgZ2V0M0RGcm9tSW5kZXg6IGdldDNERnJvbUluZGV4LFxuICBnZXRJbmRleEZyb20yRDogZ2V0SW5kZXhGcm9tMkQsXG4gIGdldDJERnJvbUluZGV4OiBnZXQyREZyb21JbmRleFxufSk7XG5cbmV4cG9ydCB7IGRlZ1RvUmFkIGFzIGEsIHJhZFRvRGVnIGFzIGIsIGNsYW1wIGFzIGMsIGRlbHRhQW5nbGUgYXMgZCwgZmlib25hY2NpT25TcGhlcmUgYXMgZSwgZmFkZSBhcyBmLCBsZXhpY29ncmFwaGljIGFzIGcsIGNvbnZleEh1bGwgYXMgaCwgcmVtYXAgYXMgaSwgaW52ZXJzZUxlcnAgYXMgaiwgcm90YXRlVmVjdG9yT25WZWN0b3IgYXMgaywgbGVycCBhcyBsLCBtaXNjIGFzIG0sIG5vcm1hbGl6ZSBhcyBuLCBwb2ludFRvQ29vcmRpbmF0ZSBhcyBvLCBwb2ludE9uQ3ViZVRvUG9pbnRPblNwaGVyZSBhcyBwLCBjb29yZGluYXRlVG9Qb2ludCBhcyBxLCByZXBlYXQgYXMgciwgcGxhbmVTZWdtZW50SW50ZXJzZWN0aW9uIGFzIHMsIHBvaW50VG9QbGFuZURpc3RhbmNlIGFzIHQsIGdldEluZGV4RnJvbTNEIGFzIHUsIHZlY3RvckVxdWFscyBhcyB2LCBnZXQzREZyb21JbmRleCBhcyB3LCBnZXRJbmRleEZyb20yRCBhcyB4LCBnZXQyREZyb21JbmRleCBhcyB5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/misc-19a3ec46.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/misc-fce4d494.cjs.dev.js":
/*!**********************************************************!*\
  !*** ./node_modules/maath/dist/misc-fce4d494.cjs.dev.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar triangle_dist_maathTriangle = __webpack_require__(/*! ./triangle-33ffdfef.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/triangle-33ffdfef.cjs.dev.js\");\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\nvar matrix_dist_maathMatrix = __webpack_require__(/*! ./matrix-fb190f60.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/matrix-fb190f60.cjs.dev.js\");\n\n/**\n * Clamps a value between a range.\n */\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n} // Loops the value t, so that it is never larger than length and never smaller than 0.\n\nfunction repeat(t, length) {\n  return clamp(t - Math.floor(t / length) * length, 0, length);\n} // Calculates the shortest difference between two given angles.\n\nfunction deltaAngle(current, target) {\n  var delta = repeat(target - current, Math.PI * 2);\n  if (delta > Math.PI) delta -= Math.PI * 2;\n  return delta;\n}\n/**\n * Converts degrees to radians.\n */\n\nfunction degToRad(degrees) {\n  return degrees / 180 * Math.PI;\n}\n/**\n * Converts radians to degrees.\n */\n\nfunction radToDeg(radians) {\n  return radians * 180 / Math.PI;\n} // adapted from https://gist.github.com/stephanbogner/a5f50548a06bec723dcb0991dcbb0856 by https://twitter.com/st_phan\n\nfunction fibonacciOnSphere(buffer, _ref) {\n  var _ref$radius = _ref.radius,\n      radius = _ref$radius === void 0 ? 1 : _ref$radius;\n  var samples = buffer.length / 3;\n  var offset = 2 / samples;\n  var increment = Math.PI * (3 - 2.2360679775);\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    var y = i * offset - 1 + offset / 2;\n    var distance = Math.sqrt(1 - Math.pow(y, 2));\n    var phi = i % samples * increment;\n    var x = Math.cos(phi) * distance;\n    var z = Math.sin(phi) * distance;\n    buffer[i] = x * radius;\n    buffer[i + 1] = y * radius;\n    buffer[i + 2] = z * radius;\n  }\n} // @ts-ignore\n\nfunction vectorEquals(a, b) {\n  var eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.EPSILON;\n  return Math.abs(a.x - b.x) < eps && Math.abs(a.y - b.y) < eps && Math.abs(a.z - b.z) < eps;\n}\n/**\n * Sorts vectors in lexicographic order, works with both v2 and v3\n *\n *  Use as:\n *  const sorted = arrayOfVectors.sort(lexicographicOrder)\n */\n// https://en.wikipedia.org/wiki/Lexicographic_order\n\nfunction lexicographic(a, b) {\n  if (a.x === b.x) {\n    // do a check to see if points is 3D,\n    // in which case add y eq check and sort by z\n    if (typeof a.z !== \"undefined\") {\n      if (a.y === b.y) {\n        return a.z - b.z;\n      }\n    }\n\n    return a.y - b.y;\n  }\n\n  return a.x - b.x;\n}\n/**\n * Convex Hull\n *\n * Returns an array of 2D Vectors representing the convex hull of a set of 2D Vectors\n */\n\n/**\n * Calculate the convex hull of a set of points\n */\n\nfunction convexHull(_points) {\n  var points = _points.sort(lexicographic); // put p1 and p2 in a list lUpper with p1 as the first point\n\n\n  var lUpper = [points[0], points[1]]; // for i <- 3 to n\n\n  for (var i = 2; i < points.length; i++) {\n    lUpper.push(points[i]); // while lUpper contains more than 2 points and the last three points in lUpper do not make a right turn\n\n    while (lUpper.length > 2 && triangle_dist_maathTriangle.doThreePointsMakeARight(triangle_dist_maathTriangle._toConsumableArray(lUpper.slice(-3)))) {\n      // delete the middle of the last three points from lUpper\n      lUpper.splice(lUpper.length - 2, 1);\n    }\n  } // put pn and pn-1 in a list lLower with pn as the first point\n\n\n  var lLower = [points[points.length - 1], points[points.length - 2]]; // for (i <- n - 2 downto 1)\n\n  for (var _i = points.length - 3; _i >= 0; _i--) {\n    // append pi to lLower\n    lLower.push(points[_i]); // while lLower contains more than 2 points and the last three points in lLower do not make a right turn\n\n    while (lLower.length > 2 && triangle_dist_maathTriangle.doThreePointsMakeARight(triangle_dist_maathTriangle._toConsumableArray(lLower.slice(-3)))) {\n      // delete the middle of the last three points from lLower\n      lLower.splice(lLower.length - 2, 1);\n    }\n  } // remove the first and last point from lLower to avoid duplication of the points where the upper and lower hull meet\n\n\n  lLower.splice(0, 1);\n  lLower.splice(lLower.length - 1, 1); // prettier-ignore\n\n  var c = [].concat(lUpper, lLower);\n  return c;\n}\nfunction remap(x, _ref2, _ref3) {\n  var _ref4 = triangle_dist_maathTriangle._slicedToArray(_ref2, 2),\n      low1 = _ref4[0],\n      high1 = _ref4[1];\n\n  var _ref5 = triangle_dist_maathTriangle._slicedToArray(_ref3, 2),\n      low2 = _ref5[0],\n      high2 = _ref5[1];\n\n  return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n/**\n *\n * https://www.desmos.com/calculator/vsnmlaljdu\n *\n * Ease-in-out, goes to -Infinite before 0 and Infinite after 1\n *\n * @param t\n * @returns\n */\n\nfunction fade(t) {\n  return t * t * t * (t * (t * 6 - 15) + 10);\n}\n/**\n *\n * Returns the result of linearly interpolating between input A and input B by input T.\n *\n * @param v0\n * @param v1\n * @param t\n * @returns\n */\n\nfunction lerp(v0, v1, t) {\n  return v0 * (1 - t) + v1 * t;\n}\n/**\n *\n * Returns the linear parameter that produces the interpolant specified by input T within the range of input A to input B.\n *\n * @param v0\n * @param v1\n * @param t\n * @returns\n */\n\nfunction inverseLerp(v0, v1, t) {\n  return (t - v0) / (v1 - v0);\n}\n/**\n *\n */\n\nfunction normalize(x, y, z) {\n  var m = Math.sqrt(x * x + y * y + z * z);\n  return [x / m, y / m, z / m];\n}\n/**\n *\n */\n\nfunction pointOnCubeToPointOnSphere(x, y, z) {\n  var x2 = x * x;\n  var y2 = y * y;\n  var z2 = z * z;\n  var nx = x * Math.sqrt(1 - (y2 + z2) / 2 + y2 * z2 / 3);\n  var ny = y * Math.sqrt(1 - (z2 + x2) / 2 + z2 * x2 / 3);\n  var nz = z * Math.sqrt(1 - (x2 + y2) / 2 + x2 * y2 / 3);\n  return [nx, ny, nz];\n} // https://math.stackexchange.com/questions/180418/calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d\n\n/**\n * Give two unit vectors a and b, returns the transformation matrix that rotates a onto b.\n *\n * */\n\nfunction rotateVectorOnVector(a, b) {\n  var v = new THREE.Vector3().crossVectors(a, b);\n  var c = a.dot(b);\n  var i = new THREE.Matrix3().identity(); //  skew-symmetric cross-product matrix of 𝑣 https://en.wikipedia.org/wiki/Skew-symmetric_matrix\n  // prettier-ignore\n\n  var vx = new THREE.Matrix3().set(0, -v.z, v.y, v.z, 0, -v.x, -v.y, v.x, 0);\n  var vxsquared = new THREE.Matrix3().multiplyMatrices(vx, vx).multiplyScalar(1 / (1 + c));\n\n  var _final = matrix_dist_maathMatrix.matrixSum3(matrix_dist_maathMatrix.matrixSum3(i, vx), vxsquared);\n\n  return _final;\n} // calculate latitude and longitude (in radians) from point on unit sphere\n\nfunction pointToCoordinate(x, y, z) {\n  var lat = Math.asin(y);\n  var lon = Math.atan2(x, -z);\n  return [lat, lon];\n} // calculate point on unit sphere given latitude and logitude in radians\n\nfunction coordinateToPoint(lat, lon) {\n  var y = Math.sin(lat);\n  var r = Math.cos(lat);\n  var x = Math.sin(lon) * r;\n  var z = -Math.cos(lon) * r;\n  return [x, y, z];\n}\n/**\n * Given a plane and a segment, return the intersection point if it exists or null it doesn't.\n */\n\nfunction planeSegmentIntersection(plane, segment) {\n  var _segment = triangle_dist_maathTriangle._slicedToArray(segment, 2),\n      a = _segment[0],\n      b = _segment[1];\n\n  var matrix = rotateVectorOnVector(plane.normal, new THREE.Vector3(0, 1, 0));\n  var t = inverseLerp(a.clone().applyMatrix3(matrix).y, b.clone().applyMatrix3(matrix).y, 0);\n  return new THREE.Vector3().lerpVectors(a, b, t);\n}\n/**\n * Given a plane and a point, return the distance.\n */\n\nfunction pointToPlaneDistance(p, plane) {\n  var d = plane.normal.dot(p); // TODO\n\n  return d;\n}\nfunction getIndexFrom3D(coords, sides) {\n  var _coords = triangle_dist_maathTriangle._slicedToArray(coords, 3),\n      ix = _coords[0],\n      iy = _coords[1],\n      iz = _coords[2];\n\n  var _sides = triangle_dist_maathTriangle._slicedToArray(sides, 2),\n      rx = _sides[0],\n      ry = _sides[1];\n\n  return iz * rx * ry + iy * rx + ix;\n}\nfunction get3DFromIndex(index, size) {\n  var _size = triangle_dist_maathTriangle._slicedToArray(size, 2),\n      rx = _size[0],\n      ry = _size[1];\n\n  var a = rx * ry;\n  var z = index / a;\n  var b = index - a * z;\n  var y = b / rx;\n  var x = b % rx;\n  return [x, y, z];\n}\nfunction getIndexFrom2D(coords, size) {\n  return coords[0] + size[0] * coords[1];\n}\nfunction get2DFromIndex(index, columns) {\n  var x = index % columns;\n  var y = Math.floor(index / columns);\n  return [x, y];\n}\n\nvar misc = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clamp: clamp,\n  repeat: repeat,\n  deltaAngle: deltaAngle,\n  degToRad: degToRad,\n  radToDeg: radToDeg,\n  fibonacciOnSphere: fibonacciOnSphere,\n  vectorEquals: vectorEquals,\n  lexicographic: lexicographic,\n  convexHull: convexHull,\n  remap: remap,\n  fade: fade,\n  lerp: lerp,\n  inverseLerp: inverseLerp,\n  normalize: normalize,\n  pointOnCubeToPointOnSphere: pointOnCubeToPointOnSphere,\n  rotateVectorOnVector: rotateVectorOnVector,\n  pointToCoordinate: pointToCoordinate,\n  coordinateToPoint: coordinateToPoint,\n  planeSegmentIntersection: planeSegmentIntersection,\n  pointToPlaneDistance: pointToPlaneDistance,\n  getIndexFrom3D: getIndexFrom3D,\n  get3DFromIndex: get3DFromIndex,\n  getIndexFrom2D: getIndexFrom2D,\n  get2DFromIndex: get2DFromIndex\n});\n\nexports.clamp = clamp;\nexports.convexHull = convexHull;\nexports.coordinateToPoint = coordinateToPoint;\nexports.degToRad = degToRad;\nexports.deltaAngle = deltaAngle;\nexports.fade = fade;\nexports.fibonacciOnSphere = fibonacciOnSphere;\nexports.get2DFromIndex = get2DFromIndex;\nexports.get3DFromIndex = get3DFromIndex;\nexports.getIndexFrom2D = getIndexFrom2D;\nexports.getIndexFrom3D = getIndexFrom3D;\nexports.inverseLerp = inverseLerp;\nexports.lerp = lerp;\nexports.lexicographic = lexicographic;\nexports.misc = misc;\nexports.normalize = normalize;\nexports.planeSegmentIntersection = planeSegmentIntersection;\nexports.pointOnCubeToPointOnSphere = pointOnCubeToPointOnSphere;\nexports.pointToCoordinate = pointToCoordinate;\nexports.pointToPlaneDistance = pointToPlaneDistance;\nexports.radToDeg = radToDeg;\nexports.remap = remap;\nexports.repeat = repeat;\nexports.rotateVectorOnVector = rotateVectorOnVector;\nexports.vectorEquals = vectorEquals;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9taXNjLWZjZTRkNDk0LmNqcy5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0NBQWtDLG1CQUFPLENBQUMsb0dBQWdDO0FBQzFFLFlBQVksbUJBQU8sQ0FBQyx5REFBTztBQUMzQiw4QkFBOEIsbUJBQU8sQ0FBQyxnR0FBOEI7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7OztBQUc1Qyx1Q0FBdUM7O0FBRXZDLGtCQUFrQixtQkFBbUI7QUFDckMsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKLHVFQUF1RTs7QUFFdkUsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGFBQWE7QUFDYixrQkFBa0I7QUFDbEIseUJBQXlCO0FBQ3pCLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLFlBQVk7QUFDWixxQkFBcUI7QUFDckIsWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixjQUFjO0FBQ2QsNEJBQTRCO0FBQzVCLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYWNlcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvbWlzYy1mY2U0ZDQ5NC5janMuZGV2LmpzPzAxZmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJpYW5nbGVfZGlzdF9tYWF0aFRyaWFuZ2xlID0gcmVxdWlyZSgnLi90cmlhbmdsZS0zM2ZmZGZlZi5janMuZGV2LmpzJyk7XG52YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpO1xudmFyIG1hdHJpeF9kaXN0X21hYXRoTWF0cml4ID0gcmVxdWlyZSgnLi9tYXRyaXgtZmIxOTBmNjAuY2pzLmRldi5qcycpO1xuXG4vKipcbiAqIENsYW1wcyBhIHZhbHVlIGJldHdlZW4gYSByYW5nZS5cbiAqL1xuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn0gLy8gTG9vcHMgdGhlIHZhbHVlIHQsIHNvIHRoYXQgaXQgaXMgbmV2ZXIgbGFyZ2VyIHRoYW4gbGVuZ3RoIGFuZCBuZXZlciBzbWFsbGVyIHRoYW4gMC5cblxuZnVuY3Rpb24gcmVwZWF0KHQsIGxlbmd0aCkge1xuICByZXR1cm4gY2xhbXAodCAtIE1hdGguZmxvb3IodCAvIGxlbmd0aCkgKiBsZW5ndGgsIDAsIGxlbmd0aCk7XG59IC8vIENhbGN1bGF0ZXMgdGhlIHNob3J0ZXN0IGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gZ2l2ZW4gYW5nbGVzLlxuXG5mdW5jdGlvbiBkZWx0YUFuZ2xlKGN1cnJlbnQsIHRhcmdldCkge1xuICB2YXIgZGVsdGEgPSByZXBlYXQodGFyZ2V0IC0gY3VycmVudCwgTWF0aC5QSSAqIDIpO1xuICBpZiAoZGVsdGEgPiBNYXRoLlBJKSBkZWx0YSAtPSBNYXRoLlBJICogMjtcbiAgcmV0dXJuIGRlbHRhO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gKi9cblxuZnVuY3Rpb24gZGVnVG9SYWQoZGVncmVlcykge1xuICByZXR1cm4gZGVncmVlcyAvIDE4MCAqIE1hdGguUEk7XG59XG4vKipcbiAqIENvbnZlcnRzIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAqL1xuXG5mdW5jdGlvbiByYWRUb0RlZyhyYWRpYW5zKSB7XG4gIHJldHVybiByYWRpYW5zICogMTgwIC8gTWF0aC5QSTtcbn0gLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N0ZXBoYW5ib2duZXIvYTVmNTA1NDhhMDZiZWM3MjNkY2IwOTkxZGNiYjA4NTYgYnkgaHR0cHM6Ly90d2l0dGVyLmNvbS9zdF9waGFuXG5cbmZ1bmN0aW9uIGZpYm9uYWNjaU9uU3BoZXJlKGJ1ZmZlciwgX3JlZikge1xuICB2YXIgX3JlZiRyYWRpdXMgPSBfcmVmLnJhZGl1cyxcbiAgICAgIHJhZGl1cyA9IF9yZWYkcmFkaXVzID09PSB2b2lkIDAgPyAxIDogX3JlZiRyYWRpdXM7XG4gIHZhciBzYW1wbGVzID0gYnVmZmVyLmxlbmd0aCAvIDM7XG4gIHZhciBvZmZzZXQgPSAyIC8gc2FtcGxlcztcbiAgdmFyIGluY3JlbWVudCA9IE1hdGguUEkgKiAoMyAtIDIuMjM2MDY3OTc3NSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICB2YXIgeSA9IGkgKiBvZmZzZXQgLSAxICsgb2Zmc2V0IC8gMjtcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoMSAtIE1hdGgucG93KHksIDIpKTtcbiAgICB2YXIgcGhpID0gaSAlIHNhbXBsZXMgKiBpbmNyZW1lbnQ7XG4gICAgdmFyIHggPSBNYXRoLmNvcyhwaGkpICogZGlzdGFuY2U7XG4gICAgdmFyIHogPSBNYXRoLnNpbihwaGkpICogZGlzdGFuY2U7XG4gICAgYnVmZmVyW2ldID0geCAqIHJhZGl1cztcbiAgICBidWZmZXJbaSArIDFdID0geSAqIHJhZGl1cztcbiAgICBidWZmZXJbaSArIDJdID0geiAqIHJhZGl1cztcbiAgfVxufSAvLyBAdHMtaWdub3JlXG5cbmZ1bmN0aW9uIHZlY3RvckVxdWFscyhhLCBiKSB7XG4gIHZhciBlcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IE51bWJlci5FUFNJTE9OO1xuICByZXR1cm4gTWF0aC5hYnMoYS54IC0gYi54KSA8IGVwcyAmJiBNYXRoLmFicyhhLnkgLSBiLnkpIDwgZXBzICYmIE1hdGguYWJzKGEueiAtIGIueikgPCBlcHM7XG59XG4vKipcbiAqIFNvcnRzIHZlY3RvcnMgaW4gbGV4aWNvZ3JhcGhpYyBvcmRlciwgd29ya3Mgd2l0aCBib3RoIHYyIGFuZCB2M1xuICpcbiAqICBVc2UgYXM6XG4gKiAgY29uc3Qgc29ydGVkID0gYXJyYXlPZlZlY3RvcnMuc29ydChsZXhpY29ncmFwaGljT3JkZXIpXG4gKi9cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xleGljb2dyYXBoaWNfb3JkZXJcblxuZnVuY3Rpb24gbGV4aWNvZ3JhcGhpYyhhLCBiKSB7XG4gIGlmIChhLnggPT09IGIueCkge1xuICAgIC8vIGRvIGEgY2hlY2sgdG8gc2VlIGlmIHBvaW50cyBpcyAzRCxcbiAgICAvLyBpbiB3aGljaCBjYXNlIGFkZCB5IGVxIGNoZWNrIGFuZCBzb3J0IGJ5IHpcbiAgICBpZiAodHlwZW9mIGEueiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGEueSA9PT0gYi55KSB7XG4gICAgICAgIHJldHVybiBhLnogLSBiLno7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGEueSAtIGIueTtcbiAgfVxuXG4gIHJldHVybiBhLnggLSBiLng7XG59XG4vKipcbiAqIENvbnZleCBIdWxsXG4gKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiAyRCBWZWN0b3JzIHJlcHJlc2VudGluZyB0aGUgY29udmV4IGh1bGwgb2YgYSBzZXQgb2YgMkQgVmVjdG9yc1xuICovXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBjb252ZXggaHVsbCBvZiBhIHNldCBvZiBwb2ludHNcbiAqL1xuXG5mdW5jdGlvbiBjb252ZXhIdWxsKF9wb2ludHMpIHtcbiAgdmFyIHBvaW50cyA9IF9wb2ludHMuc29ydChsZXhpY29ncmFwaGljKTsgLy8gcHV0IHAxIGFuZCBwMiBpbiBhIGxpc3QgbFVwcGVyIHdpdGggcDEgYXMgdGhlIGZpcnN0IHBvaW50XG5cblxuICB2YXIgbFVwcGVyID0gW3BvaW50c1swXSwgcG9pbnRzWzFdXTsgLy8gZm9yIGkgPC0gMyB0byBuXG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBsVXBwZXIucHVzaChwb2ludHNbaV0pOyAvLyB3aGlsZSBsVXBwZXIgY29udGFpbnMgbW9yZSB0aGFuIDIgcG9pbnRzIGFuZCB0aGUgbGFzdCB0aHJlZSBwb2ludHMgaW4gbFVwcGVyIGRvIG5vdCBtYWtlIGEgcmlnaHQgdHVyblxuXG4gICAgd2hpbGUgKGxVcHBlci5sZW5ndGggPiAyICYmIHRyaWFuZ2xlX2Rpc3RfbWFhdGhUcmlhbmdsZS5kb1RocmVlUG9pbnRzTWFrZUFSaWdodCh0cmlhbmdsZV9kaXN0X21hYXRoVHJpYW5nbGUuX3RvQ29uc3VtYWJsZUFycmF5KGxVcHBlci5zbGljZSgtMykpKSkge1xuICAgICAgLy8gZGVsZXRlIHRoZSBtaWRkbGUgb2YgdGhlIGxhc3QgdGhyZWUgcG9pbnRzIGZyb20gbFVwcGVyXG4gICAgICBsVXBwZXIuc3BsaWNlKGxVcHBlci5sZW5ndGggLSAyLCAxKTtcbiAgICB9XG4gIH0gLy8gcHV0IHBuIGFuZCBwbi0xIGluIGEgbGlzdCBsTG93ZXIgd2l0aCBwbiBhcyB0aGUgZmlyc3QgcG9pbnRcblxuXG4gIHZhciBsTG93ZXIgPSBbcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXV07IC8vIGZvciAoaSA8LSBuIC0gMiBkb3dudG8gMSlcblxuICBmb3IgKHZhciBfaSA9IHBvaW50cy5sZW5ndGggLSAzOyBfaSA+PSAwOyBfaS0tKSB7XG4gICAgLy8gYXBwZW5kIHBpIHRvIGxMb3dlclxuICAgIGxMb3dlci5wdXNoKHBvaW50c1tfaV0pOyAvLyB3aGlsZSBsTG93ZXIgY29udGFpbnMgbW9yZSB0aGFuIDIgcG9pbnRzIGFuZCB0aGUgbGFzdCB0aHJlZSBwb2ludHMgaW4gbExvd2VyIGRvIG5vdCBtYWtlIGEgcmlnaHQgdHVyblxuXG4gICAgd2hpbGUgKGxMb3dlci5sZW5ndGggPiAyICYmIHRyaWFuZ2xlX2Rpc3RfbWFhdGhUcmlhbmdsZS5kb1RocmVlUG9pbnRzTWFrZUFSaWdodCh0cmlhbmdsZV9kaXN0X21hYXRoVHJpYW5nbGUuX3RvQ29uc3VtYWJsZUFycmF5KGxMb3dlci5zbGljZSgtMykpKSkge1xuICAgICAgLy8gZGVsZXRlIHRoZSBtaWRkbGUgb2YgdGhlIGxhc3QgdGhyZWUgcG9pbnRzIGZyb20gbExvd2VyXG4gICAgICBsTG93ZXIuc3BsaWNlKGxMb3dlci5sZW5ndGggLSAyLCAxKTtcbiAgICB9XG4gIH0gLy8gcmVtb3ZlIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludCBmcm9tIGxMb3dlciB0byBhdm9pZCBkdXBsaWNhdGlvbiBvZiB0aGUgcG9pbnRzIHdoZXJlIHRoZSB1cHBlciBhbmQgbG93ZXIgaHVsbCBtZWV0XG5cblxuICBsTG93ZXIuc3BsaWNlKDAsIDEpO1xuICBsTG93ZXIuc3BsaWNlKGxMb3dlci5sZW5ndGggLSAxLCAxKTsgLy8gcHJldHRpZXItaWdub3JlXG5cbiAgdmFyIGMgPSBbXS5jb25jYXQobFVwcGVyLCBsTG93ZXIpO1xuICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIHJlbWFwKHgsIF9yZWYyLCBfcmVmMykge1xuICB2YXIgX3JlZjQgPSB0cmlhbmdsZV9kaXN0X21hYXRoVHJpYW5nbGUuX3NsaWNlZFRvQXJyYXkoX3JlZjIsIDIpLFxuICAgICAgbG93MSA9IF9yZWY0WzBdLFxuICAgICAgaGlnaDEgPSBfcmVmNFsxXTtcblxuICB2YXIgX3JlZjUgPSB0cmlhbmdsZV9kaXN0X21hYXRoVHJpYW5nbGUuX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgbG93MiA9IF9yZWY1WzBdLFxuICAgICAgaGlnaDIgPSBfcmVmNVsxXTtcblxuICByZXR1cm4gbG93MiArICh4IC0gbG93MSkgKiAoaGlnaDIgLSBsb3cyKSAvIChoaWdoMSAtIGxvdzEpO1xufVxuLyoqXG4gKlxuICogaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3Zzbm1sYWxqZHVcbiAqXG4gKiBFYXNlLWluLW91dCwgZ29lcyB0byAtSW5maW5pdGUgYmVmb3JlIDAgYW5kIEluZmluaXRlIGFmdGVyIDFcbiAqXG4gKiBAcGFyYW0gdFxuICogQHJldHVybnNcbiAqL1xuXG5mdW5jdGlvbiBmYWRlKHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdCAqICh0ICogKHQgKiA2IC0gMTUpICsgMTApO1xufVxuLyoqXG4gKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGxpbmVhcmx5IGludGVycG9sYXRpbmcgYmV0d2VlbiBpbnB1dCBBIGFuZCBpbnB1dCBCIGJ5IGlucHV0IFQuXG4gKlxuICogQHBhcmFtIHYwXG4gKiBAcGFyYW0gdjFcbiAqIEBwYXJhbSB0XG4gKiBAcmV0dXJuc1xuICovXG5cbmZ1bmN0aW9uIGxlcnAodjAsIHYxLCB0KSB7XG4gIHJldHVybiB2MCAqICgxIC0gdCkgKyB2MSAqIHQ7XG59XG4vKipcbiAqXG4gKiBSZXR1cm5zIHRoZSBsaW5lYXIgcGFyYW1ldGVyIHRoYXQgcHJvZHVjZXMgdGhlIGludGVycG9sYW50IHNwZWNpZmllZCBieSBpbnB1dCBUIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgaW5wdXQgQSB0byBpbnB1dCBCLlxuICpcbiAqIEBwYXJhbSB2MFxuICogQHBhcmFtIHYxXG4gKiBAcGFyYW0gdFxuICogQHJldHVybnNcbiAqL1xuXG5mdW5jdGlvbiBpbnZlcnNlTGVycCh2MCwgdjEsIHQpIHtcbiAgcmV0dXJuICh0IC0gdjApIC8gKHYxIC0gdjApO1xufVxuLyoqXG4gKlxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh4LCB5LCB6KSB7XG4gIHZhciBtID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHJldHVybiBbeCAvIG0sIHkgLyBtLCB6IC8gbV07XG59XG4vKipcbiAqXG4gKi9cblxuZnVuY3Rpb24gcG9pbnRPbkN1YmVUb1BvaW50T25TcGhlcmUoeCwgeSwgeikge1xuICB2YXIgeDIgPSB4ICogeDtcbiAgdmFyIHkyID0geSAqIHk7XG4gIHZhciB6MiA9IHogKiB6O1xuICB2YXIgbnggPSB4ICogTWF0aC5zcXJ0KDEgLSAoeTIgKyB6MikgLyAyICsgeTIgKiB6MiAvIDMpO1xuICB2YXIgbnkgPSB5ICogTWF0aC5zcXJ0KDEgLSAoejIgKyB4MikgLyAyICsgejIgKiB4MiAvIDMpO1xuICB2YXIgbnogPSB6ICogTWF0aC5zcXJ0KDEgLSAoeDIgKyB5MikgLyAyICsgeDIgKiB5MiAvIDMpO1xuICByZXR1cm4gW254LCBueSwgbnpdO1xufSAvLyBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE4MDQxOC9jYWxjdWxhdGUtcm90YXRpb24tbWF0cml4LXRvLWFsaWduLXZlY3Rvci1hLXRvLXZlY3Rvci1iLWluLTNkXG5cbi8qKlxuICogR2l2ZSB0d28gdW5pdCB2ZWN0b3JzIGEgYW5kIGIsIHJldHVybnMgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0aGF0IHJvdGF0ZXMgYSBvbnRvIGIuXG4gKlxuICogKi9cblxuZnVuY3Rpb24gcm90YXRlVmVjdG9yT25WZWN0b3IoYSwgYikge1xuICB2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKGEsIGIpO1xuICB2YXIgYyA9IGEuZG90KGIpO1xuICB2YXIgaSA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuaWRlbnRpdHkoKTsgLy8gIHNrZXctc3ltbWV0cmljIGNyb3NzLXByb2R1Y3QgbWF0cml4IG9mIPCdkaMgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2tldy1zeW1tZXRyaWNfbWF0cml4XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuXG4gIHZhciB2eCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuc2V0KDAsIC12LnosIHYueSwgdi56LCAwLCAtdi54LCAtdi55LCB2LngsIDApO1xuICB2YXIgdnhzcXVhcmVkID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5tdWx0aXBseU1hdHJpY2VzKHZ4LCB2eCkubXVsdGlwbHlTY2FsYXIoMSAvICgxICsgYykpO1xuXG4gIHZhciBfZmluYWwgPSBtYXRyaXhfZGlzdF9tYWF0aE1hdHJpeC5tYXRyaXhTdW0zKG1hdHJpeF9kaXN0X21hYXRoTWF0cml4Lm1hdHJpeFN1bTMoaSwgdngpLCB2eHNxdWFyZWQpO1xuXG4gIHJldHVybiBfZmluYWw7XG59IC8vIGNhbGN1bGF0ZSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChpbiByYWRpYW5zKSBmcm9tIHBvaW50IG9uIHVuaXQgc3BoZXJlXG5cbmZ1bmN0aW9uIHBvaW50VG9Db29yZGluYXRlKHgsIHksIHopIHtcbiAgdmFyIGxhdCA9IE1hdGguYXNpbih5KTtcbiAgdmFyIGxvbiA9IE1hdGguYXRhbjIoeCwgLXopO1xuICByZXR1cm4gW2xhdCwgbG9uXTtcbn0gLy8gY2FsY3VsYXRlIHBvaW50IG9uIHVuaXQgc3BoZXJlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb2dpdHVkZSBpbiByYWRpYW5zXG5cbmZ1bmN0aW9uIGNvb3JkaW5hdGVUb1BvaW50KGxhdCwgbG9uKSB7XG4gIHZhciB5ID0gTWF0aC5zaW4obGF0KTtcbiAgdmFyIHIgPSBNYXRoLmNvcyhsYXQpO1xuICB2YXIgeCA9IE1hdGguc2luKGxvbikgKiByO1xuICB2YXIgeiA9IC1NYXRoLmNvcyhsb24pICogcjtcbiAgcmV0dXJuIFt4LCB5LCB6XTtcbn1cbi8qKlxuICogR2l2ZW4gYSBwbGFuZSBhbmQgYSBzZWdtZW50LCByZXR1cm4gdGhlIGludGVyc2VjdGlvbiBwb2ludCBpZiBpdCBleGlzdHMgb3IgbnVsbCBpdCBkb2Vzbid0LlxuICovXG5cbmZ1bmN0aW9uIHBsYW5lU2VnbWVudEludGVyc2VjdGlvbihwbGFuZSwgc2VnbWVudCkge1xuICB2YXIgX3NlZ21lbnQgPSB0cmlhbmdsZV9kaXN0X21hYXRoVHJpYW5nbGUuX3NsaWNlZFRvQXJyYXkoc2VnbWVudCwgMiksXG4gICAgICBhID0gX3NlZ21lbnRbMF0sXG4gICAgICBiID0gX3NlZ21lbnRbMV07XG5cbiAgdmFyIG1hdHJpeCA9IHJvdGF0ZVZlY3Rvck9uVmVjdG9yKHBsYW5lLm5vcm1hbCwgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCkpO1xuICB2YXIgdCA9IGludmVyc2VMZXJwKGEuY2xvbmUoKS5hcHBseU1hdHJpeDMobWF0cml4KS55LCBiLmNsb25lKCkuYXBwbHlNYXRyaXgzKG1hdHJpeCkueSwgMCk7XG4gIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMygpLmxlcnBWZWN0b3JzKGEsIGIsIHQpO1xufVxuLyoqXG4gKiBHaXZlbiBhIHBsYW5lIGFuZCBhIHBvaW50LCByZXR1cm4gdGhlIGRpc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIHBvaW50VG9QbGFuZURpc3RhbmNlKHAsIHBsYW5lKSB7XG4gIHZhciBkID0gcGxhbmUubm9ybWFsLmRvdChwKTsgLy8gVE9ET1xuXG4gIHJldHVybiBkO1xufVxuZnVuY3Rpb24gZ2V0SW5kZXhGcm9tM0QoY29vcmRzLCBzaWRlcykge1xuICB2YXIgX2Nvb3JkcyA9IHRyaWFuZ2xlX2Rpc3RfbWFhdGhUcmlhbmdsZS5fc2xpY2VkVG9BcnJheShjb29yZHMsIDMpLFxuICAgICAgaXggPSBfY29vcmRzWzBdLFxuICAgICAgaXkgPSBfY29vcmRzWzFdLFxuICAgICAgaXogPSBfY29vcmRzWzJdO1xuXG4gIHZhciBfc2lkZXMgPSB0cmlhbmdsZV9kaXN0X21hYXRoVHJpYW5nbGUuX3NsaWNlZFRvQXJyYXkoc2lkZXMsIDIpLFxuICAgICAgcnggPSBfc2lkZXNbMF0sXG4gICAgICByeSA9IF9zaWRlc1sxXTtcblxuICByZXR1cm4gaXogKiByeCAqIHJ5ICsgaXkgKiByeCArIGl4O1xufVxuZnVuY3Rpb24gZ2V0M0RGcm9tSW5kZXgoaW5kZXgsIHNpemUpIHtcbiAgdmFyIF9zaXplID0gdHJpYW5nbGVfZGlzdF9tYWF0aFRyaWFuZ2xlLl9zbGljZWRUb0FycmF5KHNpemUsIDIpLFxuICAgICAgcnggPSBfc2l6ZVswXSxcbiAgICAgIHJ5ID0gX3NpemVbMV07XG5cbiAgdmFyIGEgPSByeCAqIHJ5O1xuICB2YXIgeiA9IGluZGV4IC8gYTtcbiAgdmFyIGIgPSBpbmRleCAtIGEgKiB6O1xuICB2YXIgeSA9IGIgLyByeDtcbiAgdmFyIHggPSBiICUgcng7XG4gIHJldHVybiBbeCwgeSwgel07XG59XG5mdW5jdGlvbiBnZXRJbmRleEZyb20yRChjb29yZHMsIHNpemUpIHtcbiAgcmV0dXJuIGNvb3Jkc1swXSArIHNpemVbMF0gKiBjb29yZHNbMV07XG59XG5mdW5jdGlvbiBnZXQyREZyb21JbmRleChpbmRleCwgY29sdW1ucykge1xuICB2YXIgeCA9IGluZGV4ICUgY29sdW1ucztcbiAgdmFyIHkgPSBNYXRoLmZsb29yKGluZGV4IC8gY29sdW1ucyk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbnZhciBtaXNjID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNsYW1wOiBjbGFtcCxcbiAgcmVwZWF0OiByZXBlYXQsXG4gIGRlbHRhQW5nbGU6IGRlbHRhQW5nbGUsXG4gIGRlZ1RvUmFkOiBkZWdUb1JhZCxcbiAgcmFkVG9EZWc6IHJhZFRvRGVnLFxuICBmaWJvbmFjY2lPblNwaGVyZTogZmlib25hY2NpT25TcGhlcmUsXG4gIHZlY3RvckVxdWFsczogdmVjdG9yRXF1YWxzLFxuICBsZXhpY29ncmFwaGljOiBsZXhpY29ncmFwaGljLFxuICBjb252ZXhIdWxsOiBjb252ZXhIdWxsLFxuICByZW1hcDogcmVtYXAsXG4gIGZhZGU6IGZhZGUsXG4gIGxlcnA6IGxlcnAsXG4gIGludmVyc2VMZXJwOiBpbnZlcnNlTGVycCxcbiAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gIHBvaW50T25DdWJlVG9Qb2ludE9uU3BoZXJlOiBwb2ludE9uQ3ViZVRvUG9pbnRPblNwaGVyZSxcbiAgcm90YXRlVmVjdG9yT25WZWN0b3I6IHJvdGF0ZVZlY3Rvck9uVmVjdG9yLFxuICBwb2ludFRvQ29vcmRpbmF0ZTogcG9pbnRUb0Nvb3JkaW5hdGUsXG4gIGNvb3JkaW5hdGVUb1BvaW50OiBjb29yZGluYXRlVG9Qb2ludCxcbiAgcGxhbmVTZWdtZW50SW50ZXJzZWN0aW9uOiBwbGFuZVNlZ21lbnRJbnRlcnNlY3Rpb24sXG4gIHBvaW50VG9QbGFuZURpc3RhbmNlOiBwb2ludFRvUGxhbmVEaXN0YW5jZSxcbiAgZ2V0SW5kZXhGcm9tM0Q6IGdldEluZGV4RnJvbTNELFxuICBnZXQzREZyb21JbmRleDogZ2V0M0RGcm9tSW5kZXgsXG4gIGdldEluZGV4RnJvbTJEOiBnZXRJbmRleEZyb20yRCxcbiAgZ2V0MkRGcm9tSW5kZXg6IGdldDJERnJvbUluZGV4XG59KTtcblxuZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xuZXhwb3J0cy5jb252ZXhIdWxsID0gY29udmV4SHVsbDtcbmV4cG9ydHMuY29vcmRpbmF0ZVRvUG9pbnQgPSBjb29yZGluYXRlVG9Qb2ludDtcbmV4cG9ydHMuZGVnVG9SYWQgPSBkZWdUb1JhZDtcbmV4cG9ydHMuZGVsdGFBbmdsZSA9IGRlbHRhQW5nbGU7XG5leHBvcnRzLmZhZGUgPSBmYWRlO1xuZXhwb3J0cy5maWJvbmFjY2lPblNwaGVyZSA9IGZpYm9uYWNjaU9uU3BoZXJlO1xuZXhwb3J0cy5nZXQyREZyb21JbmRleCA9IGdldDJERnJvbUluZGV4O1xuZXhwb3J0cy5nZXQzREZyb21JbmRleCA9IGdldDNERnJvbUluZGV4O1xuZXhwb3J0cy5nZXRJbmRleEZyb20yRCA9IGdldEluZGV4RnJvbTJEO1xuZXhwb3J0cy5nZXRJbmRleEZyb20zRCA9IGdldEluZGV4RnJvbTNEO1xuZXhwb3J0cy5pbnZlcnNlTGVycCA9IGludmVyc2VMZXJwO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMubGV4aWNvZ3JhcGhpYyA9IGxleGljb2dyYXBoaWM7XG5leHBvcnRzLm1pc2MgPSBtaXNjO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLnBsYW5lU2VnbWVudEludGVyc2VjdGlvbiA9IHBsYW5lU2VnbWVudEludGVyc2VjdGlvbjtcbmV4cG9ydHMucG9pbnRPbkN1YmVUb1BvaW50T25TcGhlcmUgPSBwb2ludE9uQ3ViZVRvUG9pbnRPblNwaGVyZTtcbmV4cG9ydHMucG9pbnRUb0Nvb3JkaW5hdGUgPSBwb2ludFRvQ29vcmRpbmF0ZTtcbmV4cG9ydHMucG9pbnRUb1BsYW5lRGlzdGFuY2UgPSBwb2ludFRvUGxhbmVEaXN0YW5jZTtcbmV4cG9ydHMucmFkVG9EZWcgPSByYWRUb0RlZztcbmV4cG9ydHMucmVtYXAgPSByZW1hcDtcbmV4cG9ydHMucmVwZWF0ID0gcmVwZWF0O1xuZXhwb3J0cy5yb3RhdGVWZWN0b3JPblZlY3RvciA9IHJvdGF0ZVZlY3Rvck9uVmVjdG9yO1xuZXhwb3J0cy52ZWN0b3JFcXVhbHMgPSB2ZWN0b3JFcXVhbHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/misc-fce4d494.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/objectSpread2-284232a6.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/maath/dist/objectSpread2-284232a6.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _objectSpread2),\n/* harmony export */   a: () => (/* binding */ _defineProperty)\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9vYmplY3RTcHJlYWQyLTI4NDIzMmE2LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9vYmplY3RTcHJlYWQyLTI4NDIzMmE2LmVzbS5qcz81OTNlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG5cbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHtcbiAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgeyBfb2JqZWN0U3ByZWFkMiBhcyBfLCBfZGVmaW5lUHJvcGVydHkgYXMgYSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/objectSpread2-284232a6.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/objectSpread2-32cd2c34.cjs.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/maath/dist/objectSpread2-32cd2c34.cjs.dev.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nexports._defineProperty = _defineProperty;\nexports._objectSpread2 = _objectSpread2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9vYmplY3RTcHJlYWQyLTMyY2QyYzM0LmNqcy5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsc0JBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9vYmplY3RTcHJlYWQyLTMyY2QyYzM0LmNqcy5kZXYuanM/NjE2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG5cbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHtcbiAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnRzLl9kZWZpbmVQcm9wZXJ0eSA9IF9kZWZpbmVQcm9wZXJ0eTtcbmV4cG9ydHMuX29iamVjdFNwcmVhZDIgPSBfb2JqZWN0U3ByZWFkMjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/objectSpread2-32cd2c34.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/three-87cc244e.cjs.dev.js":
/*!***********************************************************!*\
  !*** ./node_modules/maath/dist/three-87cc244e.cjs.dev.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\n\n/**\n * Helpers for converting buffers to and from Three.js objects\n */\n\n/**\n * Convents passed buffer of passed stride to an array of vectors with the correct length.\n *\n * @param buffer\n * @param stride\n * @returns\n */\nfunction bufferToVectors(buffer) {\n  var stride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  var p = [];\n\n  for (var i = 0, j = 0; i < buffer.length; i += stride, j++) {\n    if (stride === 3) {\n      p[j] = new THREE.Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);\n    } else {\n      p[j] = new THREE.Vector2(buffer[i], buffer[i + 1]);\n    }\n  }\n\n  return p;\n}\n/**\n * Transforms a passed Vector2 or Vector3 array to a points buffer\n *\n * @param vectorArray\n * @returns\n */\n\nfunction vectorsToBuffer(vectorArray) {\n  var l = vectorArray.length;\n  var stride = vectorArray[0].hasOwnProperty(\"z\") ? 3 : 2;\n  var buffer = new Float32Array(l * stride);\n\n  for (var i = 0; i < l; i++) {\n    var j = i * stride;\n    buffer[j] = vectorArray[i].x;\n    buffer[j + 1] = vectorArray[i].y;\n\n    if (stride === 3) {\n      buffer[j + 2] = vectorArray[i].z;\n    }\n  }\n\n  return buffer;\n}\n\nvar three = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  bufferToVectors: bufferToVectors,\n  vectorsToBuffer: vectorsToBuffer\n});\n\nexports.bufferToVectors = bufferToVectors;\nexports.three = three;\nexports.vectorsToBuffer = vectorsToBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC90aHJlZS04N2NjMjQ0ZS5janMuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx5REFBTzs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsdUJBQXVCO0FBQ3ZCLGFBQWE7QUFDYix1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9tYWF0aC9kaXN0L3RocmVlLTg3Y2MyNDRlLmNqcy5kZXYuanM/YzI4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBUSFJFRSA9IHJlcXVpcmUoJ3RocmVlJyk7XG5cbi8qKlxuICogSGVscGVycyBmb3IgY29udmVydGluZyBidWZmZXJzIHRvIGFuZCBmcm9tIFRocmVlLmpzIG9iamVjdHNcbiAqL1xuXG4vKipcbiAqIENvbnZlbnRzIHBhc3NlZCBidWZmZXIgb2YgcGFzc2VkIHN0cmlkZSB0byBhbiBhcnJheSBvZiB2ZWN0b3JzIHdpdGggdGhlIGNvcnJlY3QgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSBidWZmZXJcbiAqIEBwYXJhbSBzdHJpZGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvVmVjdG9ycyhidWZmZXIpIHtcbiAgdmFyIHN0cmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMztcbiAgdmFyIHAgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IHN0cmlkZSwgaisrKSB7XG4gICAgaWYgKHN0cmlkZSA9PT0gMykge1xuICAgICAgcFtqXSA9IG5ldyBUSFJFRS5WZWN0b3IzKGJ1ZmZlcltpXSwgYnVmZmVyW2kgKyAxXSwgYnVmZmVyW2kgKyAyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBbal0gPSBuZXcgVEhSRUUuVmVjdG9yMihidWZmZXJbaV0sIGJ1ZmZlcltpICsgMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgcGFzc2VkIFZlY3RvcjIgb3IgVmVjdG9yMyBhcnJheSB0byBhIHBvaW50cyBidWZmZXJcbiAqXG4gKiBAcGFyYW0gdmVjdG9yQXJyYXlcbiAqIEByZXR1cm5zXG4gKi9cblxuZnVuY3Rpb24gdmVjdG9yc1RvQnVmZmVyKHZlY3RvckFycmF5KSB7XG4gIHZhciBsID0gdmVjdG9yQXJyYXkubGVuZ3RoO1xuICB2YXIgc3RyaWRlID0gdmVjdG9yQXJyYXlbMF0uaGFzT3duUHJvcGVydHkoXCJ6XCIpID8gMyA6IDI7XG4gIHZhciBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGwgKiBzdHJpZGUpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGogPSBpICogc3RyaWRlO1xuICAgIGJ1ZmZlcltqXSA9IHZlY3RvckFycmF5W2ldLng7XG4gICAgYnVmZmVyW2ogKyAxXSA9IHZlY3RvckFycmF5W2ldLnk7XG5cbiAgICBpZiAoc3RyaWRlID09PSAzKSB7XG4gICAgICBidWZmZXJbaiArIDJdID0gdmVjdG9yQXJyYXlbaV0uejtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufVxuXG52YXIgdGhyZWUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYnVmZmVyVG9WZWN0b3JzOiBidWZmZXJUb1ZlY3RvcnMsXG4gIHZlY3RvcnNUb0J1ZmZlcjogdmVjdG9yc1RvQnVmZmVyXG59KTtcblxuZXhwb3J0cy5idWZmZXJUb1ZlY3RvcnMgPSBidWZmZXJUb1ZlY3RvcnM7XG5leHBvcnRzLnRocmVlID0gdGhyZWU7XG5leHBvcnRzLnZlY3RvcnNUb0J1ZmZlciA9IHZlY3RvcnNUb0J1ZmZlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/three-87cc244e.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/triangle-33ffdfef.cjs.dev.js":
/*!**************************************************************!*\
  !*** ./node_modules/maath/dist/triangle-33ffdfef.cjs.dev.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct-ddc4ebc1.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/isNativeReflectConstruct-ddc4ebc1.cjs.dev.js\");\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\nvar matrix_dist_maathMatrix = __webpack_require__(/*! ./matrix-fb190f60.cjs.dev.js */ \"(ssr)/./node_modules/maath/dist/matrix-fb190f60.cjs.dev.js\");\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct._isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) isNativeReflectConstruct._setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\n/**\n *\n * @param point\n *\n * @param triangle\n *\n * @returns {boolean} true if the point is in the triangle\n *\n * TODO: Find explainer\n */\nfunction isPointInTriangle(point, triangle) {\n  var _triangle$ = _slicedToArray(triangle[0], 2),\n      ax = _triangle$[0],\n      ay = _triangle$[1];\n\n  var _triangle$2 = _slicedToArray(triangle[1], 2),\n      bx = _triangle$2[0],\n      by = _triangle$2[1];\n\n  var _triangle$3 = _slicedToArray(triangle[2], 2),\n      cx = _triangle$3[0],\n      cy = _triangle$3[1];\n\n  var _point = _slicedToArray(point, 2),\n      px = _point[0],\n      py = _point[1]; // TODO Sub with static calc\n\n\n  var matrix = new THREE.Matrix4(); // prettier-ignore\n\n  matrix.set(ax, ay, ax * ax + ay * ay, 1, bx, by, bx * bx + by * by, 1, cx, cy, cx * cx + cy * cy, 1, px, py, px * px + py * py, 1);\n  return matrix.determinant() <= 0;\n}\nfunction triangleDeterminant(triangle) {\n  var _triangle$4 = _slicedToArray(triangle[0], 2),\n      x1 = _triangle$4[0],\n      y1 = _triangle$4[1];\n\n  var _triangle$5 = _slicedToArray(triangle[1], 2),\n      x2 = _triangle$5[0],\n      y2 = _triangle$5[1];\n\n  var _triangle$6 = _slicedToArray(triangle[2], 2),\n      x3 = _triangle$6[0],\n      y3 = _triangle$6[1]; // prettier-ignore\n\n\n  return matrix_dist_maathMatrix.determinant3(x1, y1, 1, x2, y2, 1, x3, y3, 1);\n}\n/**\n * Uses triangle area determinant to check if 3 points are collinear.\n * If they are, they can't make a triangle, so the determinant will be 0!\n *\n *      0     1     2\n * ─────■─────■─────■\n *\n *\n * Fun fact, you can use this same determinant to check the order of the points in the triangle\n *\n * NOTE: Should this use a buffer instead? NOTE: Should this use a buffer instead? [x0, y0, x1, y1, x2, y2]?\n *\n */\n\nfunction arePointsCollinear(points) {\n  return triangleDeterminant(points) === 0;\n} // TODO This is the same principle as the prev function, find a way to make it have sense\n\nfunction isTriangleClockwise(triangle) {\n  return triangleDeterminant(triangle) < 0;\n}\n/**\n \nThe circumcircle is a circle touching all the vertices of a triangle or polygon.\n\n             ┌───┐             \n             │ B │             \n             └───┘             \n           .───●───.           \n        ,─'   ╱ ╲   '─.        \n      ,'     ╱   ╲     `.      \n     ╱      ╱     ╲      ╲     \n    ;      ╱       ╲      :    \n    │     ╱         ╲     │    \n    │    ╱           ╲    │    \n    :   ╱             ╲   ;    \n     ╲ ╱               ╲ ╱     \n┌───┐ ●─────────────────● ┌───┐\n│ A │  `.             ,'  │ C │\n└───┘    '─.       ,─'    └───┘\n            `─────'                         \n */\n\n/**\n *\n * @param triangle\n *\n * @returns {number} circumcircle\n */\n// https://math.stackexchange.com/a/1460096\n\nfunction getCircumcircle(triangle) {\n  // TS-TODO the next few lines are ignored because the types aren't current to the change in vectors (that can now be iterated)\n  // @ts-ignore\n  var _triangle$7 = _slicedToArray(triangle[0], 2),\n      ax = _triangle$7[0],\n      ay = _triangle$7[1]; // @ts-ignore\n\n\n  var _triangle$8 = _slicedToArray(triangle[1], 2),\n      bx = _triangle$8[0],\n      by = _triangle$8[1]; // @ts-ignore\n\n\n  var _triangle$9 = _slicedToArray(triangle[2], 2),\n      cx = _triangle$9[0],\n      cy = _triangle$9[1];\n\n  if (arePointsCollinear(triangle)) return null; // points are collinear\n\n  var m = new THREE.Matrix4(); // prettier-ignore\n\n  m.set(1, 1, 1, 1, ax * ax + ay * ay, ax, ay, 1, bx * bx + by * by, bx, by, 1, cx * cx + cy * cy, cx, cy, 1);\n  var m11 = matrix_dist_maathMatrix.getMinor(m, 1, 1);\n  var m13 = matrix_dist_maathMatrix.getMinor(m, 1, 3);\n  var m12 = matrix_dist_maathMatrix.getMinor(m, 1, 2);\n  var m14 = matrix_dist_maathMatrix.getMinor(m, 1, 4);\n  var x0 = 0.5 * (m12 / m11);\n  var y0 = 0.5 * (m13 / m11);\n  var r2 = x0 * x0 + y0 * y0 + m14 / m11;\n  return {\n    x: Math.abs(x0) === 0 ? 0 : x0,\n    y: Math.abs(y0) === 0 ? 0 : -y0,\n    r: Math.sqrt(r2)\n  };\n} // https://stackoverflow.com/questions/39984709/how-can-i-check-wether-a-point-is-inside-the-circumcircle-of-3-points\n\nfunction isPointInCircumcircle(point, triangle) {\n  var _ref = Array.isArray(triangle[0]) ? triangle[0] : triangle[0].toArray(),\n      _ref2 = _slicedToArray(_ref, 2),\n      ax = _ref2[0],\n      ay = _ref2[1];\n\n  var _ref3 = Array.isArray(triangle[1]) ? triangle[1] : triangle[1].toArray(),\n      _ref4 = _slicedToArray(_ref3, 2),\n      bx = _ref4[0],\n      by = _ref4[1];\n\n  var _ref5 = Array.isArray(triangle[2]) ? triangle[2] : triangle[2].toArray(),\n      _ref6 = _slicedToArray(_ref5, 2),\n      cx = _ref6[0],\n      cy = _ref6[1];\n\n  var _point2 = _slicedToArray(point, 2),\n      px = _point2[0],\n      py = _point2[1];\n\n  if (arePointsCollinear(triangle)) throw new Error(\"Collinear points don't form a triangle\");\n  /**\n          | ax-px, ay-py, (ax-px)² + (ay-py)² |\n    det = | bx-px, by-py, (bx-px)² + (by-py)² |\n          | cx-px, cy-py, (cx-px)² + (cy-py)² |\n  */\n\n  var x1mpx = ax - px;\n  var aympy = ay - py;\n  var bxmpx = bx - px;\n  var bympy = by - py;\n  var cxmpx = cx - px;\n  var cympy = cy - py; // prettier-ignore\n\n  var d = matrix_dist_maathMatrix.determinant3(x1mpx, aympy, x1mpx * x1mpx + aympy * aympy, bxmpx, bympy, bxmpx * bxmpx + bympy * bympy, cxmpx, cympy, cxmpx * cxmpx + cympy * cympy); // if d is 0, the point is on C\n\n  if (d === 0) {\n    return true;\n  }\n\n  return !isTriangleClockwise(triangle) ? d > 0 : d < 0;\n} // From https://algorithmtutor.com/Computational-Geometry/Determining-if-two-consecutive-segments-turn-left-or-right/\n\nvar mv1 = new THREE.Vector2();\nvar mv2 = new THREE.Vector2();\n/**\n \n     ╱      ╲     \n    ╱        ╲    \n   ▕          ▏   \n                  \n right      left  \n\n * NOTE: Should this use a buffer instead? [x0, y0, x1, y1]?\n */\n\nfunction doThreePointsMakeARight(points) {\n  var _points$map = points.map(function (p) {\n    if (Array.isArray(p)) {\n      return _construct(THREE.Vector2, _toConsumableArray(p));\n    }\n\n    return p;\n  }),\n      _points$map2 = _slicedToArray(_points$map, 3),\n      p1 = _points$map2[0],\n      p2 = _points$map2[1],\n      p3 = _points$map2[2];\n\n  if (arePointsCollinear(points)) return false; // @ts-ignore\n\n  var p2p1 = mv1.subVectors(p2, p1); // @ts-ignore\n\n  var p3p1 = mv2.subVectors(p3, p1);\n  var cross = p3p1.cross(p2p1);\n  return cross > 0;\n}\n\nvar triangle = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  isPointInTriangle: isPointInTriangle,\n  triangleDeterminant: triangleDeterminant,\n  arePointsCollinear: arePointsCollinear,\n  isTriangleClockwise: isTriangleClockwise,\n  getCircumcircle: getCircumcircle,\n  isPointInCircumcircle: isPointInCircumcircle,\n  doThreePointsMakeARight: doThreePointsMakeARight\n});\n\nexports._slicedToArray = _slicedToArray;\nexports._toConsumableArray = _toConsumableArray;\nexports.arePointsCollinear = arePointsCollinear;\nexports.doThreePointsMakeARight = doThreePointsMakeARight;\nexports.getCircumcircle = getCircumcircle;\nexports.isPointInCircumcircle = isPointInCircumcircle;\nexports.isPointInTriangle = isPointInTriangle;\nexports.isTriangleClockwise = isTriangleClockwise;\nexports.triangle = triangle;\nexports.triangleDeterminant = triangleDeterminant;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC90cmlhbmdsZS0zM2ZmZGZlZi5janMuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLCtCQUErQixtQkFBTyxDQUFDLG9JQUFnRDtBQUN2RixZQUFZLG1CQUFPLENBQUMseURBQU87QUFDM0IsOEJBQThCLG1CQUFPLENBQUMsZ0dBQThCOztBQUVwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCOzs7QUFHdEIsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7O0FBRzNCO0FBQ0E7QUFDQSwyQkFBMkI7OztBQUczQjtBQUNBO0FBQ0E7O0FBRUEsaURBQWlEOztBQUVqRCwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkIsdUxBQXVMOztBQUV2TDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdEOztBQUVoRCxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsc0JBQXNCO0FBQ3RCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsK0JBQStCO0FBQy9CLHVCQUF1QjtBQUN2Qiw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQixnQkFBZ0I7QUFDaEIsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC90cmlhbmdsZS0zM2ZmZGZlZi5janMuZGV2LmpzPzNiNjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZSgnLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QtZGRjNGViYzEuY2pzLmRldi5qcycpO1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcbnZhciBtYXRyaXhfZGlzdF9tYWF0aE1hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4LWZiMTkwZjYwLmNqcy5kZXYuanMnKTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0Ll9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgfSBlbHNlIHtcbiAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gcG9pbnRcbiAqXG4gKiBAcGFyYW0gdHJpYW5nbGVcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW4gdGhlIHRyaWFuZ2xlXG4gKlxuICogVE9ETzogRmluZCBleHBsYWluZXJcbiAqL1xuZnVuY3Rpb24gaXNQb2ludEluVHJpYW5nbGUocG9pbnQsIHRyaWFuZ2xlKSB7XG4gIHZhciBfdHJpYW5nbGUkID0gX3NsaWNlZFRvQXJyYXkodHJpYW5nbGVbMF0sIDIpLFxuICAgICAgYXggPSBfdHJpYW5nbGUkWzBdLFxuICAgICAgYXkgPSBfdHJpYW5nbGUkWzFdO1xuXG4gIHZhciBfdHJpYW5nbGUkMiA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzFdLCAyKSxcbiAgICAgIGJ4ID0gX3RyaWFuZ2xlJDJbMF0sXG4gICAgICBieSA9IF90cmlhbmdsZSQyWzFdO1xuXG4gIHZhciBfdHJpYW5nbGUkMyA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzJdLCAyKSxcbiAgICAgIGN4ID0gX3RyaWFuZ2xlJDNbMF0sXG4gICAgICBjeSA9IF90cmlhbmdsZSQzWzFdO1xuXG4gIHZhciBfcG9pbnQgPSBfc2xpY2VkVG9BcnJheShwb2ludCwgMiksXG4gICAgICBweCA9IF9wb2ludFswXSxcbiAgICAgIHB5ID0gX3BvaW50WzFdOyAvLyBUT0RPIFN1YiB3aXRoIHN0YXRpYyBjYWxjXG5cblxuICB2YXIgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTsgLy8gcHJldHRpZXItaWdub3JlXG5cbiAgbWF0cml4LnNldChheCwgYXksIGF4ICogYXggKyBheSAqIGF5LCAxLCBieCwgYnksIGJ4ICogYnggKyBieSAqIGJ5LCAxLCBjeCwgY3ksIGN4ICogY3ggKyBjeSAqIGN5LCAxLCBweCwgcHksIHB4ICogcHggKyBweSAqIHB5LCAxKTtcbiAgcmV0dXJuIG1hdHJpeC5kZXRlcm1pbmFudCgpIDw9IDA7XG59XG5mdW5jdGlvbiB0cmlhbmdsZURldGVybWluYW50KHRyaWFuZ2xlKSB7XG4gIHZhciBfdHJpYW5nbGUkNCA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzBdLCAyKSxcbiAgICAgIHgxID0gX3RyaWFuZ2xlJDRbMF0sXG4gICAgICB5MSA9IF90cmlhbmdsZSQ0WzFdO1xuXG4gIHZhciBfdHJpYW5nbGUkNSA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzFdLCAyKSxcbiAgICAgIHgyID0gX3RyaWFuZ2xlJDVbMF0sXG4gICAgICB5MiA9IF90cmlhbmdsZSQ1WzFdO1xuXG4gIHZhciBfdHJpYW5nbGUkNiA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzJdLCAyKSxcbiAgICAgIHgzID0gX3RyaWFuZ2xlJDZbMF0sXG4gICAgICB5MyA9IF90cmlhbmdsZSQ2WzFdOyAvLyBwcmV0dGllci1pZ25vcmVcblxuXG4gIHJldHVybiBtYXRyaXhfZGlzdF9tYWF0aE1hdHJpeC5kZXRlcm1pbmFudDMoeDEsIHkxLCAxLCB4MiwgeTIsIDEsIHgzLCB5MywgMSk7XG59XG4vKipcbiAqIFVzZXMgdHJpYW5nbGUgYXJlYSBkZXRlcm1pbmFudCB0byBjaGVjayBpZiAzIHBvaW50cyBhcmUgY29sbGluZWFyLlxuICogSWYgdGhleSBhcmUsIHRoZXkgY2FuJ3QgbWFrZSBhIHRyaWFuZ2xlLCBzbyB0aGUgZGV0ZXJtaW5hbnQgd2lsbCBiZSAwIVxuICpcbiAqICAgICAgMCAgICAgMSAgICAgMlxuICog4pSA4pSA4pSA4pSA4pSA4pag4pSA4pSA4pSA4pSA4pSA4pag4pSA4pSA4pSA4pSA4pSA4pagXG4gKlxuICpcbiAqIEZ1biBmYWN0LCB5b3UgY2FuIHVzZSB0aGlzIHNhbWUgZGV0ZXJtaW5hbnQgdG8gY2hlY2sgdGhlIG9yZGVyIG9mIHRoZSBwb2ludHMgaW4gdGhlIHRyaWFuZ2xlXG4gKlxuICogTk9URTogU2hvdWxkIHRoaXMgdXNlIGEgYnVmZmVyIGluc3RlYWQ/IE5PVEU6IFNob3VsZCB0aGlzIHVzZSBhIGJ1ZmZlciBpbnN0ZWFkPyBbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0/XG4gKlxuICovXG5cbmZ1bmN0aW9uIGFyZVBvaW50c0NvbGxpbmVhcihwb2ludHMpIHtcbiAgcmV0dXJuIHRyaWFuZ2xlRGV0ZXJtaW5hbnQocG9pbnRzKSA9PT0gMDtcbn0gLy8gVE9ETyBUaGlzIGlzIHRoZSBzYW1lIHByaW5jaXBsZSBhcyB0aGUgcHJldiBmdW5jdGlvbiwgZmluZCBhIHdheSB0byBtYWtlIGl0IGhhdmUgc2Vuc2VcblxuZnVuY3Rpb24gaXNUcmlhbmdsZUNsb2Nrd2lzZSh0cmlhbmdsZSkge1xuICByZXR1cm4gdHJpYW5nbGVEZXRlcm1pbmFudCh0cmlhbmdsZSkgPCAwO1xufVxuLyoqXG4gXG5UaGUgY2lyY3VtY2lyY2xlIGlzIGEgY2lyY2xlIHRvdWNoaW5nIGFsbCB0aGUgdmVydGljZXMgb2YgYSB0cmlhbmdsZSBvciBwb2x5Z29uLlxuXG4gICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQICAgICAgICAgICAgIFxuICAgICAgICAgICAgIOKUgiBCIOKUgiAgICAgICAgICAgICBcbiAgICAgICAgICAgICDilJTilIDilIDilIDilJggICAgICAgICAgICAgXG4gICAgICAgICAgIC7ilIDilIDilIDil4/ilIDilIDilIAuICAgICAgICAgICBcbiAgICAgICAgLOKUgCcgICDilbEg4pWyICAgJ+KUgC4gICAgICAgIFxuICAgICAgLCcgICAgIOKVsSAgIOKVsiAgICAgYC4gICAgICBcbiAgICAg4pWxICAgICAg4pWxICAgICDilbIgICAgICDilbIgICAgIFxuICAgIDsgICAgICDilbEgICAgICAg4pWyICAgICAgOiAgICBcbiAgICDilIIgICAgIOKVsSAgICAgICAgIOKVsiAgICAg4pSCICAgIFxuICAgIOKUgiAgICDilbEgICAgICAgICAgIOKVsiAgICDilIIgICAgXG4gICAgOiAgIOKVsSAgICAgICAgICAgICDilbIgICA7ICAgIFxuICAgICDilbIg4pWxICAgICAgICAgICAgICAg4pWyIOKVsSAgICAgXG7ilIzilIDilIDilIDilJAg4peP4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pePIOKUjOKUgOKUgOKUgOKUkFxu4pSCIEEg4pSCICBgLiAgICAgICAgICAgICAsJyAg4pSCIEMg4pSCXG7ilJTilIDilIDilIDilJggICAgJ+KUgC4gICAgICAgLOKUgCcgICAg4pSU4pSA4pSA4pSA4pSYXG4gICAgICAgICAgICBg4pSA4pSA4pSA4pSA4pSAJyAgICAgICAgICAgICAgICAgICAgICAgICBcbiAqL1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gdHJpYW5nbGVcbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjaXJjdW1jaXJjbGVcbiAqL1xuLy8gaHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL2EvMTQ2MDA5NlxuXG5mdW5jdGlvbiBnZXRDaXJjdW1jaXJjbGUodHJpYW5nbGUpIHtcbiAgLy8gVFMtVE9ETyB0aGUgbmV4dCBmZXcgbGluZXMgYXJlIGlnbm9yZWQgYmVjYXVzZSB0aGUgdHlwZXMgYXJlbid0IGN1cnJlbnQgdG8gdGhlIGNoYW5nZSBpbiB2ZWN0b3JzICh0aGF0IGNhbiBub3cgYmUgaXRlcmF0ZWQpXG4gIC8vIEB0cy1pZ25vcmVcbiAgdmFyIF90cmlhbmdsZSQ3ID0gX3NsaWNlZFRvQXJyYXkodHJpYW5nbGVbMF0sIDIpLFxuICAgICAgYXggPSBfdHJpYW5nbGUkN1swXSxcbiAgICAgIGF5ID0gX3RyaWFuZ2xlJDdbMV07IC8vIEB0cy1pZ25vcmVcblxuXG4gIHZhciBfdHJpYW5nbGUkOCA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzFdLCAyKSxcbiAgICAgIGJ4ID0gX3RyaWFuZ2xlJDhbMF0sXG4gICAgICBieSA9IF90cmlhbmdsZSQ4WzFdOyAvLyBAdHMtaWdub3JlXG5cblxuICB2YXIgX3RyaWFuZ2xlJDkgPSBfc2xpY2VkVG9BcnJheSh0cmlhbmdsZVsyXSwgMiksXG4gICAgICBjeCA9IF90cmlhbmdsZSQ5WzBdLFxuICAgICAgY3kgPSBfdHJpYW5nbGUkOVsxXTtcblxuICBpZiAoYXJlUG9pbnRzQ29sbGluZWFyKHRyaWFuZ2xlKSkgcmV0dXJuIG51bGw7IC8vIHBvaW50cyBhcmUgY29sbGluZWFyXG5cbiAgdmFyIG0gPSBuZXcgVEhSRUUuTWF0cml4NCgpOyAvLyBwcmV0dGllci1pZ25vcmVcblxuICBtLnNldCgxLCAxLCAxLCAxLCBheCAqIGF4ICsgYXkgKiBheSwgYXgsIGF5LCAxLCBieCAqIGJ4ICsgYnkgKiBieSwgYngsIGJ5LCAxLCBjeCAqIGN4ICsgY3kgKiBjeSwgY3gsIGN5LCAxKTtcbiAgdmFyIG0xMSA9IG1hdHJpeF9kaXN0X21hYXRoTWF0cml4LmdldE1pbm9yKG0sIDEsIDEpO1xuICB2YXIgbTEzID0gbWF0cml4X2Rpc3RfbWFhdGhNYXRyaXguZ2V0TWlub3IobSwgMSwgMyk7XG4gIHZhciBtMTIgPSBtYXRyaXhfZGlzdF9tYWF0aE1hdHJpeC5nZXRNaW5vcihtLCAxLCAyKTtcbiAgdmFyIG0xNCA9IG1hdHJpeF9kaXN0X21hYXRoTWF0cml4LmdldE1pbm9yKG0sIDEsIDQpO1xuICB2YXIgeDAgPSAwLjUgKiAobTEyIC8gbTExKTtcbiAgdmFyIHkwID0gMC41ICogKG0xMyAvIG0xMSk7XG4gIHZhciByMiA9IHgwICogeDAgKyB5MCAqIHkwICsgbTE0IC8gbTExO1xuICByZXR1cm4ge1xuICAgIHg6IE1hdGguYWJzKHgwKSA9PT0gMCA/IDAgOiB4MCxcbiAgICB5OiBNYXRoLmFicyh5MCkgPT09IDAgPyAwIDogLXkwLFxuICAgIHI6IE1hdGguc3FydChyMilcbiAgfTtcbn0gLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk5ODQ3MDkvaG93LWNhbi1pLWNoZWNrLXdldGhlci1hLXBvaW50LWlzLWluc2lkZS10aGUtY2lyY3VtY2lyY2xlLW9mLTMtcG9pbnRzXG5cbmZ1bmN0aW9uIGlzUG9pbnRJbkNpcmN1bWNpcmNsZShwb2ludCwgdHJpYW5nbGUpIHtcbiAgdmFyIF9yZWYgPSBBcnJheS5pc0FycmF5KHRyaWFuZ2xlWzBdKSA/IHRyaWFuZ2xlWzBdIDogdHJpYW5nbGVbMF0udG9BcnJheSgpLFxuICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgIGF4ID0gX3JlZjJbMF0sXG4gICAgICBheSA9IF9yZWYyWzFdO1xuXG4gIHZhciBfcmVmMyA9IEFycmF5LmlzQXJyYXkodHJpYW5nbGVbMV0pID8gdHJpYW5nbGVbMV0gOiB0cmlhbmdsZVsxXS50b0FycmF5KCksXG4gICAgICBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgIGJ4ID0gX3JlZjRbMF0sXG4gICAgICBieSA9IF9yZWY0WzFdO1xuXG4gIHZhciBfcmVmNSA9IEFycmF5LmlzQXJyYXkodHJpYW5nbGVbMl0pID8gdHJpYW5nbGVbMl0gOiB0cmlhbmdsZVsyXS50b0FycmF5KCksXG4gICAgICBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAyKSxcbiAgICAgIGN4ID0gX3JlZjZbMF0sXG4gICAgICBjeSA9IF9yZWY2WzFdO1xuXG4gIHZhciBfcG9pbnQyID0gX3NsaWNlZFRvQXJyYXkocG9pbnQsIDIpLFxuICAgICAgcHggPSBfcG9pbnQyWzBdLFxuICAgICAgcHkgPSBfcG9pbnQyWzFdO1xuXG4gIGlmIChhcmVQb2ludHNDb2xsaW5lYXIodHJpYW5nbGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJDb2xsaW5lYXIgcG9pbnRzIGRvbid0IGZvcm0gYSB0cmlhbmdsZVwiKTtcbiAgLyoqXG4gICAgICAgICAgfCBheC1weCwgYXktcHksIChheC1weCnCsiArIChheS1weSnCsiB8XG4gICAgZGV0ID0gfCBieC1weCwgYnktcHksIChieC1weCnCsiArIChieS1weSnCsiB8XG4gICAgICAgICAgfCBjeC1weCwgY3ktcHksIChjeC1weCnCsiArIChjeS1weSnCsiB8XG4gICovXG5cbiAgdmFyIHgxbXB4ID0gYXggLSBweDtcbiAgdmFyIGF5bXB5ID0gYXkgLSBweTtcbiAgdmFyIGJ4bXB4ID0gYnggLSBweDtcbiAgdmFyIGJ5bXB5ID0gYnkgLSBweTtcbiAgdmFyIGN4bXB4ID0gY3ggLSBweDtcbiAgdmFyIGN5bXB5ID0gY3kgLSBweTsgLy8gcHJldHRpZXItaWdub3JlXG5cbiAgdmFyIGQgPSBtYXRyaXhfZGlzdF9tYWF0aE1hdHJpeC5kZXRlcm1pbmFudDMoeDFtcHgsIGF5bXB5LCB4MW1weCAqIHgxbXB4ICsgYXltcHkgKiBheW1weSwgYnhtcHgsIGJ5bXB5LCBieG1weCAqIGJ4bXB4ICsgYnltcHkgKiBieW1weSwgY3htcHgsIGN5bXB5LCBjeG1weCAqIGN4bXB4ICsgY3ltcHkgKiBjeW1weSk7IC8vIGlmIGQgaXMgMCwgdGhlIHBvaW50IGlzIG9uIENcblxuICBpZiAoZCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuICFpc1RyaWFuZ2xlQ2xvY2t3aXNlKHRyaWFuZ2xlKSA/IGQgPiAwIDogZCA8IDA7XG59IC8vIEZyb20gaHR0cHM6Ly9hbGdvcml0aG10dXRvci5jb20vQ29tcHV0YXRpb25hbC1HZW9tZXRyeS9EZXRlcm1pbmluZy1pZi10d28tY29uc2VjdXRpdmUtc2VnbWVudHMtdHVybi1sZWZ0LW9yLXJpZ2h0L1xuXG52YXIgbXYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbnZhciBtdjIgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuLyoqXG4gXG4gICAgIOKVsSAgICAgIOKVsiAgICAgXG4gICAg4pWxICAgICAgICDilbIgICAgXG4gICDilpUgICAgICAgICAg4paPICAgXG4gICAgICAgICAgICAgICAgICBcbiByaWdodCAgICAgIGxlZnQgIFxuXG4gKiBOT1RFOiBTaG91bGQgdGhpcyB1c2UgYSBidWZmZXIgaW5zdGVhZD8gW3gwLCB5MCwgeDEsIHkxXT9cbiAqL1xuXG5mdW5jdGlvbiBkb1RocmVlUG9pbnRzTWFrZUFSaWdodChwb2ludHMpIHtcbiAgdmFyIF9wb2ludHMkbWFwID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHApKSB7XG4gICAgICByZXR1cm4gX2NvbnN0cnVjdChUSFJFRS5WZWN0b3IyLCBfdG9Db25zdW1hYmxlQXJyYXkocCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9KSxcbiAgICAgIF9wb2ludHMkbWFwMiA9IF9zbGljZWRUb0FycmF5KF9wb2ludHMkbWFwLCAzKSxcbiAgICAgIHAxID0gX3BvaW50cyRtYXAyWzBdLFxuICAgICAgcDIgPSBfcG9pbnRzJG1hcDJbMV0sXG4gICAgICBwMyA9IF9wb2ludHMkbWFwMlsyXTtcblxuICBpZiAoYXJlUG9pbnRzQ29sbGluZWFyKHBvaW50cykpIHJldHVybiBmYWxzZTsgLy8gQHRzLWlnbm9yZVxuXG4gIHZhciBwMnAxID0gbXYxLnN1YlZlY3RvcnMocDIsIHAxKTsgLy8gQHRzLWlnbm9yZVxuXG4gIHZhciBwM3AxID0gbXYyLnN1YlZlY3RvcnMocDMsIHAxKTtcbiAgdmFyIGNyb3NzID0gcDNwMS5jcm9zcyhwMnAxKTtcbiAgcmV0dXJuIGNyb3NzID4gMDtcbn1cblxudmFyIHRyaWFuZ2xlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGlzUG9pbnRJblRyaWFuZ2xlOiBpc1BvaW50SW5UcmlhbmdsZSxcbiAgdHJpYW5nbGVEZXRlcm1pbmFudDogdHJpYW5nbGVEZXRlcm1pbmFudCxcbiAgYXJlUG9pbnRzQ29sbGluZWFyOiBhcmVQb2ludHNDb2xsaW5lYXIsXG4gIGlzVHJpYW5nbGVDbG9ja3dpc2U6IGlzVHJpYW5nbGVDbG9ja3dpc2UsXG4gIGdldENpcmN1bWNpcmNsZTogZ2V0Q2lyY3VtY2lyY2xlLFxuICBpc1BvaW50SW5DaXJjdW1jaXJjbGU6IGlzUG9pbnRJbkNpcmN1bWNpcmNsZSxcbiAgZG9UaHJlZVBvaW50c01ha2VBUmlnaHQ6IGRvVGhyZWVQb2ludHNNYWtlQVJpZ2h0XG59KTtcblxuZXhwb3J0cy5fc2xpY2VkVG9BcnJheSA9IF9zbGljZWRUb0FycmF5O1xuZXhwb3J0cy5fdG9Db25zdW1hYmxlQXJyYXkgPSBfdG9Db25zdW1hYmxlQXJyYXk7XG5leHBvcnRzLmFyZVBvaW50c0NvbGxpbmVhciA9IGFyZVBvaW50c0NvbGxpbmVhcjtcbmV4cG9ydHMuZG9UaHJlZVBvaW50c01ha2VBUmlnaHQgPSBkb1RocmVlUG9pbnRzTWFrZUFSaWdodDtcbmV4cG9ydHMuZ2V0Q2lyY3VtY2lyY2xlID0gZ2V0Q2lyY3VtY2lyY2xlO1xuZXhwb3J0cy5pc1BvaW50SW5DaXJjdW1jaXJjbGUgPSBpc1BvaW50SW5DaXJjdW1jaXJjbGU7XG5leHBvcnRzLmlzUG9pbnRJblRyaWFuZ2xlID0gaXNQb2ludEluVHJpYW5nbGU7XG5leHBvcnRzLmlzVHJpYW5nbGVDbG9ja3dpc2UgPSBpc1RyaWFuZ2xlQ2xvY2t3aXNlO1xuZXhwb3J0cy50cmlhbmdsZSA9IHRyaWFuZ2xlO1xuZXhwb3J0cy50cmlhbmdsZURldGVybWluYW50ID0gdHJpYW5nbGVEZXRlcm1pbmFudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/triangle-33ffdfef.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/triangle-b62b9067.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/maath/dist/triangle-b62b9067.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _slicedToArray),\n/* harmony export */   a: () => (/* binding */ _toConsumableArray),\n/* harmony export */   b: () => (/* binding */ triangleDeterminant),\n/* harmony export */   c: () => (/* binding */ arePointsCollinear),\n/* harmony export */   d: () => (/* binding */ doThreePointsMakeARight),\n/* harmony export */   e: () => (/* binding */ isTriangleClockwise),\n/* harmony export */   f: () => (/* binding */ isPointInCircumcircle),\n/* harmony export */   g: () => (/* binding */ getCircumcircle),\n/* harmony export */   i: () => (/* binding */ isPointInTriangle),\n/* harmony export */   t: () => (/* binding */ triangle)\n/* harmony export */ });\n/* harmony import */ var _isNativeReflectConstruct_5594d075_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isNativeReflectConstruct-5594d075.esm.js */ \"(ssr)/./node_modules/maath/dist/isNativeReflectConstruct-5594d075.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix-baa530bf.esm.js */ \"(ssr)/./node_modules/maath/dist/matrix-baa530bf.esm.js\");\n\n\n\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _construct(Parent, args, Class) {\n  if ((0,_isNativeReflectConstruct_5594d075_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) (0,_isNativeReflectConstruct_5594d075_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\n/**\n *\n * @param point\n *\n * @param triangle\n *\n * @returns {boolean} true if the point is in the triangle\n *\n * TODO: Find explainer\n */\nfunction isPointInTriangle(point, triangle) {\n  var _triangle$ = _slicedToArray(triangle[0], 2),\n      ax = _triangle$[0],\n      ay = _triangle$[1];\n\n  var _triangle$2 = _slicedToArray(triangle[1], 2),\n      bx = _triangle$2[0],\n      by = _triangle$2[1];\n\n  var _triangle$3 = _slicedToArray(triangle[2], 2),\n      cx = _triangle$3[0],\n      cy = _triangle$3[1];\n\n  var _point = _slicedToArray(point, 2),\n      px = _point[0],\n      py = _point[1]; // TODO Sub with static calc\n\n\n  var matrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4(); // prettier-ignore\n\n  matrix.set(ax, ay, ax * ax + ay * ay, 1, bx, by, bx * bx + by * by, 1, cx, cy, cx * cx + cy * cy, 1, px, py, px * px + py * py, 1);\n  return matrix.determinant() <= 0;\n}\nfunction triangleDeterminant(triangle) {\n  var _triangle$4 = _slicedToArray(triangle[0], 2),\n      x1 = _triangle$4[0],\n      y1 = _triangle$4[1];\n\n  var _triangle$5 = _slicedToArray(triangle[1], 2),\n      x2 = _triangle$5[0],\n      y2 = _triangle$5[1];\n\n  var _triangle$6 = _slicedToArray(triangle[2], 2),\n      x3 = _triangle$6[0],\n      y3 = _triangle$6[1]; // prettier-ignore\n\n\n  return (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(x1, y1, 1, x2, y2, 1, x3, y3, 1);\n}\n/**\n * Uses triangle area determinant to check if 3 points are collinear.\n * If they are, they can't make a triangle, so the determinant will be 0!\n *\n *      0     1     2\n * ─────■─────■─────■\n *\n *\n * Fun fact, you can use this same determinant to check the order of the points in the triangle\n *\n * NOTE: Should this use a buffer instead? NOTE: Should this use a buffer instead? [x0, y0, x1, y1, x2, y2]?\n *\n */\n\nfunction arePointsCollinear(points) {\n  return triangleDeterminant(points) === 0;\n} // TODO This is the same principle as the prev function, find a way to make it have sense\n\nfunction isTriangleClockwise(triangle) {\n  return triangleDeterminant(triangle) < 0;\n}\n/**\n \nThe circumcircle is a circle touching all the vertices of a triangle or polygon.\n\n             ┌───┐             \n             │ B │             \n             └───┘             \n           .───●───.           \n        ,─'   ╱ ╲   '─.        \n      ,'     ╱   ╲     `.      \n     ╱      ╱     ╲      ╲     \n    ;      ╱       ╲      :    \n    │     ╱         ╲     │    \n    │    ╱           ╲    │    \n    :   ╱             ╲   ;    \n     ╲ ╱               ╲ ╱     \n┌───┐ ●─────────────────● ┌───┐\n│ A │  `.             ,'  │ C │\n└───┘    '─.       ,─'    └───┘\n            `─────'                         \n */\n\n/**\n *\n * @param triangle\n *\n * @returns {number} circumcircle\n */\n// https://math.stackexchange.com/a/1460096\n\nfunction getCircumcircle(triangle) {\n  // TS-TODO the next few lines are ignored because the types aren't current to the change in vectors (that can now be iterated)\n  // @ts-ignore\n  var _triangle$7 = _slicedToArray(triangle[0], 2),\n      ax = _triangle$7[0],\n      ay = _triangle$7[1]; // @ts-ignore\n\n\n  var _triangle$8 = _slicedToArray(triangle[1], 2),\n      bx = _triangle$8[0],\n      by = _triangle$8[1]; // @ts-ignore\n\n\n  var _triangle$9 = _slicedToArray(triangle[2], 2),\n      cx = _triangle$9[0],\n      cy = _triangle$9[1];\n\n  if (arePointsCollinear(triangle)) return null; // points are collinear\n\n  var m = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4(); // prettier-ignore\n\n  m.set(1, 1, 1, 1, ax * ax + ay * ay, ax, ay, 1, bx * bx + by * by, bx, by, 1, cx * cx + cy * cy, cx, cy, 1);\n  var m11 = (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(m, 1, 1);\n  var m13 = (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(m, 1, 3);\n  var m12 = (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(m, 1, 2);\n  var m14 = (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(m, 1, 4);\n  var x0 = 0.5 * (m12 / m11);\n  var y0 = 0.5 * (m13 / m11);\n  var r2 = x0 * x0 + y0 * y0 + m14 / m11;\n  return {\n    x: Math.abs(x0) === 0 ? 0 : x0,\n    y: Math.abs(y0) === 0 ? 0 : -y0,\n    r: Math.sqrt(r2)\n  };\n} // https://stackoverflow.com/questions/39984709/how-can-i-check-wether-a-point-is-inside-the-circumcircle-of-3-points\n\nfunction isPointInCircumcircle(point, triangle) {\n  var _ref = Array.isArray(triangle[0]) ? triangle[0] : triangle[0].toArray(),\n      _ref2 = _slicedToArray(_ref, 2),\n      ax = _ref2[0],\n      ay = _ref2[1];\n\n  var _ref3 = Array.isArray(triangle[1]) ? triangle[1] : triangle[1].toArray(),\n      _ref4 = _slicedToArray(_ref3, 2),\n      bx = _ref4[0],\n      by = _ref4[1];\n\n  var _ref5 = Array.isArray(triangle[2]) ? triangle[2] : triangle[2].toArray(),\n      _ref6 = _slicedToArray(_ref5, 2),\n      cx = _ref6[0],\n      cy = _ref6[1];\n\n  var _point2 = _slicedToArray(point, 2),\n      px = _point2[0],\n      py = _point2[1];\n\n  if (arePointsCollinear(triangle)) throw new Error(\"Collinear points don't form a triangle\");\n  /**\n          | ax-px, ay-py, (ax-px)² + (ay-py)² |\n    det = | bx-px, by-py, (bx-px)² + (by-py)² |\n          | cx-px, cy-py, (cx-px)² + (cy-py)² |\n  */\n\n  var x1mpx = ax - px;\n  var aympy = ay - py;\n  var bxmpx = bx - px;\n  var bympy = by - py;\n  var cxmpx = cx - px;\n  var cympy = cy - py; // prettier-ignore\n\n  var d = (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(x1mpx, aympy, x1mpx * x1mpx + aympy * aympy, bxmpx, bympy, bxmpx * bxmpx + bympy * bympy, cxmpx, cympy, cxmpx * cxmpx + cympy * cympy); // if d is 0, the point is on C\n\n  if (d === 0) {\n    return true;\n  }\n\n  return !isTriangleClockwise(triangle) ? d > 0 : d < 0;\n} // From https://algorithmtutor.com/Computational-Geometry/Determining-if-two-consecutive-segments-turn-left-or-right/\n\nvar mv1 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();\nvar mv2 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();\n/**\n \n     ╱      ╲     \n    ╱        ╲    \n   ▕          ▏   \n                  \n right      left  \n\n * NOTE: Should this use a buffer instead? [x0, y0, x1, y1]?\n */\n\nfunction doThreePointsMakeARight(points) {\n  var _points$map = points.map(function (p) {\n    if (Array.isArray(p)) {\n      return _construct(three__WEBPACK_IMPORTED_MODULE_2__.Vector2, _toConsumableArray(p));\n    }\n\n    return p;\n  }),\n      _points$map2 = _slicedToArray(_points$map, 3),\n      p1 = _points$map2[0],\n      p2 = _points$map2[1],\n      p3 = _points$map2[2];\n\n  if (arePointsCollinear(points)) return false; // @ts-ignore\n\n  var p2p1 = mv1.subVectors(p2, p1); // @ts-ignore\n\n  var p3p1 = mv2.subVectors(p3, p1);\n  var cross = p3p1.cross(p2p1);\n  return cross > 0;\n}\n\nvar triangle = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  isPointInTriangle: isPointInTriangle,\n  triangleDeterminant: triangleDeterminant,\n  arePointsCollinear: arePointsCollinear,\n  isTriangleClockwise: isTriangleClockwise,\n  getCircumcircle: getCircumcircle,\n  isPointInCircumcircle: isPointInCircumcircle,\n  doThreePointsMakeARight: doThreePointsMakeARight\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC90cmlhbmdsZS1iNjJiOTA2Ny5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFrSDtBQUN6RTtBQUNtQzs7QUFFNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sNEVBQXlCO0FBQy9CO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEVBQWU7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjs7O0FBR3RCLG1CQUFtQiwwQ0FBTyxJQUFJOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjs7O0FBRzNCLFNBQVMsMERBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7O0FBRzNCO0FBQ0E7QUFDQSwyQkFBMkI7OztBQUczQjtBQUNBO0FBQ0E7O0FBRUEsaURBQWlEOztBQUVqRCxjQUFjLDBDQUFPLElBQUk7O0FBRXpCO0FBQ0EsWUFBWSwwREFBUTtBQUNwQixZQUFZLDBEQUFRO0FBQ3BCLFlBQVksMERBQVE7QUFDcEIsWUFBWSwwREFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkIsVUFBVSwwREFBWSx5SUFBeUk7O0FBRS9KO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUYsY0FBYywwQ0FBTztBQUNyQixjQUFjLDBDQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBDQUFPO0FBQy9COztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDs7QUFFaEQscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUUyUCIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYWNlcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvdHJpYW5nbGUtYjYyYjkwNjcuZXNtLmpzPzQyNWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYSBhcyBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LCBfIGFzIF9zZXRQcm90b3R5cGVPZiB9IGZyb20gJy4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LTU1OTRkMDc1LmVzbS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyLCBNYXRyaXg0IH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgZCBhcyBkZXRlcm1pbmFudDMsIGcgYXMgZ2V0TWlub3IgfSBmcm9tICcuL21hdHJpeC1iYWE1MzBiZi5lc20uanMnO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuXG4gIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuXG4gIHZhciBfcywgX2U7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gcG9pbnRcbiAqXG4gKiBAcGFyYW0gdHJpYW5nbGVcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW4gdGhlIHRyaWFuZ2xlXG4gKlxuICogVE9ETzogRmluZCBleHBsYWluZXJcbiAqL1xuZnVuY3Rpb24gaXNQb2ludEluVHJpYW5nbGUocG9pbnQsIHRyaWFuZ2xlKSB7XG4gIHZhciBfdHJpYW5nbGUkID0gX3NsaWNlZFRvQXJyYXkodHJpYW5nbGVbMF0sIDIpLFxuICAgICAgYXggPSBfdHJpYW5nbGUkWzBdLFxuICAgICAgYXkgPSBfdHJpYW5nbGUkWzFdO1xuXG4gIHZhciBfdHJpYW5nbGUkMiA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzFdLCAyKSxcbiAgICAgIGJ4ID0gX3RyaWFuZ2xlJDJbMF0sXG4gICAgICBieSA9IF90cmlhbmdsZSQyWzFdO1xuXG4gIHZhciBfdHJpYW5nbGUkMyA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzJdLCAyKSxcbiAgICAgIGN4ID0gX3RyaWFuZ2xlJDNbMF0sXG4gICAgICBjeSA9IF90cmlhbmdsZSQzWzFdO1xuXG4gIHZhciBfcG9pbnQgPSBfc2xpY2VkVG9BcnJheShwb2ludCwgMiksXG4gICAgICBweCA9IF9wb2ludFswXSxcbiAgICAgIHB5ID0gX3BvaW50WzFdOyAvLyBUT0RPIFN1YiB3aXRoIHN0YXRpYyBjYWxjXG5cblxuICB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTsgLy8gcHJldHRpZXItaWdub3JlXG5cbiAgbWF0cml4LnNldChheCwgYXksIGF4ICogYXggKyBheSAqIGF5LCAxLCBieCwgYnksIGJ4ICogYnggKyBieSAqIGJ5LCAxLCBjeCwgY3ksIGN4ICogY3ggKyBjeSAqIGN5LCAxLCBweCwgcHksIHB4ICogcHggKyBweSAqIHB5LCAxKTtcbiAgcmV0dXJuIG1hdHJpeC5kZXRlcm1pbmFudCgpIDw9IDA7XG59XG5mdW5jdGlvbiB0cmlhbmdsZURldGVybWluYW50KHRyaWFuZ2xlKSB7XG4gIHZhciBfdHJpYW5nbGUkNCA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzBdLCAyKSxcbiAgICAgIHgxID0gX3RyaWFuZ2xlJDRbMF0sXG4gICAgICB5MSA9IF90cmlhbmdsZSQ0WzFdO1xuXG4gIHZhciBfdHJpYW5nbGUkNSA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzFdLCAyKSxcbiAgICAgIHgyID0gX3RyaWFuZ2xlJDVbMF0sXG4gICAgICB5MiA9IF90cmlhbmdsZSQ1WzFdO1xuXG4gIHZhciBfdHJpYW5nbGUkNiA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzJdLCAyKSxcbiAgICAgIHgzID0gX3RyaWFuZ2xlJDZbMF0sXG4gICAgICB5MyA9IF90cmlhbmdsZSQ2WzFdOyAvLyBwcmV0dGllci1pZ25vcmVcblxuXG4gIHJldHVybiBkZXRlcm1pbmFudDMoeDEsIHkxLCAxLCB4MiwgeTIsIDEsIHgzLCB5MywgMSk7XG59XG4vKipcbiAqIFVzZXMgdHJpYW5nbGUgYXJlYSBkZXRlcm1pbmFudCB0byBjaGVjayBpZiAzIHBvaW50cyBhcmUgY29sbGluZWFyLlxuICogSWYgdGhleSBhcmUsIHRoZXkgY2FuJ3QgbWFrZSBhIHRyaWFuZ2xlLCBzbyB0aGUgZGV0ZXJtaW5hbnQgd2lsbCBiZSAwIVxuICpcbiAqICAgICAgMCAgICAgMSAgICAgMlxuICog4pSA4pSA4pSA4pSA4pSA4pag4pSA4pSA4pSA4pSA4pSA4pag4pSA4pSA4pSA4pSA4pSA4pagXG4gKlxuICpcbiAqIEZ1biBmYWN0LCB5b3UgY2FuIHVzZSB0aGlzIHNhbWUgZGV0ZXJtaW5hbnQgdG8gY2hlY2sgdGhlIG9yZGVyIG9mIHRoZSBwb2ludHMgaW4gdGhlIHRyaWFuZ2xlXG4gKlxuICogTk9URTogU2hvdWxkIHRoaXMgdXNlIGEgYnVmZmVyIGluc3RlYWQ/IE5PVEU6IFNob3VsZCB0aGlzIHVzZSBhIGJ1ZmZlciBpbnN0ZWFkPyBbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0/XG4gKlxuICovXG5cbmZ1bmN0aW9uIGFyZVBvaW50c0NvbGxpbmVhcihwb2ludHMpIHtcbiAgcmV0dXJuIHRyaWFuZ2xlRGV0ZXJtaW5hbnQocG9pbnRzKSA9PT0gMDtcbn0gLy8gVE9ETyBUaGlzIGlzIHRoZSBzYW1lIHByaW5jaXBsZSBhcyB0aGUgcHJldiBmdW5jdGlvbiwgZmluZCBhIHdheSB0byBtYWtlIGl0IGhhdmUgc2Vuc2VcblxuZnVuY3Rpb24gaXNUcmlhbmdsZUNsb2Nrd2lzZSh0cmlhbmdsZSkge1xuICByZXR1cm4gdHJpYW5nbGVEZXRlcm1pbmFudCh0cmlhbmdsZSkgPCAwO1xufVxuLyoqXG4gXG5UaGUgY2lyY3VtY2lyY2xlIGlzIGEgY2lyY2xlIHRvdWNoaW5nIGFsbCB0aGUgdmVydGljZXMgb2YgYSB0cmlhbmdsZSBvciBwb2x5Z29uLlxuXG4gICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQICAgICAgICAgICAgIFxuICAgICAgICAgICAgIOKUgiBCIOKUgiAgICAgICAgICAgICBcbiAgICAgICAgICAgICDilJTilIDilIDilIDilJggICAgICAgICAgICAgXG4gICAgICAgICAgIC7ilIDilIDilIDil4/ilIDilIDilIAuICAgICAgICAgICBcbiAgICAgICAgLOKUgCcgICDilbEg4pWyICAgJ+KUgC4gICAgICAgIFxuICAgICAgLCcgICAgIOKVsSAgIOKVsiAgICAgYC4gICAgICBcbiAgICAg4pWxICAgICAg4pWxICAgICDilbIgICAgICDilbIgICAgIFxuICAgIDsgICAgICDilbEgICAgICAg4pWyICAgICAgOiAgICBcbiAgICDilIIgICAgIOKVsSAgICAgICAgIOKVsiAgICAg4pSCICAgIFxuICAgIOKUgiAgICDilbEgICAgICAgICAgIOKVsiAgICDilIIgICAgXG4gICAgOiAgIOKVsSAgICAgICAgICAgICDilbIgICA7ICAgIFxuICAgICDilbIg4pWxICAgICAgICAgICAgICAg4pWyIOKVsSAgICAgXG7ilIzilIDilIDilIDilJAg4peP4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pePIOKUjOKUgOKUgOKUgOKUkFxu4pSCIEEg4pSCICBgLiAgICAgICAgICAgICAsJyAg4pSCIEMg4pSCXG7ilJTilIDilIDilIDilJggICAgJ+KUgC4gICAgICAgLOKUgCcgICAg4pSU4pSA4pSA4pSA4pSYXG4gICAgICAgICAgICBg4pSA4pSA4pSA4pSA4pSAJyAgICAgICAgICAgICAgICAgICAgICAgICBcbiAqL1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gdHJpYW5nbGVcbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjaXJjdW1jaXJjbGVcbiAqL1xuLy8gaHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL2EvMTQ2MDA5NlxuXG5mdW5jdGlvbiBnZXRDaXJjdW1jaXJjbGUodHJpYW5nbGUpIHtcbiAgLy8gVFMtVE9ETyB0aGUgbmV4dCBmZXcgbGluZXMgYXJlIGlnbm9yZWQgYmVjYXVzZSB0aGUgdHlwZXMgYXJlbid0IGN1cnJlbnQgdG8gdGhlIGNoYW5nZSBpbiB2ZWN0b3JzICh0aGF0IGNhbiBub3cgYmUgaXRlcmF0ZWQpXG4gIC8vIEB0cy1pZ25vcmVcbiAgdmFyIF90cmlhbmdsZSQ3ID0gX3NsaWNlZFRvQXJyYXkodHJpYW5nbGVbMF0sIDIpLFxuICAgICAgYXggPSBfdHJpYW5nbGUkN1swXSxcbiAgICAgIGF5ID0gX3RyaWFuZ2xlJDdbMV07IC8vIEB0cy1pZ25vcmVcblxuXG4gIHZhciBfdHJpYW5nbGUkOCA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzFdLCAyKSxcbiAgICAgIGJ4ID0gX3RyaWFuZ2xlJDhbMF0sXG4gICAgICBieSA9IF90cmlhbmdsZSQ4WzFdOyAvLyBAdHMtaWdub3JlXG5cblxuICB2YXIgX3RyaWFuZ2xlJDkgPSBfc2xpY2VkVG9BcnJheSh0cmlhbmdsZVsyXSwgMiksXG4gICAgICBjeCA9IF90cmlhbmdsZSQ5WzBdLFxuICAgICAgY3kgPSBfdHJpYW5nbGUkOVsxXTtcblxuICBpZiAoYXJlUG9pbnRzQ29sbGluZWFyKHRyaWFuZ2xlKSkgcmV0dXJuIG51bGw7IC8vIHBvaW50cyBhcmUgY29sbGluZWFyXG5cbiAgdmFyIG0gPSBuZXcgTWF0cml4NCgpOyAvLyBwcmV0dGllci1pZ25vcmVcblxuICBtLnNldCgxLCAxLCAxLCAxLCBheCAqIGF4ICsgYXkgKiBheSwgYXgsIGF5LCAxLCBieCAqIGJ4ICsgYnkgKiBieSwgYngsIGJ5LCAxLCBjeCAqIGN4ICsgY3kgKiBjeSwgY3gsIGN5LCAxKTtcbiAgdmFyIG0xMSA9IGdldE1pbm9yKG0sIDEsIDEpO1xuICB2YXIgbTEzID0gZ2V0TWlub3IobSwgMSwgMyk7XG4gIHZhciBtMTIgPSBnZXRNaW5vcihtLCAxLCAyKTtcbiAgdmFyIG0xNCA9IGdldE1pbm9yKG0sIDEsIDQpO1xuICB2YXIgeDAgPSAwLjUgKiAobTEyIC8gbTExKTtcbiAgdmFyIHkwID0gMC41ICogKG0xMyAvIG0xMSk7XG4gIHZhciByMiA9IHgwICogeDAgKyB5MCAqIHkwICsgbTE0IC8gbTExO1xuICByZXR1cm4ge1xuICAgIHg6IE1hdGguYWJzKHgwKSA9PT0gMCA/IDAgOiB4MCxcbiAgICB5OiBNYXRoLmFicyh5MCkgPT09IDAgPyAwIDogLXkwLFxuICAgIHI6IE1hdGguc3FydChyMilcbiAgfTtcbn0gLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk5ODQ3MDkvaG93LWNhbi1pLWNoZWNrLXdldGhlci1hLXBvaW50LWlzLWluc2lkZS10aGUtY2lyY3VtY2lyY2xlLW9mLTMtcG9pbnRzXG5cbmZ1bmN0aW9uIGlzUG9pbnRJbkNpcmN1bWNpcmNsZShwb2ludCwgdHJpYW5nbGUpIHtcbiAgdmFyIF9yZWYgPSBBcnJheS5pc0FycmF5KHRyaWFuZ2xlWzBdKSA/IHRyaWFuZ2xlWzBdIDogdHJpYW5nbGVbMF0udG9BcnJheSgpLFxuICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgIGF4ID0gX3JlZjJbMF0sXG4gICAgICBheSA9IF9yZWYyWzFdO1xuXG4gIHZhciBfcmVmMyA9IEFycmF5LmlzQXJyYXkodHJpYW5nbGVbMV0pID8gdHJpYW5nbGVbMV0gOiB0cmlhbmdsZVsxXS50b0FycmF5KCksXG4gICAgICBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgIGJ4ID0gX3JlZjRbMF0sXG4gICAgICBieSA9IF9yZWY0WzFdO1xuXG4gIHZhciBfcmVmNSA9IEFycmF5LmlzQXJyYXkodHJpYW5nbGVbMl0pID8gdHJpYW5nbGVbMl0gOiB0cmlhbmdsZVsyXS50b0FycmF5KCksXG4gICAgICBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAyKSxcbiAgICAgIGN4ID0gX3JlZjZbMF0sXG4gICAgICBjeSA9IF9yZWY2WzFdO1xuXG4gIHZhciBfcG9pbnQyID0gX3NsaWNlZFRvQXJyYXkocG9pbnQsIDIpLFxuICAgICAgcHggPSBfcG9pbnQyWzBdLFxuICAgICAgcHkgPSBfcG9pbnQyWzFdO1xuXG4gIGlmIChhcmVQb2ludHNDb2xsaW5lYXIodHJpYW5nbGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJDb2xsaW5lYXIgcG9pbnRzIGRvbid0IGZvcm0gYSB0cmlhbmdsZVwiKTtcbiAgLyoqXG4gICAgICAgICAgfCBheC1weCwgYXktcHksIChheC1weCnCsiArIChheS1weSnCsiB8XG4gICAgZGV0ID0gfCBieC1weCwgYnktcHksIChieC1weCnCsiArIChieS1weSnCsiB8XG4gICAgICAgICAgfCBjeC1weCwgY3ktcHksIChjeC1weCnCsiArIChjeS1weSnCsiB8XG4gICovXG5cbiAgdmFyIHgxbXB4ID0gYXggLSBweDtcbiAgdmFyIGF5bXB5ID0gYXkgLSBweTtcbiAgdmFyIGJ4bXB4ID0gYnggLSBweDtcbiAgdmFyIGJ5bXB5ID0gYnkgLSBweTtcbiAgdmFyIGN4bXB4ID0gY3ggLSBweDtcbiAgdmFyIGN5bXB5ID0gY3kgLSBweTsgLy8gcHJldHRpZXItaWdub3JlXG5cbiAgdmFyIGQgPSBkZXRlcm1pbmFudDMoeDFtcHgsIGF5bXB5LCB4MW1weCAqIHgxbXB4ICsgYXltcHkgKiBheW1weSwgYnhtcHgsIGJ5bXB5LCBieG1weCAqIGJ4bXB4ICsgYnltcHkgKiBieW1weSwgY3htcHgsIGN5bXB5LCBjeG1weCAqIGN4bXB4ICsgY3ltcHkgKiBjeW1weSk7IC8vIGlmIGQgaXMgMCwgdGhlIHBvaW50IGlzIG9uIENcblxuICBpZiAoZCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuICFpc1RyaWFuZ2xlQ2xvY2t3aXNlKHRyaWFuZ2xlKSA/IGQgPiAwIDogZCA8IDA7XG59IC8vIEZyb20gaHR0cHM6Ly9hbGdvcml0aG10dXRvci5jb20vQ29tcHV0YXRpb25hbC1HZW9tZXRyeS9EZXRlcm1pbmluZy1pZi10d28tY29uc2VjdXRpdmUtc2VnbWVudHMtdHVybi1sZWZ0LW9yLXJpZ2h0L1xuXG52YXIgbXYxID0gbmV3IFZlY3RvcjIoKTtcbnZhciBtdjIgPSBuZXcgVmVjdG9yMigpO1xuLyoqXG4gXG4gICAgIOKVsSAgICAgIOKVsiAgICAgXG4gICAg4pWxICAgICAgICDilbIgICAgXG4gICDilpUgICAgICAgICAg4paPICAgXG4gICAgICAgICAgICAgICAgICBcbiByaWdodCAgICAgIGxlZnQgIFxuXG4gKiBOT1RFOiBTaG91bGQgdGhpcyB1c2UgYSBidWZmZXIgaW5zdGVhZD8gW3gwLCB5MCwgeDEsIHkxXT9cbiAqL1xuXG5mdW5jdGlvbiBkb1RocmVlUG9pbnRzTWFrZUFSaWdodChwb2ludHMpIHtcbiAgdmFyIF9wb2ludHMkbWFwID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHApKSB7XG4gICAgICByZXR1cm4gX2NvbnN0cnVjdChWZWN0b3IyLCBfdG9Db25zdW1hYmxlQXJyYXkocCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9KSxcbiAgICAgIF9wb2ludHMkbWFwMiA9IF9zbGljZWRUb0FycmF5KF9wb2ludHMkbWFwLCAzKSxcbiAgICAgIHAxID0gX3BvaW50cyRtYXAyWzBdLFxuICAgICAgcDIgPSBfcG9pbnRzJG1hcDJbMV0sXG4gICAgICBwMyA9IF9wb2ludHMkbWFwMlsyXTtcblxuICBpZiAoYXJlUG9pbnRzQ29sbGluZWFyKHBvaW50cykpIHJldHVybiBmYWxzZTsgLy8gQHRzLWlnbm9yZVxuXG4gIHZhciBwMnAxID0gbXYxLnN1YlZlY3RvcnMocDIsIHAxKTsgLy8gQHRzLWlnbm9yZVxuXG4gIHZhciBwM3AxID0gbXYyLnN1YlZlY3RvcnMocDMsIHAxKTtcbiAgdmFyIGNyb3NzID0gcDNwMS5jcm9zcyhwMnAxKTtcbiAgcmV0dXJuIGNyb3NzID4gMDtcbn1cblxudmFyIHRyaWFuZ2xlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGlzUG9pbnRJblRyaWFuZ2xlOiBpc1BvaW50SW5UcmlhbmdsZSxcbiAgdHJpYW5nbGVEZXRlcm1pbmFudDogdHJpYW5nbGVEZXRlcm1pbmFudCxcbiAgYXJlUG9pbnRzQ29sbGluZWFyOiBhcmVQb2ludHNDb2xsaW5lYXIsXG4gIGlzVHJpYW5nbGVDbG9ja3dpc2U6IGlzVHJpYW5nbGVDbG9ja3dpc2UsXG4gIGdldENpcmN1bWNpcmNsZTogZ2V0Q2lyY3VtY2lyY2xlLFxuICBpc1BvaW50SW5DaXJjdW1jaXJjbGU6IGlzUG9pbnRJbkNpcmN1bWNpcmNsZSxcbiAgZG9UaHJlZVBvaW50c01ha2VBUmlnaHQ6IGRvVGhyZWVQb2ludHNNYWtlQVJpZ2h0XG59KTtcblxuZXhwb3J0IHsgX3NsaWNlZFRvQXJyYXkgYXMgXywgX3RvQ29uc3VtYWJsZUFycmF5IGFzIGEsIHRyaWFuZ2xlRGV0ZXJtaW5hbnQgYXMgYiwgYXJlUG9pbnRzQ29sbGluZWFyIGFzIGMsIGRvVGhyZWVQb2ludHNNYWtlQVJpZ2h0IGFzIGQsIGlzVHJpYW5nbGVDbG9ja3dpc2UgYXMgZSwgaXNQb2ludEluQ2lyY3VtY2lyY2xlIGFzIGYsIGdldENpcmN1bWNpcmNsZSBhcyBnLCBpc1BvaW50SW5UcmlhbmdsZSBhcyBpLCB0cmlhbmdsZSBhcyB0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/triangle-b62b9067.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/vector2-f44fd63e.cjs.dev.js":
/*!*************************************************************!*\
  !*** ./node_modules/maath/dist/vector2-f44fd63e.cjs.dev.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n/**\n *\n */\nfunction zero() {\n  return [0, 0];\n}\nfunction one() {\n  return [1, 1];\n}\nfunction add(a, b) {\n  return [a[0] + b[0], a[1] + b[1]];\n}\nfunction addValue(a, n) {\n  return [a[0] + n, a[1] + n];\n}\nfunction sub(a, b) {\n  return [a[0] - b[0], a[1] - b[1]];\n}\nfunction subValue(a, n) {\n  return [a[0] - n, a[1] - n];\n}\nfunction scale(a, n) {\n  return [a[0] * n, a[1] * n];\n}\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Calculate the squared length of a vector.\n * Use this when comparing two vectors instead of length, as it's more efficient (no sqrt)\n */\n\nfunction lengthSqr(a) {\n  return a[0] * a[0] + a[1] * a[1];\n}\n/**\n * Calculate the length of a vector.\n * If you only need to compare lenghts, consider using the more efficient lengthSqr\n */\n\nfunction length(a) {\n  return Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n}\nfunction distance(a, b) {\n  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\n}\n\nvar vector2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  zero: zero,\n  one: one,\n  add: add,\n  addValue: addValue,\n  sub: sub,\n  subValue: subValue,\n  scale: scale,\n  dot: dot,\n  lengthSqr: lengthSqr,\n  length: length,\n  distance: distance\n});\n\nexports.add = add;\nexports.addValue = addValue;\nexports.distance = distance;\nexports.dot = dot;\nexports.length = length;\nexports.lengthSqr = lengthSqr;\nexports.one = one;\nexports.scale = scale;\nexports.sub = sub;\nexports.subValue = subValue;\nexports.vector2 = vector2;\nexports.zero = zero;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC92ZWN0b3IyLWY0NGZkNjNlLmNqcy5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXO0FBQ1gsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1gsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixXQUFXO0FBQ1gsYUFBYTtBQUNiLFdBQVc7QUFDWCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9tYWF0aC9kaXN0L3ZlY3RvcjItZjQ0ZmQ2M2UuY2pzLmRldi5qcz9kMDlhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKlxuICovXG5mdW5jdGlvbiB6ZXJvKCkge1xuICByZXR1cm4gWzAsIDBdO1xufVxuZnVuY3Rpb24gb25lKCkge1xuICByZXR1cm4gWzEsIDFdO1xufVxuZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgcmV0dXJuIFthWzBdICsgYlswXSwgYVsxXSArIGJbMV1dO1xufVxuZnVuY3Rpb24gYWRkVmFsdWUoYSwgbikge1xuICByZXR1cm4gW2FbMF0gKyBuLCBhWzFdICsgbl07XG59XG5mdW5jdGlvbiBzdWIoYSwgYikge1xuICByZXR1cm4gW2FbMF0gLSBiWzBdLCBhWzFdIC0gYlsxXV07XG59XG5mdW5jdGlvbiBzdWJWYWx1ZShhLCBuKSB7XG4gIHJldHVybiBbYVswXSAtIG4sIGFbMV0gLSBuXTtcbn1cbmZ1bmN0aW9uIHNjYWxlKGEsIG4pIHtcbiAgcmV0dXJuIFthWzBdICogbiwgYVsxXSAqIG5dO1xufVxuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWN0b3IuXG4gKiBVc2UgdGhpcyB3aGVuIGNvbXBhcmluZyB0d28gdmVjdG9ycyBpbnN0ZWFkIG9mIGxlbmd0aCwgYXMgaXQncyBtb3JlIGVmZmljaWVudCAobm8gc3FydClcbiAqL1xuXG5mdW5jdGlvbiBsZW5ndGhTcXIoYSkge1xuICByZXR1cm4gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IuXG4gKiBJZiB5b3Ugb25seSBuZWVkIHRvIGNvbXBhcmUgbGVuZ2h0cywgY29uc2lkZXIgdXNpbmcgdGhlIG1vcmUgZWZmaWNpZW50IGxlbmd0aFNxclxuICovXG5cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXSk7XG59XG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoKGFbMF0gLSBiWzBdKSAqIChhWzBdIC0gYlswXSkgKyAoYVsxXSAtIGJbMV0pICogKGFbMV0gLSBiWzFdKSk7XG59XG5cbnZhciB2ZWN0b3IyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHplcm86IHplcm8sXG4gIG9uZTogb25lLFxuICBhZGQ6IGFkZCxcbiAgYWRkVmFsdWU6IGFkZFZhbHVlLFxuICBzdWI6IHN1YixcbiAgc3ViVmFsdWU6IHN1YlZhbHVlLFxuICBzY2FsZTogc2NhbGUsXG4gIGRvdDogZG90LFxuICBsZW5ndGhTcXI6IGxlbmd0aFNxcixcbiAgbGVuZ3RoOiBsZW5ndGgsXG4gIGRpc3RhbmNlOiBkaXN0YW5jZVxufSk7XG5cbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5hZGRWYWx1ZSA9IGFkZFZhbHVlO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5kb3QgPSBkb3Q7XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMubGVuZ3RoU3FyID0gbGVuZ3RoU3FyO1xuZXhwb3J0cy5vbmUgPSBvbmU7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLnN1YiA9IHN1YjtcbmV4cG9ydHMuc3ViVmFsdWUgPSBzdWJWYWx1ZTtcbmV4cG9ydHMudmVjdG9yMiA9IHZlY3RvcjI7XG5leHBvcnRzLnplcm8gPSB6ZXJvO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/vector2-f44fd63e.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/dist/vector3-5e723d1a.cjs.dev.js":
/*!*************************************************************!*\
  !*** ./node_modules/maath/dist/vector3-5e723d1a.cjs.dev.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n/**\n *\n */\nfunction zero() {\n  return [0, 0, 0];\n}\nfunction one() {\n  return [1, 1, 1];\n}\nfunction add(a, b) {\n  return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];\n}\nfunction addValue(a, n) {\n  return [a[0] + n, a[1] + n, a[2] + n];\n}\nfunction sub(a, b) {\n  return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\n}\nfunction subValue(a, n) {\n  return [a[0] - n, a[1] - n, a[2] - n];\n}\nfunction scale(a, n) {\n  return [a[0] * n, a[1] * n, a[2] * n];\n}\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\nfunction cross(a, b) {\n  var x = a[1] * b[2] - a[2] * b[1];\n  var y = a[2] * b[0] - a[0] * b[2];\n  var z = a[0] * b[1] - a[1] * b[0];\n  return [x, y, z];\n}\n/**\n * Calculate the squared length of a vector.\n * Use this when comparing two vectors instead of length, as it's more efficient (no sqrt)\n */\n\nfunction lengthSqr(a) {\n  return a[0] * a[0] + a[1] * a[1] + a[2] * a[2];\n}\n/**\n * Calculate the length of a vector.\n * If you only need to compare lenghts, consider using the more efficient lengthSqr\n */\n\nfunction length(a) {\n  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);\n}\nfunction distance(a, b) {\n  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]) + (a[2] - b[2]) * (a[2] - b[2]));\n}\n\nvar vector3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  zero: zero,\n  one: one,\n  add: add,\n  addValue: addValue,\n  sub: sub,\n  subValue: subValue,\n  scale: scale,\n  dot: dot,\n  cross: cross,\n  lengthSqr: lengthSqr,\n  length: length,\n  distance: distance\n});\n\nexports.add = add;\nexports.addValue = addValue;\nexports.cross = cross;\nexports.distance = distance;\nexports.dot = dot;\nexports.length = length;\nexports.lengthSqr = lengthSqr;\nexports.one = one;\nexports.scale = scale;\nexports.sub = sub;\nexports.subValue = subValue;\nexports.vector3 = vector3;\nexports.zero = zero;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC92ZWN0b3IzLTVlNzIzZDFhLmNqcy5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELFdBQVc7QUFDWCxnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1gsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixXQUFXO0FBQ1gsYUFBYTtBQUNiLFdBQVc7QUFDWCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9tYWF0aC9kaXN0L3ZlY3RvcjMtNWU3MjNkMWEuY2pzLmRldi5qcz9lNWI2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKlxuICovXG5mdW5jdGlvbiB6ZXJvKCkge1xuICByZXR1cm4gWzAsIDAsIDBdO1xufVxuZnVuY3Rpb24gb25lKCkge1xuICByZXR1cm4gWzEsIDEsIDFdO1xufVxuZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgcmV0dXJuIFthWzBdICsgYlswXSwgYVsxXSArIGJbMV0sIGFbMl0gKyBiWzJdXTtcbn1cbmZ1bmN0aW9uIGFkZFZhbHVlKGEsIG4pIHtcbiAgcmV0dXJuIFthWzBdICsgbiwgYVsxXSArIG4sIGFbMl0gKyBuXTtcbn1cbmZ1bmN0aW9uIHN1YihhLCBiKSB7XG4gIHJldHVybiBbYVswXSAtIGJbMF0sIGFbMV0gLSBiWzFdLCBhWzJdIC0gYlsyXV07XG59XG5mdW5jdGlvbiBzdWJWYWx1ZShhLCBuKSB7XG4gIHJldHVybiBbYVswXSAtIG4sIGFbMV0gLSBuLCBhWzJdIC0gbl07XG59XG5mdW5jdGlvbiBzY2FsZShhLCBuKSB7XG4gIHJldHVybiBbYVswXSAqIG4sIGFbMV0gKiBuLCBhWzJdICogbl07XG59XG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuZnVuY3Rpb24gY3Jvc3MoYSwgYikge1xuICB2YXIgeCA9IGFbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV07XG4gIHZhciB5ID0gYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXTtcbiAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICByZXR1cm4gW3gsIHksIHpdO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjdG9yLlxuICogVXNlIHRoaXMgd2hlbiBjb21wYXJpbmcgdHdvIHZlY3RvcnMgaW5zdGVhZCBvZiBsZW5ndGgsIGFzIGl0J3MgbW9yZSBlZmZpY2llbnQgKG5vIHNxcnQpXG4gKi9cblxuZnVuY3Rpb24gbGVuZ3RoU3FyKGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzBdICsgYVsxXSAqIGFbMV0gKyBhWzJdICogYVsyXTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IuXG4gKiBJZiB5b3Ugb25seSBuZWVkIHRvIGNvbXBhcmUgbGVuZ2h0cywgY29uc2lkZXIgdXNpbmcgdGhlIG1vcmUgZWZmaWNpZW50IGxlbmd0aFNxclxuICovXG5cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXSArIGFbMl0gKiBhWzJdKTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguc3FydCgoYVswXSAtIGJbMF0pICogKGFbMF0gLSBiWzBdKSArIChhWzFdIC0gYlsxXSkgKiAoYVsxXSAtIGJbMV0pICsgKGFbMl0gLSBiWzJdKSAqIChhWzJdIC0gYlsyXSkpO1xufVxuXG52YXIgdmVjdG9yMyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICB6ZXJvOiB6ZXJvLFxuICBvbmU6IG9uZSxcbiAgYWRkOiBhZGQsXG4gIGFkZFZhbHVlOiBhZGRWYWx1ZSxcbiAgc3ViOiBzdWIsXG4gIHN1YlZhbHVlOiBzdWJWYWx1ZSxcbiAgc2NhbGU6IHNjYWxlLFxuICBkb3Q6IGRvdCxcbiAgY3Jvc3M6IGNyb3NzLFxuICBsZW5ndGhTcXI6IGxlbmd0aFNxcixcbiAgbGVuZ3RoOiBsZW5ndGgsXG4gIGRpc3RhbmNlOiBkaXN0YW5jZVxufSk7XG5cbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5hZGRWYWx1ZSA9IGFkZFZhbHVlO1xuZXhwb3J0cy5jcm9zcyA9IGNyb3NzO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5kb3QgPSBkb3Q7XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMubGVuZ3RoU3FyID0gbGVuZ3RoU3FyO1xuZXhwb3J0cy5vbmUgPSBvbmU7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLnN1YiA9IHN1YjtcbmV4cG9ydHMuc3ViVmFsdWUgPSBzdWJWYWx1ZTtcbmV4cG9ydHMudmVjdG9yMyA9IHZlY3RvcjM7XG5leHBvcnRzLnplcm8gPSB6ZXJvO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/dist/vector3-5e723d1a.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maath/random/dist/maath-random.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/maath/random/dist/maath-random.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FlashGen: () => (/* reexport safe */ _dist_index_0332b2ed_esm_js__WEBPACK_IMPORTED_MODULE_2__.F),\n/* harmony export */   Generator: () => (/* reexport safe */ _dist_index_0332b2ed_esm_js__WEBPACK_IMPORTED_MODULE_2__.G),\n/* harmony export */   inBox: () => (/* reexport safe */ _dist_index_0332b2ed_esm_js__WEBPACK_IMPORTED_MODULE_2__.f),\n/* harmony export */   inCircle: () => (/* reexport safe */ _dist_index_0332b2ed_esm_js__WEBPACK_IMPORTED_MODULE_2__.b),\n/* harmony export */   inRect: () => (/* reexport safe */ _dist_index_0332b2ed_esm_js__WEBPACK_IMPORTED_MODULE_2__.d),\n/* harmony export */   inSphere: () => (/* reexport safe */ _dist_index_0332b2ed_esm_js__WEBPACK_IMPORTED_MODULE_2__.a),\n/* harmony export */   noise: () => (/* reexport safe */ _dist_index_0332b2ed_esm_js__WEBPACK_IMPORTED_MODULE_2__.n),\n/* harmony export */   onBox: () => (/* reexport safe */ _dist_index_0332b2ed_esm_js__WEBPACK_IMPORTED_MODULE_2__.g),\n/* harmony export */   onCircle: () => (/* reexport safe */ _dist_index_0332b2ed_esm_js__WEBPACK_IMPORTED_MODULE_2__.c),\n/* harmony export */   onRect: () => (/* reexport safe */ _dist_index_0332b2ed_esm_js__WEBPACK_IMPORTED_MODULE_2__.e),\n/* harmony export */   onSphere: () => (/* reexport safe */ _dist_index_0332b2ed_esm_js__WEBPACK_IMPORTED_MODULE_2__.o)\n/* harmony export */ });\n/* harmony import */ var _dist_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/objectSpread2-284232a6.esm.js */ \"(ssr)/./node_modules/maath/dist/objectSpread2-284232a6.esm.js\");\n/* harmony import */ var _dist_classCallCheck_9098b006_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/classCallCheck-9098b006.esm.js */ \"(ssr)/./node_modules/maath/dist/classCallCheck-9098b006.esm.js\");\n/* harmony import */ var _dist_index_0332b2ed_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dist/index-0332b2ed.esm.js */ \"(ssr)/./node_modules/maath/dist/index-0332b2ed.esm.js\");\n/* harmony import */ var _dist_misc_19a3ec46_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dist/misc-19a3ec46.esm.js */ \"(ssr)/./node_modules/maath/dist/misc-19a3ec46.esm.js\");\n/* harmony import */ var _dist_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../dist/triangle-b62b9067.esm.js */ \"(ssr)/./node_modules/maath/dist/triangle-b62b9067.esm.js\");\n/* harmony import */ var _dist_isNativeReflectConstruct_5594d075_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../dist/isNativeReflectConstruct-5594d075.esm.js */ \"(ssr)/./node_modules/maath/dist/isNativeReflectConstruct-5594d075.esm.js\");\n/* harmony import */ var _dist_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../dist/matrix-baa530bf.esm.js */ \"(ssr)/./node_modules/maath/dist/matrix-baa530bf.esm.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFhdGgvcmFuZG9tL2Rpc3QvbWFhdGgtcmFuZG9tLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0Q7QUFDQztBQUN3SjtBQUNsSztBQUNJO0FBQ2dCO0FBQzlDO0FBQzRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWFhdGgvcmFuZG9tL2Rpc3QvbWFhdGgtcmFuZG9tLmVzbS5qcz8zNjFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vLi4vZGlzdC9vYmplY3RTcHJlYWQyLTI4NDIzMmE2LmVzbS5qcyc7XG5pbXBvcnQgJy4uLy4uL2Rpc3QvY2xhc3NDYWxsQ2hlY2stOTA5OGIwMDYuZXNtLmpzJztcbmV4cG9ydCB7IEYgYXMgRmxhc2hHZW4sIEcgYXMgR2VuZXJhdG9yLCBmIGFzIGluQm94LCBiIGFzIGluQ2lyY2xlLCBkIGFzIGluUmVjdCwgYSBhcyBpblNwaGVyZSwgbiBhcyBub2lzZSwgZyBhcyBvbkJveCwgYyBhcyBvbkNpcmNsZSwgZSBhcyBvblJlY3QsIG8gYXMgb25TcGhlcmUgfSBmcm9tICcuLi8uLi9kaXN0L2luZGV4LTAzMzJiMmVkLmVzbS5qcyc7XG5pbXBvcnQgJy4uLy4uL2Rpc3QvbWlzYy0xOWEzZWM0Ni5lc20uanMnO1xuaW1wb3J0ICcuLi8uLi9kaXN0L3RyaWFuZ2xlLWI2MmI5MDY3LmVzbS5qcyc7XG5pbXBvcnQgJy4uLy4uL2Rpc3QvaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LTU1OTRkMDc1LmVzbS5qcyc7XG5pbXBvcnQgJ3RocmVlJztcbmltcG9ydCAnLi4vLi4vZGlzdC9tYXRyaXgtYmFhNTMwYmYuZXNtLmpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maath/random/dist/maath-random.esm.js\n");

/***/ })

};
;